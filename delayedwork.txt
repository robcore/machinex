arch/arm/kernel/auto_hotplug.c
arch/arm/kernel/autosmp.c
arch/arm/mach-msm/bam_dmux.c
arch/arm/mach-msm/board-mahimahi-microp.c
arch/arm/mach-msm/board-msm8x60.c
arch/arm/mach-msm/dma.c
arch/arm/mach-msm/ipc_router_hsic_xprt.c
arch/arm/mach-msm/ipc_router_smd_xprt.c
arch/arm/mach-msm/lge/mako/board-mako-earjack-debugger.c
arch/arm/mach-msm/mdm_common.c
arch/arm/mach-msm/modem-8660.c
arch/arm/mach-msm/msm_dcvs.c
arch/arm/mach-msm/msm_watchdog.c
arch/arm/mach-msm/msm_watchdog_v2.c
arch/arm/mach-msm/msm_zen_decision.c
arch/arm/mach-msm/ocmem_sched.c
arch/arm/mach-msm/peripheral-loader.c
arch/arm/mach-msm/rmt_storage_client.c
arch/arm/mach-msm/rpcrouter_sdio_xprt.c
arch/arm/mach-msm/rpm-regulator.c
arch/arm/mach-msm/sdio_dmux.c
arch/arm/mach-msm/sec_thermistor.c
arch/arm/mach-msm/smd_pkt.c
arch/arm/mach-msm/smd_tty.c
arch/arm/mach-msm/state_helper.c
arch/arm/mach-msm/wcnss-ssr-8960.c
arch/arm/mach-pxa/sharpsl_pm.c
arch/arm/mach-s3c24xx/mach-gta02.c
arch/arm/mach-shmobile/board-mackerel.c
arch/arm/mvp/commkm/comm_os_linux.c
arch/arm/mvp/oektestkm/mvp_fake_kb.c
arch/arm/mvp/pvtcpkm/comm_os_linux.c
arch/tile/kernel/smpboot.c
arch/um/drivers/chan_kern.c
arch/x86/kernel/check.c
arch/x86/kernel/hpet.c
arch/x86/kernel/tsc.c
block/blk-core.c
block/blk-mq.c
block/blk-throttle.c
block/genhd.c
drivers/ata/libata-eh.c
drivers/ata/libata-scsi.c
drivers/ata/libata-sff.c
drivers/ata/pata_arasan_cf.c
drivers/ata/pata_octeon_cf.c
drivers/auxdisplay/cfag12864b.c
drivers/barcode_emul/barcode_emul_ice4_8930_442.c
drivers/barcode_emul/barcode_emul_ice4_8930.c
drivers/barcode_emul/barcode_emul_ice4.c
drivers/base/devcoredump.c
drivers/base/firmware_class.c
drivers/battery/max17050_fuelgauge.c
drivers/battery/max77693_charger_8930.c
drivers/battery/max77693_charger.c
drivers/battery/sec_battery_8930.c
drivers/battery/sec_battery.c
drivers/battery/sec_charger_8930.c
drivers/battery/sec_charger.c
drivers/battery/sec_fuelgauge_8930.c
drivers/battery/sec_fuelgauge.c
drivers/block/paride/pd.c
drivers/block/paride/pseudo.h
drivers/bluetooth/bluesleep_bcm.c
drivers/bluetooth/bluesleep.c
drivers/char/hw_random/n2-drv.c
drivers/char/msm_rotator.c
drivers/cpufreq/cpu-boost.c
drivers/cpufreq/cpufreq_abyssplugv2.c
drivers/cpufreq/cpufreq_adaptive.c
drivers/cpufreq/cpufreq_alucard.c
drivers/cpufreq/cpufreq_bioshock.c
drivers/cpufreq/cpufreq.c
drivers/cpufreq/cpufreq_dancedance.c
drivers/cpufreq/cpufreq_darkness.c
drivers/cpufreq/cpufreq_electroactive.c
drivers/cpufreq/cpufreq_electrodemand.c
drivers/cpufreq/cpufreq_elementalx.c
drivers/cpufreq/cpufreq_lazy.c
drivers/cpufreq/cpufreq_lightning.c
drivers/cpufreq/cpufreq_lionfish.c
drivers/cpufreq/cpufreq_lionheart.c
drivers/cpufreq/cpufreq_medusa.c
drivers/cpufreq/cpufreq_pegasusq.c
drivers/cpufreq/cpufreq_preservative.c
drivers/cpufreq/cpufreq_smartmax.c
drivers/cpufreq/cpufreq_smartmax_eps.c
drivers/cpufreq/cpufreq_stockdemand.c
drivers/cpufreq/cpufreq_uberdemand.c
drivers/cpufreq/cpufreq_wheatley.c
drivers/cpufreq/cpufreq_zzmoove.c
drivers/cpu_hotplug/autosmp.c
drivers/cpu_hotplug/blu_plug.c
drivers/cpu_hotplug/bricked_hotplug.c
drivers/cpu_hotplug/dyn_hotplug.c
drivers/cpu_hotplug/intelli_hotplug.c
drivers/cpu_hotplug/mako_hotplug.c
drivers/cpu_hotplug/msm_hotplug.c
drivers/cpu_hotplug/mx_hotplug.c
drivers/cpuquiet/governors/balanced.c
drivers/cpuquiet/governors/rqbalance.c
drivers/crypto/hifn_795x.c
drivers/devfreq/devfreq.c
drivers/edac/edac_device.c
drivers/edac/edac_mc.c
drivers/edac/edac_pci.c
drivers/edac/i5100_edac.c
drivers/felica/felica.c
drivers/firewire/core-card.c
drivers/firewire/core-cdev.c
drivers/firewire/core-device.c
drivers/firewire/sbp2.c
drivers/gpu/drm/drm_crtc_helper.c
drivers/gpu/drm/i915/i915_gem.c
drivers/gpu/drm/i915/intel_display.c
drivers/gpu/drm/i915/intel_dp.c
drivers/gpu/drm/radeon/radeon_pm.c
drivers/gpu/drm/ttm/ttm_bo.c
drivers/gpu/drm/udl/udl_main.c
drivers/gpu/drm/vmwgfx/vmwgfx_fb.c
drivers/hid/hid-picolcd.c
drivers/hv/hv_kvp.c
drivers/infiniband/core/addr.c
drivers/infiniband/core/cm.c
drivers/infiniband/core/mad.c
drivers/infiniband/core/mad_rmpp.c
drivers/infiniband/hw/cxgb3/iwch.c
drivers/infiniband/hw/nes/nes_hw.c
drivers/infiniband/hw/nes/nes_nic.c
drivers/infiniband/hw/qib/qib_iba7220.c
drivers/infiniband/hw/qib/qib_iba7322.c
drivers/infiniband/ulp/ipoib/ipoib_cm.c
drivers/infiniband/ulp/ipoib/ipoib_ib.c
drivers/infiniband/ulp/ipoib/ipoib_multicast.c
drivers/input/input_booster.c
drivers/input/input-polldev.c
drivers/input/joystick/tdisc_vtd518_shinetsu.c
drivers/input/keyboard/adp5588-keys.c
drivers/input/keyboard/atkbd.c
drivers/input/keyboard/gpio_keys.c
drivers/input/keyboard/matrix_keypad.c
drivers/input/keyboard/qt2160.c
drivers/input/keyboard/tca6416-keypad.c
drivers/input/keyreset.c
drivers/input/misc/bma150.c
drivers/input/misc/bmp18x-core.c
drivers/input/misc/da9052_onkey.c
drivers/input/misc/lis3dh_acc.c
drivers/input/misc/mpu3050.c
drivers/input/misc/mpu6050/mpu6050_input.c
drivers/input/misc/mpu6500/mpu6500_input.c
drivers/input/misc/pmic8058-othc.c
drivers/input/misc/wm831x-on.c
drivers/input/mouse/psmouse-base.c
drivers/input/mouse/synaptics_i2c.c
drivers/input/serio/hp_sdc.c
drivers/input/touchscreen/atmel_maxtouch.c
drivers/input/touchscreen/cy8c_ts.c
drivers/input/touchscreen/cyttsp4_mt_common.c
drivers/input/touchscreen/da9034-ts.c
drivers/input/touchscreen/hp680_ts_input.c
drivers/input/touchscreen/ili210x.c
drivers/input/touchscreen/lge_touch_core.c
drivers/input/touchscreen/mc13783_ts.c
drivers/input/touchscreen/mms_ts_144.c
drivers/input/touchscreen/mxt224e.c
drivers/input/touchscreen/mxts.c
drivers/input/touchscreen/mxts_msm8930.c
drivers/input/touchscreen/mxts_sec_msm8930.c
drivers/input/touchscreen/pcap_ts.c
drivers/input/touchscreen/rmi_f54.c
drivers/input/touchscreen/rmi_f54_msm8930.c
drivers/input/touchscreen/stmpe-ts.c
drivers/input/touchscreen/sweep2sleep.c
drivers/input/touchscreen/synaptics_fw_update.c
drivers/input/touchscreen/synaptics_i2c_rmi4.c
drivers/input/touchscreen/synaptics_i2c_rmi.c
drivers/input/touchscreen/synaptics_i2c_rmi_msm8930.c
drivers/input/touchscreen/tps6507x-ts.c
drivers/input/touchscreen/tsc2005.c
drivers/input/touchscreen/tsc2007.c
drivers/input/touchscreen/wm97xx-core.c
drivers/macintosh/rack-meter.c
drivers/md/bcache/btree.c
drivers/md/bcache/journal.c
drivers/md/bcache/sysfs.c
drivers/md/bcache/writeback.c
drivers/md/dm-bufio.c
drivers/md/dm-cache-target.c
drivers/md/dm-log-userspace-base.c
drivers/md/dm-mpath.c
drivers/md/dm-thin.c
drivers/media/dvb/b2c2/flexcop-pci.c
drivers/media/dvb/dvb-usb/dvb-usb-remote.c
drivers/media/dvb/dvb-usb/technisat-usb2.c
drivers/media/dvb/frontends/af9013.c
drivers/media/isdbtmm/tuner_drv.c
drivers/media/radio/radio-tavarua.c
drivers/media/video/em28xx/em28xx-input.c
drivers/media/video/ir-kbd-i2c.c
drivers/media/video/saa6588.c
drivers/media/video/tm6000/tm6000-input.c
drivers/message/fusion/mptbase.c
drivers/message/fusion/mptlan.c
drivers/message/i2o/i2o_block.c
drivers/mfd/tps65010.c
drivers/misc/arm-charlcd.c
drivers/misc/bh1770glc.c
drivers/misc/fsa9485.c
drivers/misc/fsa9485_lt02.c
drivers/misc/inv_mpu/mpuirq.c
drivers/misc/max77693-muic.c
drivers/misc/max77693-muic_melius.c
drivers/misc/max77693-muic_serrano.c
drivers/misc/slimport_anx7808/slimport.c
drivers/misc/tsu6721.c
drivers/misc/vmw_balloon.c
drivers/mmc/core/core.c
drivers/mmc/core/host.c
drivers/mmc/host/sh_mmcif.c
drivers/mmc/host/tmio_mmc_pio.c
drivers/mmc/host/vub300.c
drivers/mtd/nand/r852.c
drivers/net/bonding/bond_3ad.c
drivers/net/bonding/bond_alb.c
drivers/net/bonding/bond_main.c
drivers/net/bonding/bond_sysfs.c
drivers/net/can/sja1000/peak_pci.c
drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.c
drivers/net/ethernet/broadcom/bnx2x/bnx2x_dcb.c
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c
drivers/net/ethernet/broadcom/cnic.c
drivers/net/ethernet/chelsio/cxgb3/cxgb3_main.c
drivers/net/ethernet/chelsio/cxgb/cxgb2.c
drivers/net/ethernet/chelsio/cxgb/my3126.c
drivers/net/ethernet/davicom/dm9000.c
drivers/net/ethernet/emulex/benet/be_main.c
drivers/net/ethernet/ibm/ehea/ehea_main.c
drivers/net/ethernet/ibm/emac/core.c
drivers/net/ethernet/icplus/ipg.c
drivers/net/ethernet/intel/e1000/e1000_main.c
drivers/net/ethernet/intel/e1000e/netdev.c
drivers/net/ethernet/mellanox/mlx4/en_netdev.c
drivers/net/ethernet/mellanox/mlx4/sense.c
drivers/net/ethernet/qlogic/netxen/netxen_nic_main.c
drivers/net/ethernet/qlogic/qla3xxx.c
drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c
drivers/net/ethernet/qlogic/qlge/qlge_main.c
drivers/net/ethernet/qlogic/qlge/qlge_mpi.c
drivers/net/ethernet/realtek/8139too.c
drivers/net/ethernet/sfc/efx.c
drivers/net/ethernet/sfc/selftest.c
drivers/net/ethernet/tile/tilepro.c
drivers/net/ethernet/toshiba/ps3_gelic_wireless.c
drivers/net/hamradio/baycom_epp.c
drivers/net/hyperv/netvsc_drv.c
drivers/net/irda/sir_dev.c
drivers/net/phy/phy.c
drivers/net/plip/plip.c
drivers/net/usb/ipheth.c
drivers/net/usb/kaweth.c
drivers/net/usb/pegasus.c
drivers/net/virtio_net.c
drivers/net/wireless/at76c50x-usb.c
drivers/net/wireless/ath/ath5k/base.c
drivers/net/wireless/ath/ath9k/htc_drv_gpio.c
drivers/net/wireless/ath/ath9k/htc_drv_main.c
drivers/net/wireless/ath/ath9k/main.c
drivers/net/wireless/ath/ath9k/xmit.c
drivers/net/wireless/ath/carl9170/led.c
drivers/net/wireless/ath/carl9170/main.c
drivers/net/wireless/ath/carl9170/tx.c
drivers/net/wireless/b43legacy/main.c
drivers/net/wireless/b43/main.c
drivers/net/wireless/bcmdhd/wl_cfg80211.c
drivers/net/wireless/brcm80211/brcmsmac/mac80211_if.c
drivers/net/wireless/ipw2x00/ipw2100.c
drivers/net/wireless/ipw2x00/ipw2200.c
drivers/net/wireless/iwlegacy/3945.c
drivers/net/wireless/iwlegacy/3945-mac.c
drivers/net/wireless/iwlegacy/4965-mac.c
drivers/net/wireless/iwlegacy/common.c
drivers/net/wireless/iwlwifi/iwl-scan.c
drivers/net/wireless/iwmc3200wifi/rx.c
drivers/net/wireless/libertas/cfg.c
drivers/net/wireless/mac80211_hwsim.c
drivers/net/wireless/p54/led.c
drivers/net/wireless/p54/main.c
drivers/net/wireless/p54/txrx.c
drivers/net/wireless/rndis_wlan.c
drivers/net/wireless/rt2x00/rt2x00config.c
drivers/net/wireless/rt2x00/rt2x00link.c
drivers/net/wireless/rtl818x/rtl8180/dev.c
drivers/net/wireless/rtl818x/rtl8187/dev.c
drivers/net/wireless/rtl818x/rtl8187/leds.c
drivers/net/wireless/rtlwifi/base.c
drivers/net/wireless/rtlwifi/core.c
drivers/net/wireless/rtlwifi/ps.c
drivers/net/wireless/wcnss/wcnss_wlan.c
drivers/net/wireless/wl1251/ps.c
drivers/net/wireless/wl12xx/main.c
drivers/net/wireless/wl12xx/ps.c
drivers/net/wireless/wl12xx/scan.c
drivers/net/wireless/zd1211rw/zd_mac.c
drivers/net/wireless/zd1211rw/zd_usb.c
drivers/oprofile/cpu_buffer.c
drivers/oprofile/oprof.c
drivers/parisc/led.c
drivers/pci/hotplug/pciehp_ctrl.c
drivers/pci/hotplug/shpchp_ctrl.c
drivers/pci/pci.c
drivers/platform/msm/ipa/ipa.c
drivers/platform/msm/qpnp-power-on.c
drivers/platform/x86/acer-wmi.c
drivers/platform/x86/dell-laptop.c
drivers/platform/x86/msi-laptop.c
drivers/platform/x86/thinkpad_acpi.c
drivers/power/ab8500_btemp.c
drivers/power/ab8500_charger.c
drivers/power/ab8500_fg.c
drivers/power/abx500_chargalg.c
drivers/power/battery_current_limit.c
drivers/power/battery_temp_ctrl.c
drivers/power/bq27520_fuelgauger.c
drivers/power/bq27541_fuelgauger.c
drivers/power/bq27x00_battery.c
drivers/power/charger-manager.c
drivers/power/da9030_battery.c
drivers/power/ds2760_battery.c
drivers/power/generic-adc-battery.c
drivers/power/intel_mid_battery.c
drivers/power/isl9519q.c
drivers/power/jz4740-battery.c
drivers/power/lp8727_charger.c
drivers/power/max17040_battery.c
drivers/power/msm_charger.c
drivers/power/pm8921-bms.c
drivers/power/pm8921-charger.c
drivers/power/pm8921-sec-charger-8930.c
drivers/power/pm8921-sec-charger.c
drivers/power/pm8xxx-ccadc.c
drivers/power/pmic8058-charger.c
drivers/power/s3c_adc_battery.c
drivers/power/sbs-battery.c
drivers/power/sec_battery.c
drivers/power/smb137b.c
drivers/regulator/core.c
drivers/rtc/rtc-88pm860x.c
drivers/s390/block/dasd_alias.c
drivers/s390/char/tape_core.c
drivers/s390/net/qeth_core_main.c
drivers/s390/scsi/zfcp_fc.c
drivers/scsi/bnx2fc/bnx2fc_io.c
drivers/scsi/fcoe/fcoe_sysfs.c
drivers/scsi/imm.c
drivers/scsi/libfc/fc_disc.c
drivers/scsi/libfc/fc_exch.c
drivers/scsi/libfc/fc_lport.c
drivers/scsi/libfc/fc_rport.c
drivers/scsi/megaraid/megaraid_sas_base.c
drivers/scsi/mpt2sas/mpt2sas_base.c
drivers/scsi/mpt2sas/mpt2sas_scsih.c
drivers/scsi/mvsas/mv_sas.c
drivers/scsi/NCR5380.c
drivers/scsi/ppa.c
drivers/scsi/scsi_transport_fc.c
drivers/scsi/scsi_transport_iscsi.c
drivers/sensorhub/ssp_dev.c
drivers/sensors/asp01.c
drivers/sensors/geomagnetic/yas_mag_kernel_driver.c
drivers/sensors/k2dh.c
drivers/sensors/optical/gp2ap020.c
drivers/sensors/yas_acc_kernel_driver.c
drivers/soc/qcom/bricked_hotplug.c
drivers/staging/csr/oska/kernel-compat.h
drivers/staging/iio/impedance-analyzer/ad5933.c
drivers/staging/iio/light/tsl2563.c
drivers/staging/mei/interrupt.c
drivers/staging/mei/main.c
drivers/staging/nvec/nvec_power.c
drivers/staging/octeon/ethernet.c
drivers/staging/rtl8187se/ieee80211/ieee80211_softmac.c
drivers/staging/rtl8187se/r8180_core.c
drivers/staging/rtl8192e/rtllib.h
drivers/staging/rtl8192u/ieee80211/ieee80211_softmac.c
drivers/staging/rtl8192u/r8192U_core.c
drivers/staging/rtl8192u/r8192U_dm.c
drivers/staging/rtl8192u/r819xU_phy.c
drivers/staging/zcache/ramster/ramster.c
drivers/staging/zcache/ramster/tcp.c
drivers/switch/hds_fsa8008.c
drivers/thermal/franco_thermal.c
drivers/thermal/machinex_thermal.c
drivers/thermal/msm_thermal_backup.c
drivers/thermal/msm_thermal.c
drivers/thermal/msm_thermal-last-working.c
drivers/thermal/msm_thermal_wip.c
drivers/thermal/pm8xxx-tm.c
drivers/thermal/thermal_core.c
drivers/tty/hvc/hvc_iucv.c
drivers/tty/hvc/hvsi.c
drivers/tty/n_smux.c
drivers/tty/serial/msm_serial_hs.c
drivers/usb/atm/cxacru.c
drivers/usb/core/driver.c
drivers/usb/core/hub.c
drivers/usb/dwc3/dwc3-msm.c
drivers/usb/gadget/ci13xxx_udc.c
drivers/usb/gadget/f_accessory.c
drivers/usb/gadget/f_rmnet_sdio.c
drivers/usb/gadget/f_rmnet_smd_sdio.c
drivers/usb/gadget/msm72k_udc.c
drivers/usb/gadget/u_rmnet_ctrl_smd.c
drivers/usb/gadget/u_sdio.c
drivers/usb/gadget/u_smd.c
drivers/usb/host/u132-hcd.c
drivers/usb/misc/appledisplay.c
drivers/usb/misc/ftdi-elan.c
drivers/usb/otg/ab8500-usb.c
drivers/usb/otg/fsl_otg.c
drivers/usb/otg/gpio_vbus.c
drivers/usb/otg/msm_otg_8930.c
drivers/usb/otg/msm_otg.c
drivers/usb/otg/mv_otg.c
drivers/usb/renesas_usbhs/common.c
drivers/usb/serial/oti6858.c
drivers/usb/storage/usb.c
drivers/usb/wusbcore/devconnect.c
drivers/usb/wusbcore/wusbhc.c
drivers/uwb/drp.c
drivers/uwb/rsv.c
drivers/video/fb_defio.c
drivers/video/hyperv_fb.c
drivers/video/msm/mdp.c
drivers/video/msm/mdss/mdss_mdp.c
drivers/video/msm/mipi_ql_dsi2lvds.c
drivers/video/msm/mipi_samsung_esd_refresh-8960.c
drivers/video/msm/mipi_samsung_esd_refresh.c
drivers/video/msm/mipi_samsung_oled-8960.c
drivers/video/omap2/displays/panel-taal.c
drivers/video/omap2/dss/dsi.c
drivers/video/omap2/omapfb/omapfb-main.c
drivers/video/omap/lcd_mipid.c
drivers/video/sh_mobile_hdmi.c
drivers/video/sh_mobile_lcdcfb.c
drivers/video/smscufx.c
drivers/video/udlfb.c
drivers/xen/balloon.c
drivers/xen/xen-selfballoon.c
fs/affs/super.c
fs/afs/callback.c
fs/afs/flock.c
fs/afs/mntpt.c
fs/afs/server.c
fs/afs/vlocation.c
fs/btrfs/transaction.c
fs/ceph/mds_client.c
fs/cifs/cifs_dfs_ref.c
fs/cifs/connect.c
fs/fs-writeback.c
fs/gfs2/glock.c
fs/gfs2/lock_dlm.c
fs/jffs2/wbuf.c
fs/lockd/svc.c
fs/namespace.c
fs/nfsd/nfs4state.c
fs/nfs/namespace.c
fs/nfs/nfs4renewd.c
fs/ocfs2/alloc.c
fs/ocfs2/cluster/heartbeat.c
fs/ocfs2/cluster/tcp.c
fs/ocfs2/journal.c
fs/ocfs2/localalloc.c
fs/ocfs2/quota_global.c
fs/reiserfs/journal.c
fs/ufs/super.c
fs/xfs/xfs_mru_cache.c
fs/xfs/xfs_sync.c
include/linux/blkdev.h
include/linux/kthread.h
include/linux/libata.h
include/linux/workqueue.h
include/net/mac80211.h
kernel/cgroup.c
kernel/jump_label.c
kernel/kprobes.c
kernel/kthread.c
kernel/power/qos.c
kernel/power/state_notifier.c
kernel/rcu/srcutree.c
kernel/time/ntp.c
kernel/workqueue.c
MachinexChangeLog
mm/backing-dev.c
mm/slab.c
mm/vmstat.c
net/atm/lec.c
net/batman-adv/bat_iv_ogm.c
net/batman-adv/originator.c
net/batman-adv/send.c
net/batman-adv/translation-table.c
net/batman-adv/vis.c
net/bluetooth/hci_conn.c
net/bluetooth/l2cap_core.c
net/ceph/messenger.c
net/ceph/mon_client.c
net/ceph/osd_client.c
net/core/dst.c
net/core/link_watch.c
net/core/neighbour.c
net/core/netpoll.c
net/ipv4/inetpeer.c
net/ipv4/route.c
net/mac80211/scan.c
net/mac80211/util.c
net/mac80211/work.c
net/netfilter/ipvs/ip_vs_ctl.c
net/netfilter/ipvs/ip_vs_sync.c
net/openvswitch/datapath.c
net/rds/connection.c
net/rds/ib_rdma.c
net/rds/ib_send.c
net/rds/iw_recv.c
net/rds/iw_send.c
net/rds/send.c
net/rds/tcp_recv.c
net/rds/tcp_send.c
net/rds/threads.c
net/rfkill/core.c
net/rfkill/input.c
net/rxrpc/ar-connection.c
net/rxrpc/ar-internal.h
net/rxrpc/ar-transport.c
net/sunrpc/cache.c
net/sunrpc/rpc_pipe.c
net/sunrpc/xprtrdma/transport.c
net/sunrpc/xprtsock.c
net/wireless/reg.c
patches-all/allpatches.txt
sound/aoa/core/gpio-feature.c
sound/aoa/core/gpio-pmf.c
sound/i2c/other/ak4113.c
sound/i2c/other/ak4114.c
sound/pci/ac97/ac97_codec.c
sound/pci/hda/hda_beep.c
sound/pci/hda/hda_codec.c
sound/pci/hda/patch_hdmi.c
sound/pci/hda/patch_via.c
sound/soc/codecs/audience/es325.c
sound/soc/codecs/audience/es705.c
sound/soc/codecs/es325.c
sound/soc/codecs/sta32x.c
sound/soc/codecs/twl6040.c
sound/soc/codecs/wcd9304.c
sound/soc/codecs/wcd9306.c
sound/soc/codecs/wcd9310.c
sound/soc/codecs/wcd9320.c
sound/soc/codecs/wcd9335.c
sound/soc/codecs/wcd9xxx-mbhc.c
sound/soc/codecs/wm8350.c
sound/soc/codecs/wm8753.c
sound/soc/codecs/wm8962.c
sound/soc/codecs/wm8971.c
sound/soc/msm/msm8230.c
sound/soc/msm/msm8930.c
sound/soc/msm/msm8960-d2.c
sound/soc/msm/msm8960-jaguar.c
sound/soc/soc-jack.c
sound/soc/soc-pcm.c--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
arch/arm/kernel/auto_hotplug.c-
arch/arm/kernel/auto_hotplug.c-
arch/arm/kernel/auto_hotplug.c-
arch/arm/kernel/auto_hotplug.c-
arch/arm/kernel/auto_hotplug.c-
arch/arm/kernel/auto_hotplug.c-
arch/arm/kernel/auto_hotplug.c-
arch/arm/kernel/auto_hotplug.c-
arch/arm/kernel/auto_hotplug.c-
arch/arm/kernel/auto_hotplug.c-}
arch/arm/kernel/auto_hotplug.c-}
arch/arm/kernel/auto_hotplug.c-}
arch/arm/kernel/auto_hotplug.c-}
arch/arm/kernel/auto_hotplug.c-}
arch/arm/kernel/auto_hotplug.c-}
arch/arm/kernel/auto_hotplug.c-	}
arch/arm/kernel/auto_hotplug.c-	}
arch/arm/kernel/auto_hotplug.c-	}
arch/arm/kernel/auto_hotplug.c-	}
arch/arm/kernel/auto_hotplug.c-	 */
arch/arm/kernel/auto_hotplug.c-	 */
arch/arm/kernel/auto_hotplug.c-		}
arch/arm/kernel/auto_hotplug.c-		}
arch/arm/kernel/auto_hotplug.c-		}
arch/arm/kernel/auto_hotplug.c-		 */
arch/arm/kernel/auto_hotplug.c-			}
arch/arm/kernel/auto_hotplug.c-			}
arch/arm/kernel/auto_hotplug.c-			 */
arch/arm/kernel/auto_hotplug.c-	/* Cancel all scheduled delayed work to avoid races */
arch/arm/kernel/auto_hotplug.c:				cancel_delayed_work(&aphotplug_offline_work);
arch/arm/kernel/auto_hotplug.c:				cancel_delayed_work(&aphotplug_offline_work);
arch/arm/kernel/auto_hotplug.c:				cancel_delayed_work(&aphotplug_offline_work);
arch/arm/kernel/auto_hotplug.c:	cancel_delayed_work_sync(&aphotplug_offline_work);
arch/arm/kernel/auto_hotplug.c:		cancel_delayed_work_sync(&aphotplug_offline_work);
arch/arm/kernel/auto_hotplug.c:			cancel_delayed_work_sync(&aphotplug_offline_work);
arch/arm/kernel/auto_hotplug.c:	cancel_delayed_work_sync(&hotplug_decision_work);
arch/arm/kernel/auto_hotplug.c:		cancel_delayed_work_sync(&hotplug_decision_work);
arch/arm/kernel/auto_hotplug.c:		cancel_delayed_work_sync(&hotplug_unpause_work);
arch/arm/kernel/auto_hotplug.c-#define POWERSUSPEND_ACTIVE	(1 << 3)
arch/arm/kernel/auto_hotplug.c-	else
arch/arm/kernel/auto_hotplug.c-		} else {
arch/arm/kernel/auto_hotplug.c-	} else if (flag && (!(flags & HOTPLUG_DISABLED))) {
arch/arm/kernel/auto_hotplug.c-		} else if (flags & HOTPLUG_PAUSED) {
arch/arm/kernel/auto_hotplug.c-		} else if (hotplug_flag_off) {
arch/arm/kernel/auto_hotplug.c-		} else if (hotplug_flag_on) {
arch/arm/kernel/auto_hotplug.c-		EnableOverride = true;
arch/arm/kernel/auto_hotplug.c-#endif
arch/arm/kernel/auto_hotplug.c-#endif
arch/arm/kernel/auto_hotplug.c-#endif
arch/arm/kernel/auto_hotplug.c-#endif
arch/arm/kernel/auto_hotplug.c-#endif
arch/arm/kernel/auto_hotplug.c-#endif
arch/arm/kernel/auto_hotplug.c-#endif
arch/arm/kernel/auto_hotplug.c-#endif
arch/arm/kernel/auto_hotplug.c-#endif
arch/arm/kernel/auto_hotplug.c-		flags |= HOTPLUG_DISABLED;
arch/arm/kernel/auto_hotplug.c-				flags |= HOTPLUG_PAUSED;
arch/arm/kernel/auto_hotplug.c-			flags |= HOTPLUG_PAUSED;
arch/arm/kernel/auto_hotplug.c-			flags |= HOTPLUG_PAUSED;
arch/arm/kernel/auto_hotplug.c-	flags |= HOTPLUG_PAUSED;
arch/arm/kernel/auto_hotplug.c-	flags &= ~POWERSUSPEND_ACTIVE;
arch/arm/kernel/auto_hotplug.c-				hotplug_flag_off = false;
arch/arm/kernel/auto_hotplug.c-			hotplug_flag_on = false;
arch/arm/kernel/auto_hotplug.c-			/* If boostpulse is active, clear the flags */
arch/arm/kernel/auto_hotplug.c-#if DEBUG
arch/arm/kernel/auto_hotplug.c-#if DEBUG
arch/arm/kernel/auto_hotplug.c-#if DEBUG
arch/arm/kernel/auto_hotplug.c-#ifdef CONFIG_POWERSUSPEND
arch/arm/kernel/auto_hotplug.c:			if (delayed_work_pending(&aphotplug_offline_work))
arch/arm/kernel/auto_hotplug.c:			if (delayed_work_pending(&aphotplug_offline_work))
arch/arm/kernel/auto_hotplug.c:			if (!(delayed_work_pending(&aphotplug_offline_work))) {
arch/arm/kernel/auto_hotplug.c:			if (delayed_work_pending(&aphotplug_offline_work)) {
arch/arm/kernel/auto_hotplug.c-		if (likely(num_online_cpus() < 2)) {
arch/arm/kernel/auto_hotplug.c-	if (num_online_cpus() > 1) {
arch/arm/kernel/auto_hotplug.c-			/* Only queue a cpu_down() if there isn't one already pending */
arch/arm/kernel/auto_hotplug.c-	 * Pause for 2 seconds before even considering offlining a CPU
arch/arm/kernel/auto_hotplug.c-		pr_info("auto_hotplug: Clearing disable flag\n");
arch/arm/kernel/auto_hotplug.c-				pr_info("auto_hotplug: Offlining CPU, avg running: %d\n", avg_running);
arch/arm/kernel/auto_hotplug.c-		pr_info("auto_hotplug: Offlining CPUs for power suspend\n");
arch/arm/kernel/auto_hotplug.c-			pr_info("auto_hotplug: Onlining single CPU, avg running: %d\n", avg_running);
arch/arm/kernel/auto_hotplug.c-				pr_info("auto_hotplug: %s: Cancelling aphotplug_offline_work\n", __func__);
arch/arm/kernel/auto_hotplug.c-			pr_info("auto_hotplug: %s: %d CPUs online\n", __func__, num_online_cpus());
arch/arm/kernel/auto_hotplug.c-		pr_info("auto_hotplug: Setting disable flag\n");
arch/arm/kernel/auto_hotplug.c-		pr_info("sampling_rate is: %d\n", jiffies_to_msecs(sampling_rate));
arch/arm/kernel/auto_hotplug.c-		pr_info("sampling_rate is: %d\n", jiffies_to_msecs(sampling_rate));
arch/arm/kernel/auto_hotplug.c-	pr_info("sampling_rate is: %d\n", jiffies_to_msecs(sampling_rate));
arch/arm/kernel/auto_hotplug.c-			return;
arch/arm/kernel/auto_hotplug.c-			return;
arch/arm/kernel/auto_hotplug.c:				schedule_delayed_work(&hotplug_unpause_work, HZ );
arch/arm/kernel/auto_hotplug.c:			schedule_delayed_work(&hotplug_unpause_work, HZ );
arch/arm/kernel/auto_hotplug.c:	schedule_delayed_work(&hotplug_unpause_work, HZ * 10);
arch/arm/kernel/auto_hotplug.c:	schedule_delayed_work(&hotplug_unpause_work, HZ * 2);
arch/arm/kernel/auto_hotplug.c:				schedule_delayed_work_on(0, &aphotplug_offline_work, HZ);
arch/arm/kernel/auto_hotplug.c:		schedule_delayed_work_on(0, &hotplug_decision_work, 0);
arch/arm/kernel/auto_hotplug.c:	schedule_delayed_work_on(0, &hotplug_decision_work, HZ);
arch/arm/kernel/auto_hotplug.c:	schedule_delayed_work_on(0, &hotplug_decision_work, HZ * 5);
arch/arm/kernel/auto_hotplug.c:				schedule_delayed_work_on(0, &hotplug_decision_work, MIN_SAMPLING_RATE);
arch/arm/kernel/auto_hotplug.c:			schedule_delayed_work_on(0, &hotplug_decision_work, MIN_SAMPLING_RATE);
arch/arm/kernel/auto_hotplug.c:	schedule_delayed_work_on(0, &hotplug_decision_work, MIN_SAMPLING_RATE);
arch/arm/kernel/auto_hotplug.c:	schedule_delayed_work_on(0, &hotplug_decision_work, MIN_SAMPLING_RATE);
arch/arm/kernel/auto_hotplug.c:	schedule_delayed_work_on(0, &hotplug_decision_work, MIN_SAMPLING_RATE);
arch/arm/kernel/auto_hotplug.c:		schedule_delayed_work_on(0, &hotplug_decision_work, sampling_rate);
arch/arm/kernel/auto_hotplug.c:		schedule_delayed_work_on(0, &hotplug_decision_work, sampling_rate);
arch/arm/kernel/auto_hotplug.c:	schedule_delayed_work_on(0, &hotplug_decision_work, sampling_rate);
arch/arm/kernel/auto_hotplug.c-			schedule_work_on(0, &hotplug_online_all_work);
arch/arm/kernel/auto_hotplug.c-		schedule_work_on(0, &hotplug_online_all_work);
arch/arm/kernel/auto_hotplug.c-			schedule_work_on(0, &hotplug_online_single_work);
arch/arm/kernel/auto_hotplug.c-			schedule_work_on(0, &hotplug_online_single_work);
arch/arm/kernel/auto_hotplug.c:struct delayed_work aphotplug_offline_work;
arch/arm/kernel/auto_hotplug.c:struct delayed_work hotplug_decision_work;
arch/arm/kernel/auto_hotplug.c:struct delayed_work hotplug_unpause_work;
arch/arm/kernel/auto_hotplug.c-struct work_struct hotplug_boost_online_work;
arch/arm/kernel/auto_hotplug.c-struct work_struct hotplug_offline_all_work;
arch/arm/kernel/auto_hotplug.c-struct work_struct hotplug_online_all_work;
arch/arm/kernel/auto_hotplug.c-struct work_struct hotplug_online_single_work;
arch/arm/kernel/autosmp.c-
arch/arm/kernel/autosmp.c-
arch/arm/kernel/autosmp.c-
arch/arm/kernel/autosmp.c-
arch/arm/kernel/autosmp.c-
arch/arm/kernel/autosmp.c-
arch/arm/kernel/autosmp.c-}
arch/arm/kernel/autosmp.c-};
arch/arm/kernel/autosmp.c:		cancel_delayed_work_sync(&asmp_work);
arch/arm/kernel/autosmp.c:		cancel_delayed_work_sync(&asmp_work);
arch/arm/kernel/autosmp.c-	} else {
arch/arm/kernel/autosmp.c-	} /* else do nothing */
arch/arm/kernel/autosmp.c-		for_each_present_cpu(cpu) {
arch/arm/kernel/autosmp.c-	if (enabled)
arch/arm/kernel/autosmp.c-	if (enabled)
arch/arm/kernel/autosmp.c-	if (enabled)
arch/arm/kernel/autosmp.c-	if (enabled) {
arch/arm/kernel/autosmp.c-			if (num_online_cpus() >= nr_cpu_ids)
arch/arm/kernel/autosmp.c-	INIT_DELAYED_WORK(&asmp_work, asmp_work_fn);
arch/arm/kernel/autosmp.c-				msecs_to_jiffies(asmp_param.delay));
arch/arm/kernel/autosmp.c-				msecs_to_jiffies(asmp_param.delay));
arch/arm/kernel/autosmp.c-				   msecs_to_jiffies(ASMP_STARTDELAY));
arch/arm/kernel/autosmp.c-		pr_info(ASMP_TAG"enabled\n");
arch/arm/kernel/autosmp.c-	pr_info(ASMP_TAG"suspended\n");
arch/arm/kernel/autosmp.c:		queue_delayed_work(asmp_workq, &asmp_work,
arch/arm/kernel/autosmp.c:		queue_delayed_work(asmp_workq, &asmp_work,
arch/arm/kernel/autosmp.c:		queue_delayed_work(asmp_workq, &asmp_work,
arch/arm/kernel/autosmp.c:	queue_delayed_work(asmp_workq, &asmp_work, delay_jif);
arch/arm/kernel/autosmp.c-	/* resume main work thread */
arch/arm/kernel/autosmp.c-	ret = param_set_bool(val, kp);
arch/arm/kernel/autosmp.c-static DEFINE_PER_CPU(struct asmp_cpudata_t, asmp_cpudata);
arch/arm/kernel/autosmp.c:static struct delayed_work asmp_work;
arch/arm/kernel/autosmp.c-static struct workqueue_struct *asmp_workq;
arch/arm/kernel/autosmp.c-	/* suspend main work thread */
arch/arm/mach-msm/bam_dmux.c-	BAM_DMUX_LOG("%s complete\n", __func__);
arch/arm/mach-msm/bam_dmux.c-		bam_is_connected = 1;
arch/arm/mach-msm/bam_dmux.c-	bam_is_connected = 1;
arch/arm/mach-msm/bam_dmux.c-		} else {
arch/arm/mach-msm/bam_dmux.c-				__func__, ul_packet_written);
arch/arm/mach-msm/bam_dmux.c-		if (likely(do_vote_dfab))
arch/arm/mach-msm/bam_dmux.c-	if (!ret) { /* failed to grab lock, reschedule and bail */
arch/arm/mach-msm/bam_dmux.c-				msecs_to_jiffies(UL_TIMEOUT_DELAY));
arch/arm/mach-msm/bam_dmux.c-				msecs_to_jiffies(UL_TIMEOUT_DELAY));
arch/arm/mach-msm/bam_dmux.c-				msecs_to_jiffies(UL_TIMEOUT_DELAY));
arch/arm/mach-msm/bam_dmux.c-					msecs_to_jiffies(UL_TIMEOUT_DELAY));
arch/arm/mach-msm/bam_dmux.c-	mutex_unlock(&wakeup_lock);
arch/arm/mach-msm/bam_dmux.c-		return;
arch/arm/mach-msm/bam_dmux.c-	ret = write_trylock_irqsave(&ul_wakeup_lock, flags);
arch/arm/mach-msm/bam_dmux.c:	schedule_delayed_work(&ul_timeout_work,
arch/arm/mach-msm/bam_dmux.c:		schedule_delayed_work(&ul_timeout_work,
arch/arm/mach-msm/bam_dmux.c:		schedule_delayed_work(&ul_timeout_work,
arch/arm/mach-msm/bam_dmux.c:			schedule_delayed_work(&ul_timeout_work,
arch/arm/mach-msm/bam_dmux.c-static atomic_t ul_ondemand_vote = ATOMIC_INIT(0);
arch/arm/mach-msm/bam_dmux.c-static int ul_packet_written;
arch/arm/mach-msm/bam_dmux.c-static struct completion bam_connection_completion;
arch/arm/mach-msm/bam_dmux.c-static struct completion ul_wakeup_ack_completion;
arch/arm/mach-msm/bam_dmux.c:static struct delayed_work ul_timeout_work;
arch/arm/mach-msm/bam_dmux.c-			ul_packet_written = 0;
arch/arm/mach-msm/bam_dmux.c-			vote_dfab();
arch/arm/mach-msm/board-mahimahi-microp.c-
arch/arm/mach-msm/board-mahimahi-microp.c-
arch/arm/mach-msm/board-mahimahi-microp.c-
arch/arm/mach-msm/board-mahimahi-microp.c-	}
arch/arm/mach-msm/board-mahimahi-microp.c-	}
arch/arm/mach-msm/board-mahimahi-microp.c-	 */
arch/arm/mach-msm/board-mahimahi-microp.c:	cancel_delayed_work(&cdata->ls_read_work);
arch/arm/mach-msm/board-mahimahi-microp.c-		else
arch/arm/mach-msm/board-mahimahi-microp.c-		if (!cdata->headset_is_in)
arch/arm/mach-msm/board-mahimahi-microp.c-					msecs_to_jiffies(300));
arch/arm/mach-msm/board-mahimahi-microp.c-					msecs_to_jiffies(500));
arch/arm/mach-msm/board-mahimahi-microp.c-	ret = microp_i2c_auto_backlight_mode(client, 0);
arch/arm/mach-msm/board-mahimahi-microp.c:			schedule_delayed_work(&cdata->hpin_debounce_work,
arch/arm/mach-msm/board-mahimahi-microp.c:			schedule_delayed_work(&cdata->hpin_debounce_work,
arch/arm/mach-msm/board-mahimahi-microp.c:	schedule_delayed_work(&cdata->ls_read_work, LS_READ_DELAY);
arch/arm/mach-msm/board-mahimahi-microp.c-	schedule_work(&cdata->work.work);
arch/arm/mach-msm/board-mahimahi-microp.c:	struct delayed_work hpin_debounce_work;
arch/arm/mach-msm/board-mahimahi-microp.c:	struct delayed_work ls_read_work;
arch/arm/mach-msm/board-mahimahi-microp.c-	struct microp_i2c_work work;
arch/arm/mach-msm/board-mahimahi-microp.c-	struct power_suspend power_suspend;
arch/arm/mach-msm/board-mahimahi-microp.c-	 * to work around sensor manager race condition
arch/arm/mach-msm/board-mahimahi-microp.c-	uint16_t version;
arch/arm/mach-msm/board-mahimahi-microp.c-	uint8_t enable_power_suspend;
arch/arm/mach-msm/board-mahimahi-microp.c-		wake_lock_timeout(&microp_i2c_wakelock, 3*HZ);
arch/arm/mach-msm/board-msm8x60.c-
arch/arm/mach-msm/board-msm8x60.c-
arch/arm/mach-msm/board-msm8x60.c-	}
arch/arm/mach-msm/board-msm8x60.c-	 */
arch/arm/mach-msm/board-msm8x60.c-		}
arch/arm/mach-msm/board-msm8x60.c:		cancel_delayed_work_sync(&pmic_id_det);
arch/arm/mach-msm/board-msm8x60.c-#define USB_PMIC_ID_DET_DELAY	msecs_to_jiffies(100)
arch/arm/mach-msm/board-msm8x60.c-#ifdef CONFIG_USB_EHCI_MSM_72K
arch/arm/mach-msm/board-msm8x60.c-		msm_otg_pdata.pmic_id_irq = 0;
arch/arm/mach-msm/board-msm8x60.c-		notify_vbus_state_func_ptr = NULL;
arch/arm/mach-msm/board-msm8x60.c-	return IRQ_HANDLED;
arch/arm/mach-msm/board-msm8x60.c:	schedule_delayed_work(&pmic_id_det, USB_PMIC_ID_DET_DELAY);
arch/arm/mach-msm/board-msm8x60.c-static int __init usb_id_pin_rework_setup(char *support)
arch/arm/mach-msm/board-msm8x60.c:struct delayed_work pmic_id_det;
arch/arm/mach-msm/board-msm8x60.c-	 * work to to allow debounce on gpio
arch/arm/mach-msm/dma.c-
arch/arm/mach-msm/dma.c-{
arch/arm/mach-msm/dma.c-};
arch/arm/mach-msm/dma.c-	}
arch/arm/mach-msm/dma.c:		cancel_delayed_work(&dmov_conf[adm].work);
arch/arm/mach-msm/dma.c-	case CLK_TO_BE_DIS:
arch/arm/mach-msm/dma.c:		container_of(to_delayed_work(work), struct msm_dmov_conf, work);
arch/arm/mach-msm/dma.c-		disable_irq_nosync(dmov_conf[adm].irq);
arch/arm/mach-msm/dma.c-		dmov_conf[adm].clk_ctl = CLK_EN;
arch/arm/mach-msm/dma.c-		dmov_conf[adm].clk_ctl = CLK_TO_BE_DIS;
arch/arm/mach-msm/dma.c-	int adm = DMOV_IRQ_TO_ADM(conf->irq);
arch/arm/mach-msm/dma.c-						   msecs_to_jiffies(10));
arch/arm/mach-msm/dma.c-		msm_dmov_enqueue_cmd_ext_atomic(id, cmd);
arch/arm/mach-msm/dma.c:		queue_delayed_work(dmov_conf[adm].cmd_wq, &dmov_conf[adm].work,
arch/arm/mach-msm/dma.c-	struct clk *ebiclk;
arch/arm/mach-msm/dma.c:	struct delayed_work work;
arch/arm/mach-msm/dma.c-	struct msm_dmov_conf *conf =
arch/arm/mach-msm/dma.c-	struct workqueue_struct *cmd_wq;
arch/arm/mach-msm/dma.c-	unsigned int clk_ctl;
arch/arm/mach-msm/dma.c-	unsigned long irq_flags;
arch/arm/mach-msm/ipc_router_hsic_xprt.c-		container_of(rwork, struct msm_ipc_router_hsic_xprt, read_work);
arch/arm/mach-msm/ipc_router_hsic_xprt.c-	D("%s: Notified IPC Router of %s OPEN\n",
arch/arm/mach-msm/ipc_router_hsic_xprt.c-	  __func__, hsic_remote_xprt[id].xprt.name);
arch/arm/mach-msm/ipc_router_hsic_xprt.c-			   &hsic_remote_xprt[id].read_work, 0);
arch/arm/mach-msm/ipc_router_hsic_xprt.c:	queue_delayed_work(hsic_remote_xprt[id].hsic_xprt_wq,
arch/arm/mach-msm/ipc_router_hsic_xprt.c-	return 0;
arch/arm/mach-msm/ipc_router_hsic_xprt.c:	struct delayed_work read_work;
arch/arm/mach-msm/ipc_router_hsic_xprt.c:	struct delayed_work *rwork = to_delayed_work(work);
arch/arm/mach-msm/ipc_router_hsic_xprt.c-	struct ipc_bridge_platform_data *pdata;
arch/arm/mach-msm/ipc_router_hsic_xprt.c-	struct msm_ipc_router_hsic_xprt *hsic_xprtp =
arch/arm/mach-msm/ipc_router_hsic_xprt.c-	struct mutex ss_reset_lock;
arch/arm/mach-msm/ipc_router_hsic_xprt.c-	struct platform_device *pdev;
arch/arm/mach-msm/ipc_router_hsic_xprt.c-	struct rr_packet *in_pkt;
arch/arm/mach-msm/ipc_router_hsic_xprt.c-	struct workqueue_struct *hsic_xprt_wq;
arch/arm/mach-msm/ipc_router_hsic_xprt.c-	void *data;
arch/arm/mach-msm/ipc_router_smd_xprt.c-	case SMD_EVENT_DATA:
arch/arm/mach-msm/ipc_router_smd_xprt.c-		container_of(rwork, struct msm_ipc_router_smd_xprt, read_work);
arch/arm/mach-msm/ipc_router_smd_xprt.c-			if (!ipc_rtr_pkt) {
arch/arm/mach-msm/ipc_router_smd_xprt.c-		if (smd_read_avail(smd_xprtp->channel))
arch/arm/mach-msm/ipc_router_smd_xprt.c-		if (smd_write_avail(smd_xprtp->channel))
arch/arm/mach-msm/ipc_router_smd_xprt.c-				if (sz <= (PAGE_SIZE/2)) {
arch/arm/mach-msm/ipc_router_smd_xprt.c-	int is_partial_in_pkt;
arch/arm/mach-msm/ipc_router_smd_xprt.c-	int ss_reset;
arch/arm/mach-msm/ipc_router_smd_xprt.c:					queue_delayed_work(
arch/arm/mach-msm/ipc_router_smd_xprt.c:			queue_delayed_work(smd_xprtp->smd_xprt_wq,
arch/arm/mach-msm/ipc_router_smd_xprt.c-						&smd_xprtp->read_work,
arch/arm/mach-msm/ipc_router_smd_xprt.c-					   &smd_xprtp->read_work, 0);
arch/arm/mach-msm/ipc_router_smd_xprt.c-						smd_xprtp->smd_xprt_wq,
arch/arm/mach-msm/ipc_router_smd_xprt.c-	spinlock_t ss_reset_lock;	/*Subsystem reset lock*/
arch/arm/mach-msm/ipc_router_smd_xprt.c:	struct delayed_work read_work;
arch/arm/mach-msm/ipc_router_smd_xprt.c:	struct delayed_work *rwork = to_delayed_work(work);
arch/arm/mach-msm/ipc_router_smd_xprt.c-	struct msm_ipc_router_smd_xprt *smd_xprtp =
arch/arm/mach-msm/ipc_router_smd_xprt.c-	struct rr_packet *in_pkt;
arch/arm/mach-msm/ipc_router_smd_xprt.c-	unsigned long flags;
arch/arm/mach-msm/ipc_router_smd_xprt.c-	void *data;
arch/arm/mach-msm/lge/mako/board-mako-earjack-debugger.c-
arch/arm/mach-msm/lge/mako/board-mako-earjack-debugger.c-
arch/arm/mach-msm/lge/mako/board-mako-earjack-debugger.c-{
arch/arm/mach-msm/lge/mako/board-mako-earjack-debugger.c-};
arch/arm/mach-msm/lge/mako/board-mako-earjack-debugger.c-			dwork, struct earjack_debugger_device, work);
arch/arm/mach-msm/lge/mako/board-mako-earjack-debugger.c-	enable_irq(adev->irq);
arch/arm/mach-msm/lge/mako/board-mako-earjack-debugger.c-	int irq;
arch/arm/mach-msm/lge/mako/board-mako-earjack-debugger.c-	int saved_detect;
arch/arm/mach-msm/lge/mako/board-mako-earjack-debugger.c:	schedule_delayed_work(&adev->work, msecs_to_jiffies(10));
arch/arm/mach-msm/lge/mako/board-mako-earjack-debugger.c-static void set_console_work(struct work_struct *work)
arch/arm/mach-msm/lge/mako/board-mako-earjack-debugger.c:	struct delayed_work *dwork = to_delayed_work(work);
arch/arm/mach-msm/lge/mako/board-mako-earjack-debugger.c:	struct delayed_work work;
arch/arm/mach-msm/lge/mako/board-mako-earjack-debugger.c-	struct earjack_debugger_device *adev = container_of(
arch/arm/mach-msm/lge/mako/board-mako-earjack-debugger.c-	struct earjack_debugger_device *adev = platform_get_drvdata(pdev);
arch/arm/mach-msm/lge/mako/board-mako-earjack-debugger.c-	void (*set_uart_console)(int enable);
arch/arm/mach-msm/mdm_common.c-
arch/arm/mach-msm/mdm_common.c-
arch/arm/mach-msm/mdm_common.c-
arch/arm/mach-msm/mdm_common.c-
arch/arm/mach-msm/mdm_common.c-		 */
arch/arm/mach-msm/mdm_common.c-	atomic_set(&mdev->mdm_data.mdm_ready, 0);
arch/arm/mach-msm/mdm_common.c-		break;
arch/arm/mach-msm/mdm_common.c:	cancel_delayed_work(&mdev->mdm2ap_status_check_work);
arch/arm/mach-msm/mdm_common.c:	cancel_delayed_work(&mdev->mdm2ap_status_check_work);
arch/arm/mach-msm/mdm_common.c:		cancel_delayed_work(&mdev->mdm2ap_status_check_work);
arch/arm/mach-msm/mdm_common.c-	} else if (value == 1) {
arch/arm/mach-msm/mdm_common.c-				__func__, mdev->mdm_data.device_id);
arch/arm/mach-msm/mdm_common.c-		if (!status && gpio_get_value(mdm_drv->mdm2ap_status_gpio) == 0)
arch/arm/mach-msm/mdm_common.c-	if (want_dumps) {
arch/arm/mach-msm/mdm_common.c-	int mdm_pblrdy_irq;
arch/arm/mach-msm/mdm_common.c-		mdm_drv->boot_type = CHARM_RAM_DUMPS;
arch/arm/mach-msm/mdm_common.c-	mdm_drv->mdm_ram_dump_status = 0;
arch/arm/mach-msm/mdm_common.c-	mdm_ssr_started(mdev);
arch/arm/mach-msm/mdm_common.c-		mdm_start_ssr(mdev);
arch/arm/mach-msm/mdm_common.c-				msecs_to_jiffies(MDM2AP_STATUS_TIMEOUT_MS));
arch/arm/mach-msm/mdm_common.c-		pr_info("%s: status = 1: mdm id %d is now ready\n",
arch/arm/mach-msm/mdm_common.c:			schedule_delayed_work(&mdev->mdm2ap_status_check_work,
arch/arm/mach-msm/mdm_common.c:	struct delayed_work mdm2ap_status_check_work;
arch/arm/mach-msm/mdm_common.c-	struct work_struct mdm_status_work;
arch/arm/mach-msm/mdm_common.c-	struct work_struct sfr_reason_work;
arch/arm/mach-msm/modem-8660.c-
arch/arm/mach-msm/modem-8660.c-
arch/arm/mach-msm/modem-8660.c-
arch/arm/mach-msm/modem-8660.c-
arch/arm/mach-msm/modem-8660.c-}
arch/arm/mach-msm/modem-8660.c-		*/
arch/arm/mach-msm/modem-8660.c-#endif
arch/arm/mach-msm/modem-8660.c-#endif
arch/arm/mach-msm/modem-8660.c-#if defined(SUBSYS_FATAL_DEBUG)
arch/arm/mach-msm/modem-8660.c-		 * in that case.
arch/arm/mach-msm/modem-8660.c-					msecs_to_jiffies(6000));
arch/arm/mach-msm/modem-8660.c-	reset_modem = 0;
arch/arm/mach-msm/modem-8660.c:		ret = schedule_delayed_work(&modem_unlock_timeout_work,
arch/arm/mach-msm/modem-8660.c:	schedule_delayed_work(&debug_crash_modem_work, msecs_to_jiffies(1000));
arch/arm/mach-msm/modem-8660.c:	schedule_delayed_work(&debug_crash_modem_work, msecs_to_jiffies(5000));
arch/arm/mach-msm/msm_dcvs.c-
arch/arm/mach-msm/msm_dcvs.c-
arch/arm/mach-msm/msm_dcvs.c-
arch/arm/mach-msm/msm_dcvs.c-
arch/arm/mach-msm/msm_dcvs.c-
arch/arm/mach-msm/msm_dcvs.c-}
arch/arm/mach-msm/msm_dcvs.c-};
arch/arm/mach-msm/msm_dcvs.c:	cancel_delayed_work(&core->temperature_work);
arch/arm/mach-msm/msm_dcvs.c-	core->flags |= CORE_FLAG_TEMP_UPDATE;
arch/arm/mach-msm/msm_dcvs.c-	core->flags &= ~CORE_FLAG_TEMP_UPDATE;
arch/arm/mach-msm/msm_dcvs.c-	core->idle_enable(core->type_core_num, MSM_DCVS_DISABLE_IDLE_PULSE);
arch/arm/mach-msm/msm_dcvs.c-	INIT_DELAYED_WORK(&core->temperature_work, msm_dcvs_report_temp_work);
arch/arm/mach-msm/msm_dcvs.c-		interval_ms = info->thermal_poll_ms;
arch/arm/mach-msm/msm_dcvs.c-	int flags;
arch/arm/mach-msm/msm_dcvs.c-			      msecs_to_jiffies(core->info->thermal_poll_ms));
arch/arm/mach-msm/msm_dcvs.c-			msecs_to_jiffies(interval_ms));
arch/arm/mach-msm/msm_dcvs.c:	schedule_delayed_work(&core->temperature_work,
arch/arm/mach-msm/msm_dcvs.c:	schedule_delayed_work(&core->temperature_work,
arch/arm/mach-msm/msm_dcvs.c:	struct delayed_work	temperature_work;
arch/arm/mach-msm/msm_dcvs.c-	struct hrtimer	slack_timer;
arch/arm/mach-msm/msm_watchdog.c-
arch/arm/mach-msm/msm_watchdog.c-
arch/arm/mach-msm/msm_watchdog.c-
arch/arm/mach-msm/msm_watchdog.c-
arch/arm/mach-msm/msm_watchdog.c-}
arch/arm/mach-msm/msm_watchdog.c-	atomic_notifier_chain_register(&panic_notifier_list,
arch/arm/mach-msm/msm_watchdog.c-	atomic_notifier_chain_unregister(&panic_notifier_list, &panic_blk);
arch/arm/mach-msm/msm_watchdog.c:	cancel_delayed_work(&dogwork_struct);
arch/arm/mach-msm/msm_watchdog.c-	if (enable)
arch/arm/mach-msm/msm_watchdog.c-	/* may be suspended after the first write above */
arch/arm/mach-msm/msm_watchdog.c-	__raw_writel(0, msm_wdt_base + WDT_EN);
arch/arm/mach-msm/msm_watchdog.c-	__raw_writel(timeout + 3*WDT_HZ, msm_wdt_base + WDT_BITE_TIME);
arch/arm/mach-msm/msm_watchdog.c:		schedule_delayed_work_on(0, &dogwork_struct, delay_time);
arch/arm/mach-msm/msm_watchdog.c:	schedule_delayed_work_on(0, &dogwork_struct, delay_time);
arch/arm/mach-msm/msm_watchdog.c-	unregister_reboot_notifier(&msm_reboot_notifier);
arch/arm/mach-msm/msm_watchdog_v2.c-{
arch/arm/mach-msm/msm_watchdog_v2.c-}
arch/arm/mach-msm/msm_watchdog_v2.c-};
arch/arm/mach-msm/msm_watchdog_v2.c-	atomic_notifier_chain_unregister(&panic_notifier_list,
arch/arm/mach-msm/msm_watchdog_v2.c:	cancel_delayed_work_sync(&wdog_dd->dogwork_struct);
arch/arm/mach-msm/msm_watchdog_v2.c-	 * Could have been changed on other cpu */
arch/arm/mach-msm/msm_watchdog_v2.c-							delay_time);
arch/arm/mach-msm/msm_watchdog_v2.c-							dogwork_struct);
arch/arm/mach-msm/msm_watchdog_v2.c-	if (enable)
arch/arm/mach-msm/msm_watchdog_v2.c-	/* may be suspended after the first write above */
arch/arm/mach-msm/msm_watchdog_v2.c-	mutex_init(&wdog_dd->disable_lock);
arch/arm/mach-msm/msm_watchdog_v2.c-	__raw_writel(0, wdog_dd->base + WDT0_EN);
arch/arm/mach-msm/msm_watchdog_v2.c-	__raw_writel(1, wdog_dd->base + WDT0_EN);
arch/arm/mach-msm/msm_watchdog_v2.c-	__raw_writel(1, wdog_dd->base + WDT0_RST);
arch/arm/mach-msm/msm_watchdog_v2.c:	schedule_delayed_work_on(0, &wdog_dd->dogwork_struct, delay_time);
arch/arm/mach-msm/msm_watchdog_v2.c:		schedule_delayed_work(&wdog_dd->dogwork_struct,
arch/arm/mach-msm/msm_watchdog_v2.c:	struct delayed_work *delayed_work = to_delayed_work(work);
arch/arm/mach-msm/msm_watchdog_v2.c:	struct delayed_work dogwork_struct;
arch/arm/mach-msm/msm_watchdog_v2.c-						struct msm_watchdog_data,
arch/arm/mach-msm/msm_watchdog_v2.c:	struct msm_watchdog_data *wdog_dd = container_of(delayed_work,
arch/arm/mach-msm/msm_watchdog_v2.c-	struct mutex disable_lock;
arch/arm/mach-msm/msm_watchdog_v2.c-	struct notifier_block panic_blk;
arch/arm/mach-msm/msm_watchdog_v2.c-	struct work_struct init_dogwork_struct;
arch/arm/mach-msm/msm_watchdog_v2.c-	unsigned long delay_time;
arch/arm/mach-msm/msm_watchdog_v2.c-				       &wdog_dd->panic_blk);
arch/arm/mach-msm/msm_watchdog_v2.c-						&wdog_dd->panic_blk);
arch/arm/mach-msm/msm_zen_decision.c-
arch/arm/mach-msm/msm_zen_decision.c-
arch/arm/mach-msm/msm_zen_decision.c-{
arch/arm/mach-msm/msm_zen_decision.c-}
arch/arm/mach-msm/msm_zen_decision.c-			break;
arch/arm/mach-msm/msm_zen_decision.c:	cancel_delayed_work_sync(&wake_work);
arch/arm/mach-msm/msm_zen_decision.c:			cancel_delayed_work_sync(&wake_work);
arch/arm/mach-msm/msm_zen_decision.c-		case STATE_NOTIFIER_SUSPEND:
arch/arm/mach-msm/msm_zen_decision.c-			/* Clear wake workqueue of any pending threads */
arch/arm/mach-msm/msm_zen_decision.c-	destroy_workqueue(zen_wake_wq);
arch/arm/mach-msm/msm_zen_decision.c-	flush_workqueue(zen_wake_wq);
arch/arm/mach-msm/msm_zen_decision.c-			flush_workqueue(zen_wake_wq);
arch/arm/mach-msm/msm_zen_decision.c-			msecs_to_jiffies(wake_wait_time));
arch/arm/mach-msm/msm_zen_decision.c:	queue_delayed_work(zen_wake_wq, &wake_work,
arch/arm/mach-msm/msm_zen_decision.c-	state_unregister_client(&notif);
arch/arm/mach-msm/msm_zen_decision.c:static struct delayed_work wake_work;
arch/arm/mach-msm/msm_zen_decision.c-static struct workqueue_struct *zen_wake_wq;
arch/arm/mach-msm/msm_zen_decision.c-static void msm_zd_queue_online_work(void)
arch/arm/mach-msm/msm_zen_decision.c-/* Sysfs stuff */
arch/arm/mach-msm/msm_zen_decision.c-/* Worker Stuff */
arch/arm/mach-msm/ocmem_sched.c-{
arch/arm/mach-msm/ocmem_sched.c-				msecs_to_jiffies(SCHED_DELAY));
arch/arm/mach-msm/ocmem_sched.c-	return 0;
arch/arm/mach-msm/ocmem_sched.c:	schedule_delayed_work(&ocmem_sched_thread,
arch/arm/mach-msm/ocmem_sched.c-static int ocmem_schedule_pending(void)
arch/arm/mach-msm/peripheral-loader.c-
arch/arm/mach-msm/peripheral-loader.c-
arch/arm/mach-msm/peripheral-loader.c-
arch/arm/mach-msm/peripheral-loader.c-}
arch/arm/mach-msm/peripheral-loader.c-	char wake_name[32];
arch/arm/mach-msm/peripheral-loader.c-		device_unregister(&pil->dev);
arch/arm/mach-msm/peripheral-loader.c-	else
arch/arm/mach-msm/peripheral-loader.c-#endif
arch/arm/mach-msm/peripheral-loader.c:		flush_delayed_work(&pil->proxy);
arch/arm/mach-msm/peripheral-loader.c:		flush_delayed_work(&pil->proxy);
arch/arm/mach-msm/peripheral-loader.c-	if (timeout && pil->desc->ops->proxy_unvote)
arch/arm/mach-msm/peripheral-loader.c-		msm_pil_debugfs_remove(pil);
arch/arm/mach-msm/peripheral-loader.c-		mutex_lock(&pil->lock);
arch/arm/mach-msm/peripheral-loader.c-		pil->desc->ops->proxy_unvote(pil->desc);
arch/arm/mach-msm/peripheral-loader.c-	pil_set_state(pil, PIL_OFFLINE);
arch/arm/mach-msm/peripheral-loader.c:		schedule_delayed_work(&pil->proxy, msecs_to_jiffies(timeout));
arch/arm/mach-msm/peripheral-loader.c:	struct delayed_work proxy;
arch/arm/mach-msm/peripheral-loader.c-	struct dentry *dentry;
arch/arm/mach-msm/peripheral-loader.c-	struct wake_lock wlock;
arch/arm/mach-msm/peripheral-loader.c-		WARN_ON(pil->count);
arch/arm/mach-msm/rmt_storage_client.c-
arch/arm/mach-msm/rmt_storage_client.c-
arch/arm/mach-msm/rmt_storage_client.c-
arch/arm/mach-msm/rmt_storage_client.c-
arch/arm/mach-msm/rmt_storage_client.c-{
arch/arm/mach-msm/rmt_storage_client.c-}
arch/arm/mach-msm/rmt_storage_client.c-}
arch/arm/mach-msm/rmt_storage_client.c-}
arch/arm/mach-msm/rmt_storage_client.c-}
arch/arm/mach-msm/rmt_storage_client.c-};
arch/arm/mach-msm/rmt_storage_client.c:	cancel_delayed_work_sync(&srv->restart_work);
arch/arm/mach-msm/rmt_storage_client.c-	if (!msm_rpc_client_in_reset(srv->rpc_client))
arch/arm/mach-msm/rmt_storage_client.c-	if (!rmt_storage_get_srv(srv->prog)) {
arch/arm/mach-msm/rmt_storage_client.c-	int ret;
arch/arm/mach-msm/rmt_storage_client.c-			msecs_to_jiffies(RESTART_WORK_DELAY_MS));
arch/arm/mach-msm/rmt_storage_client.c-				msecs_to_jiffies(RESTART_WORK_DELAY_MS));
arch/arm/mach-msm/rmt_storage_client.c-	pr_debug("%s: Modem restart for 0x%08x\n", __func__, srv->prog);
arch/arm/mach-msm/rmt_storage_client.c-	pr_debug("%s: Scheduling restart for 0x%08x\n", __func__, srv->prog);
arch/arm/mach-msm/rmt_storage_client.c:	queue_delayed_work(rmc->workq, &sdio_smem_work, 0);
arch/arm/mach-msm/rmt_storage_client.c:		queue_delayed_work(rmc->workq, &srv->restart_work,
arch/arm/mach-msm/rmt_storage_client.c:	queue_delayed_work(rmc->workq, &srv->restart_work,
arch/arm/mach-msm/rmt_storage_client.c-		return;
arch/arm/mach-msm/rmt_storage_client.c-		return;
arch/arm/mach-msm/rmt_storage_client.c-	return 0;
arch/arm/mach-msm/rmt_storage_client.c-	sdio_smem_unregister_client();
arch/arm/mach-msm/rmt_storage_client.c:	srv = container_of((struct delayed_work *)work,
arch/arm/mach-msm/rmt_storage_client.c:	struct delayed_work restart_work;
arch/arm/mach-msm/rmt_storage_client.c-	struct msm_rpc_client *rpc_client;
arch/arm/mach-msm/rmt_storage_client.c-	struct platform_driver plat_drv;
arch/arm/mach-msm/rmt_storage_client.c-			   struct rmt_storage_srv, restart_work);
arch/arm/mach-msm/rpcrouter_sdio_xprt.c-	}
arch/arm/mach-msm/rpcrouter_sdio_xprt.c-				flags);
arch/arm/mach-msm/rpcrouter_sdio_xprt.c-					   msecs_to_jiffies(100));
arch/arm/mach-msm/rpcrouter_sdio_xprt.c-					   msecs_to_jiffies(100));
arch/arm/mach-msm/rpcrouter_sdio_xprt.c-					   msecs_to_jiffies(100));
arch/arm/mach-msm/rpcrouter_sdio_xprt.c:		queue_delayed_work(sdio_xprt_read_workqueue,
arch/arm/mach-msm/rpcrouter_sdio_xprt.c:			queue_delayed_work(sdio_xprt_read_workqueue,
arch/arm/mach-msm/rpcrouter_sdio_xprt.c:			queue_delayed_work(sdio_xprt_read_workqueue,
arch/arm/mach-msm/rpcrouter_sdio_xprt.c:			queue_delayed_work(sdio_xprt_read_workqueue,
arch/arm/mach-msm/rpcrouter_sdio_xprt.c-			return_to_free_list(sdio_remote_xprt.channel, buf);
arch/arm/mach-msm/rpcrouter_sdio_xprt.c-			      "SDIO_EVENT_DATA_READ_AVAIL\n", __func__);
arch/arm/mach-msm/rpcrouter_sdio_xprt.c-				&sdio_remote_xprt.channel->read_list_lock,
arch/arm/mach-msm/rpcrouter_sdio_xprt.c-			SDIO_XPRT_DBG("%s: Failed to alloc_from_free_list"
arch/arm/mach-msm/rpcrouter_sdio_xprt.c-		SDIO_XPRT_DBG("%s Received Notify"
arch/arm/mach-msm/rpcrouter_sdio_xprt.c-					size, read_avail);
arch/arm/mach-msm/rpcrouter_sdio_xprt.c-				      " Try again later\n", __func__);
arch/arm/mach-msm/rpcrouter_sdio_xprt.c-					   &work_read_data,
arch/arm/mach-msm/rpcrouter_sdio_xprt.c-					   &work_read_data,
arch/arm/mach-msm/rpcrouter_sdio_xprt.c-					   &work_read_data,
arch/arm/mach-msm/rpcrouter_sdio_xprt.c-				   &work_read_data, 0);
arch/arm/mach-msm/rpm-regulator.c-}
arch/arm/mach-msm/rpm-regulator.c-	 */
arch/arm/mach-msm/rpm-regulator.c-	if (tcxo_handle)
arch/arm/mach-msm/rpm-regulator.c-				msecs_to_jiffies(TCXO_WARMUP_TIME_MS) + 1);
arch/arm/mach-msm/rpm-regulator.c:		schedule_delayed_work(&tcxo_disable_work,
arch/arm/mach-msm/sdio_dmux.c-
arch/arm/mach-msm/sdio_dmux.c-					);
arch/arm/mach-msm/sdio_dmux.c:					&delayed_work_sdio_mux_write,
arch/arm/mach-msm/sdio_dmux.c-		} else {
arch/arm/mach-msm/sdio_dmux.c-					msecs_to_jiffies(250)
arch/arm/mach-msm/sdio_dmux.c:			queue_delayed_work(sdio_mux_workqueue,
arch/arm/mach-msm/sdio_dmux.c-			__skb_queue_head(&sdio_mux_write_pool, skb);
arch/arm/mach-msm/sdio_dmux.c:static DECLARE_DELAYED_WORK(delayed_work_sdio_mux_write, sdio_mux_write_data);
arch/arm/mach-msm/sdio_dmux.c-static DECLARE_WORK(work_sdio_mux_read, sdio_mux_read_data);
arch/arm/mach-msm/sdio_dmux.c-static DECLARE_WORK(work_sdio_mux_write, sdio_mux_write_data);
arch/arm/mach-msm/sdio_dmux.c-static struct workqueue_struct *sdio_mux_workqueue;
arch/arm/mach-msm/sec_thermistor.c-
arch/arm/mach-msm/sec_thermistor.c-
arch/arm/mach-msm/sec_thermistor.c-
arch/arm/mach-msm/sec_thermistor.c-
arch/arm/mach-msm/sec_thermistor.c-
arch/arm/mach-msm/sec_thermistor.c-
arch/arm/mach-msm/sec_thermistor.c-
arch/arm/mach-msm/sec_thermistor.c-
arch/arm/mach-msm/sec_thermistor.c-}
arch/arm/mach-msm/sec_thermistor.c:		cancel_delayed_work(&info->polling_work);
arch/arm/mach-msm/sec_thermistor.c:		cancel_delayed_work(&info->polling_work);
arch/arm/mach-msm/sec_thermistor.c-	if (!(info->pdata->no_polling))
arch/arm/mach-msm/sec_thermistor.c-	if (!(info->pdata->no_polling))
arch/arm/mach-msm/sec_thermistor.c-	if (!(info->pdata->no_polling))
arch/arm/mach-msm/sec_thermistor.c-		INIT_DEFERRABLE_WORK(&info->polling_work,
arch/arm/mach-msm/sec_thermistor.c-	int curr_temperature;
arch/arm/mach-msm/sec_thermistor.c-	kfree(info);
arch/arm/mach-msm/sec_thermistor.c-			msecs_to_jiffies(info->pdata->polling_interval));
arch/arm/mach-msm/sec_thermistor.c-			msecs_to_jiffies(info->pdata->polling_interval));
arch/arm/mach-msm/sec_thermistor.c-			msecs_to_jiffies(info->pdata->polling_interval));
arch/arm/mach-msm/sec_thermistor.c-out:
arch/arm/mach-msm/sec_thermistor.c-	return 0;
arch/arm/mach-msm/sec_thermistor.c-	return 0;
arch/arm/mach-msm/sec_thermistor.c:	schedule_delayed_work(&info->polling_work,
arch/arm/mach-msm/sec_thermistor.c:		schedule_delayed_work(&info->polling_work,
arch/arm/mach-msm/sec_thermistor.c:		schedule_delayed_work(&info->polling_work,
arch/arm/mach-msm/sec_thermistor.c-			sec_therm_polling_work);
arch/arm/mach-msm/sec_thermistor.c:	struct delayed_work polling_work;
arch/arm/mach-msm/sec_thermistor.c-	struct device *dev;
arch/arm/mach-msm/sec_thermistor.c-	struct sec_therm_platform_data *pdata;
arch/arm/mach-msm/smd_pkt.c-		break;
arch/arm/mach-msm/smd_pkt.c-		clean_and_signal(smd_pkt_devp);
arch/arm/mach-msm/smd_pkt.c-	** doesn't degrade the performance. */
arch/arm/mach-msm/smd_pkt.c-	else
arch/arm/mach-msm/smd_pkt.c-	if (!is_modem_smsm_inited())
arch/arm/mach-msm/smd_pkt.c-		if (smd_pkt_devp->i == LOOPBACK_INX)
arch/arm/mach-msm/smd_pkt.c-					msecs_to_jiffies(1000));
arch/arm/mach-msm/smd_pkt.c:			schedule_delayed_work(&loopback_work,
arch/arm/mach-msm/smd_pkt.c:		schedule_delayed_work(&loopback_work, msecs_to_jiffies(1000));
arch/arm/mach-msm/smd_pkt.c-		smsm_change_state(SMSM_APPS_STATE,
arch/arm/mach-msm/smd_pkt.c-static dev_t smd_pkt_number;
arch/arm/mach-msm/smd_pkt.c:static struct delayed_work loopback_work;
arch/arm/mach-msm/smd_pkt.c-static void check_and_wakeup_reader(struct smd_pkt_dev *smd_pkt_devp);
arch/arm/mach-msm/smd_pkt.c-static void check_and_wakeup_writer(struct smd_pkt_dev *smd_pkt_devp);
arch/arm/mach-msm/smd_pkt.c-struct class *smd_pkt_classp;
arch/arm/mach-msm/smd_tty.c-
arch/arm/mach-msm/smd_tty.c-
arch/arm/mach-msm/smd_tty.c-		break;
arch/arm/mach-msm/smd_tty.c-#define BT_CMD_IDX 3
arch/arm/mach-msm/smd_tty.c-	else
arch/arm/mach-msm/smd_tty.c-		if (info->tty->index == LOOPBACK_IDX)
arch/arm/mach-msm/smd_tty.c-	if (!is_modem_smsm_inited())
arch/arm/mach-msm/smd_tty.c-					msecs_to_jiffies(1000));
arch/arm/mach-msm/smd_tty.c:			schedule_delayed_work(&loopback_work,
arch/arm/mach-msm/smd_tty.c:		schedule_delayed_work(&loopback_work, msecs_to_jiffies(1000));
arch/arm/mach-msm/smd_tty.c-		smsm_change_state(SMSM_APPS_STATE,
arch/arm/mach-msm/smd_tty.c:static struct delayed_work loopback_work;
arch/arm/mach-msm/smd_tty.c-static struct pm_qos_request smd_tty_qos_req;
arch/arm/mach-msm/smd_tty.c-static struct smd_tty_info smd_tty[MAX_SMD_TTYS];
arch/arm/mach-msm/smd_tty.c-	/* wait for modem to restart before requesting loopback server */
arch/arm/mach-msm/state_helper.c-
arch/arm/mach-msm/state_helper.c-
arch/arm/mach-msm/state_helper.c-
arch/arm/mach-msm/state_helper.c-
arch/arm/mach-msm/state_helper.c-
arch/arm/mach-msm/state_helper.c-
arch/arm/mach-msm/state_helper.c-}
arch/arm/mach-msm/state_helper.c-}
arch/arm/mach-msm/state_helper.c:	cancel_delayed_work_sync(&helper_work);
arch/arm/mach-msm/state_helper.c:	cancel_delayed_work_sync(&helper_work);
arch/arm/mach-msm/state_helper.c:	cancel_delayed_work_sync(&helper_work);
arch/arm/mach-msm/state_helper.c-#define dprintk(msg...)		\
arch/arm/mach-msm/state_helper.c-	flush_workqueue(helper_wq);
arch/arm/mach-msm/state_helper.c-		msecs_to_jiffies(DELAY_MSEC));
arch/arm/mach-msm/state_helper.c:	queue_delayed_work(helper_wq, &helper_work,
arch/arm/mach-msm/state_helper.c:	queue_delayed_work(helper_wq, &helper_work, 0);
arch/arm/mach-msm/state_helper.c-		return;
arch/arm/mach-msm/state_helper.c:static struct delayed_work helper_work;
arch/arm/mach-msm/state_helper.c-static struct notifier_block notif;
arch/arm/mach-msm/state_helper.c-static struct workqueue_struct *helper_wq;
arch/arm/mach-msm/state_helper.c-	//thermal_check();
arch/arm/mach-msm/state_helper.c-	/* Wake up all the sibling cores */
arch/arm/mach-msm/wcnss-ssr-8960.c-
arch/arm/mach-msm/wcnss-ssr-8960.c-
arch/arm/mach-msm/wcnss-ssr-8960.c-{
arch/arm/mach-msm/wcnss-ssr-8960.c-#define MAX_BUF_SIZE			0x51
arch/arm/mach-msm/wcnss-ssr-8960.c-	disable_irq_nosync(RIVA_APSS_WDOG_BITE_RESET_RDY_IRQ);
arch/arm/mach-msm/wcnss-ssr-8960.c-	enable_irq(RIVA_APSS_WDOG_BITE_RESET_RDY_IRQ);
arch/arm/mach-msm/wcnss-ssr-8960.c:	flush_delayed_work(&cancel_vote_work);
arch/arm/mach-msm/wcnss-ssr-8960.c-	pil_force_shutdown("wcnss");
arch/arm/mach-msm/wcnss-ssr-8960.c-	return ret;
arch/arm/mach-msm/wcnss-ssr-8960.c:	schedule_delayed_work(&cancel_vote_work, msecs_to_jiffies(5000));
arch/arm/mach-msm/wcnss-ssr-8960.c-	ss_restart_inprogress = false;
arch/arm/mach-msm/wcnss-ssr-8960.c-static int riva_crash;
arch/arm/mach-msm/wcnss-ssr-8960.c:static struct delayed_work cancel_vote_work;
arch/arm/mach-msm/wcnss-ssr-8960.c-static void *riva_ramdump_dev;
arch/arm/mach-msm/wcnss-ssr-8960.c-	wcnss_flush_delayed_boot_votes();
arch/arm/mach-pxa/sharpsl_pm.c-
arch/arm/mach-pxa/sharpsl_pm.c-
arch/arm/mach-pxa/sharpsl_pm.c-
arch/arm/mach-pxa/sharpsl_pm.c-
arch/arm/mach-pxa/sharpsl_pm.c-
arch/arm/mach-pxa/sharpsl_pm.c-
arch/arm/mach-pxa/sharpsl_pm.c-
arch/arm/mach-pxa/sharpsl_pm.c-
arch/arm/mach-pxa/sharpsl_pm.c-
arch/arm/mach-pxa/sharpsl_pm.c-{
arch/arm/mach-pxa/sharpsl_pm.c-{
arch/arm/mach-pxa/sharpsl_pm.c-}
arch/arm/mach-pxa/sharpsl_pm.c-}
arch/arm/mach-pxa/sharpsl_pm.c-}
arch/arm/mach-pxa/sharpsl_pm.c-}
arch/arm/mach-pxa/sharpsl_pm.c-}
arch/arm/mach-pxa/sharpsl_pm.c-	}
arch/arm/mach-pxa/sharpsl_pm.c-		dev_dbg(sharpsl_pm.dev, "Charge Full: Count too low\n");
arch/arm/mach-pxa/sharpsl_pm.c-		dev_dbg(sharpsl_pm.dev, "Charge Full: Interrupt generated too slowly - retry.\n");
arch/arm/mach-pxa/sharpsl_pm.c-	} else {
arch/arm/mach-pxa/sharpsl_pm.c-	} else if (sharpsl_pm.full_count < 2) {
arch/arm/mach-pxa/sharpsl_pm.c-	} else if (time_after(jiffies, sharpsl_pm.charge_start_time + SHARPSL_CHARGE_FINISH_TIME)) {
arch/arm/mach-pxa/sharpsl_pm.c-EXPORT_SYMBOL(sharpsl_battery_kick);
arch/arm/mach-pxa/sharpsl_pm.c:	flush_delayed_work(&sharpsl_bat);
arch/arm/mach-pxa/sharpsl_pm.c:	flush_delayed_work(&toggle_charger);
arch/arm/mach-pxa/sharpsl_pm.c-	for (i = 0; i < 5; i++) {
arch/arm/mach-pxa/sharpsl_pm.c-	if (sharpsl_pm.charge_mode == CHRG_ON)
arch/arm/mach-pxa/sharpsl_pm.c-	if (!sharpsl_pm.machinfo->batfull_irq && (sharpsl_pm.charge_mode == CHRG_ON)
arch/arm/mach-pxa/sharpsl_pm.c:	schedule_delayed_work(&sharpsl_bat, 0);
arch/arm/mach-pxa/sharpsl_pm.c:	schedule_delayed_work(&sharpsl_bat, 0);
arch/arm/mach-pxa/sharpsl_pm.c:	schedule_delayed_work(&sharpsl_bat, msecs_to_jiffies(125));
arch/arm/mach-pxa/sharpsl_pm.c:	schedule_delayed_work(&sharpsl_bat, msecs_to_jiffies(500));
arch/arm/mach-pxa/sharpsl_pm.c:	schedule_delayed_work(&sharpsl_bat, SHARPSL_BATCHK_TIME);
arch/arm/mach-pxa/sharpsl_pm.c:		schedule_delayed_work(&toggle_charger, 0);
arch/arm/mach-pxa/sharpsl_pm.c:		schedule_delayed_work(&toggle_charger, 0);
arch/arm/mach-pxa/sharpsl_pm.c:		schedule_delayed_work(&toggle_charger, 0);
arch/arm/mach-pxa/sharpsl_pm.c:	schedule_delayed_work(&toggle_charger, msecs_to_jiffies(250));
arch/arm/mach-pxa/sharpsl_pm.c-		sharpsl_charge_off();
arch/arm/mach-pxa/sharpsl_pm.c-		sharpsl_charge_off();
arch/arm/mach-pxa/sharpsl_pm.c-	sharpsl_pm.charge_mode = CHRG_OFF;
arch/arm/mach-pxa/sharpsl_pm.c-	sharpsl_pm.charge_mode = CHRG_ON;
arch/arm/mach-pxa/sharpsl_pm.c-	sharpsl_pm.flags |= SHARPSL_SUSPENDED;
arch/arm/mach-pxa/sharpsl_pm.c-	sharpsl_pm.full_count = 0;
arch/arm/mach-pxa/sharpsl_pm.c-			&& time_after(jiffies, sharpsl_pm.charge_start_time +  SHARPSL_CHARGE_ON_TIME_INTERVAL))
arch/arm/mach-pxa/sharpsl_pm.c-void sharpsl_battery_kick(void)
arch/arm/mach-s3c24xx/mach-gta02.c-
arch/arm/mach-s3c24xx/mach-gta02.c-
arch/arm/mach-s3c24xx/mach-gta02.c-
arch/arm/mach-s3c24xx/mach-gta02.c-
arch/arm/mach-s3c24xx/mach-gta02.c-
arch/arm/mach-s3c24xx/mach-gta02.c-{
arch/arm/mach-s3c24xx/mach-gta02.c-}
arch/arm/mach-s3c24xx/mach-gta02.c-}
arch/arm/mach-s3c24xx/mach-gta02.c-	}
arch/arm/mach-s3c24xx/mach-gta02.c:		cancel_delayed_work_sync(&gta02_charger_work);
arch/arm/mach-s3c24xx/mach-gta02.c-			      GTA02_CHARGER_CONFIGURE_TIMEOUT);
arch/arm/mach-s3c24xx/mach-gta02.c-				      GTA02_CHARGER_CONFIGURE_TIMEOUT);
arch/arm/mach-s3c24xx/mach-gta02.c-		gta02_usb_vbus_draw = 0;
arch/arm/mach-s3c24xx/mach-gta02.c-	gta02_usb_vbus_draw = ma;
arch/arm/mach-s3c24xx/mach-gta02.c-	if (irq == PCF50633_IRQ_USBINS) {
arch/arm/mach-s3c24xx/mach-gta02.c-	if (irq == PCF50633_IRQ_USBREM) {
arch/arm/mach-s3c24xx/mach-gta02.c:	schedule_delayed_work(&gta02_charger_work,
arch/arm/mach-s3c24xx/mach-gta02.c:		schedule_delayed_work(&gta02_charger_work,
arch/arm/mach-s3c24xx/mach-gta02.c-static int gta02_usb_vbus_draw;
arch/arm/mach-s3c24xx/mach-gta02.c:static struct delayed_work gta02_charger_work;
arch/arm/mach-shmobile/board-mackerel.c-
arch/arm/mach-shmobile/board-mackerel.c-
arch/arm/mach-shmobile/board-mackerel.c-
arch/arm/mach-shmobile/board-mackerel.c-
arch/arm/mach-shmobile/board-mackerel.c-}
arch/arm/mach-shmobile/board-mackerel.c-}
arch/arm/mach-shmobile/board-mackerel.c-}
arch/arm/mach-shmobile/board-mackerel.c-};
arch/arm/mach-shmobile/board-mackerel.c:	cancel_delayed_work_sync(&priv->work);
arch/arm/mach-shmobile/board-mackerel.c-	INIT_DELAYED_WORK(&priv->work, usbhs0_work_function);
arch/arm/mach-shmobile/board-mackerel.c-	priv->pdev = pdev;
arch/arm/mach-shmobile/board-mackerel.c-	renesas_usbhs_call_notify_hotplug(priv->pdev);
arch/arm/mach-shmobile/board-mackerel.c-	return 0;
arch/arm/mach-shmobile/board-mackerel.c:	schedule_delayed_work(&priv->work, USBHS0_POLL_INTERVAL);
arch/arm/mach-shmobile/board-mackerel.c:	schedule_delayed_work(&priv->work, USBHS0_POLL_INTERVAL);
arch/arm/mach-shmobile/board-mackerel.c:	struct delayed_work work;
arch/arm/mach-shmobile/board-mackerel.c-	struct platform_device *pdev;
arch/arm/mach-shmobile/board-mackerel.c-	struct renesas_usbhs_platform_info info;
arch/arm/mach-shmobile/board-mackerel.c-	struct usbhs_private *priv = usbhs_get_priv(pdev);
arch/arm/mach-shmobile/board-mackerel.c-	unsigned int usbcrcaddr;
arch/arm/mvp/commkm/comm_os_linux.c-
arch/arm/mvp/commkm/comm_os_linux.c-
arch/arm/mvp/commkm/comm_os_linux.c-
arch/arm/mvp/commkm/comm_os_linux.c-
arch/arm/mvp/commkm/comm_os_linux.c-{
arch/arm/mvp/commkm/comm_os_linux.c-{
arch/arm/mvp/commkm/comm_os_linux.c-{
arch/arm/mvp/commkm/comm_os_linux.c-{
arch/arm/mvp/commkm/comm_os_linux.c-}
arch/arm/mvp/commkm/comm_os_linux.c-}
arch/arm/mvp/commkm/comm_os_linux.c-}
arch/arm/mvp/commkm/comm_os_linux.c-}
arch/arm/mvp/commkm/comm_os_linux.c:	cancel_delayed_work_sync(work);
arch/arm/mvp/commkm/comm_os_linux.c-FlushDelayedWork(CommOSWork *work)
arch/arm/mvp/commkm/comm_os_linux.c:	flush_delayed_work(work);
arch/arm/mvp/commkm/comm_os_linux.c:	return !queue_delayed_work_on(cpu, wq, work, jif) ? -1 : 0;
arch/arm/mvp/commkm/comm_os_linux.c:	return !queue_delayed_work(wq, work, jif) ? -1 : 0;
arch/arm/mvp/commkm/comm_os_linux.c-		   unsigned long jif)
arch/arm/mvp/commkm/comm_os_linux.c-		 unsigned long jif)
arch/arm/mvp/commkm/comm_os_linux.c-WaitForDelayedWork(CommOSWork *work)
arch/arm/mvp/oektestkm/mvp_fake_kb.c-{
arch/arm/mvp/oektestkm/mvp_fake_kb.c-	}
arch/arm/mvp/oektestkm/mvp_fake_kb.c-	/* Cancel delayed work for automatic unregistration */
arch/arm/mvp/oektestkm/mvp_fake_kb.c:	cancel_delayed_work(&unregister_keyboard_work);
arch/arm/mvp/oektestkm/mvp_fake_kb.c:		cancel_delayed_work(&unregister_keyboard_work);
arch/arm/mvp/oektestkm/mvp_fake_kb.c:			cancel_delayed_work(&unregister_keyboard_work);
arch/arm/mvp/oektestkm/mvp_fake_kb.c-	} else {
arch/arm/mvp/oektestkm/mvp_fake_kb.c-	if (key_dev != NULL) {
arch/arm/mvp/oektestkm/mvp_fake_kb.c-		if (time_after(new_timeout, time_to_unregister)) {
arch/arm/mvp/oektestkm/mvp_fake_kb.c-			jiffies + msecs_to_jiffies(timeout * 1000);
arch/arm/mvp/oektestkm/mvp_fake_kb.c-		/* keep the keyboard enabled until manual disable */
arch/arm/mvp/oektestkm/mvp_fake_kb.c-					      msecs_to_jiffies(timeout * 1000));
arch/arm/mvp/oektestkm/mvp_fake_kb.c:			schedule_delayed_work(&unregister_keyboard_work,
arch/arm/mvp/oektestkm/mvp_fake_kb.c-	time_to_unregister = INITIAL_JIFFIES;
arch/arm/mvp/oektestkm/mvp_fake_kb.c-		time_to_unregister = MAX_JIFFY_OFFSET;
arch/arm/mvp/oektestkm/mvp_fake_kb.c-			time_to_unregister = new_timeout;
arch/arm/mvp/pvtcpkm/comm_os_linux.c-
arch/arm/mvp/pvtcpkm/comm_os_linux.c-
arch/arm/mvp/pvtcpkm/comm_os_linux.c-
arch/arm/mvp/pvtcpkm/comm_os_linux.c-
arch/arm/mvp/pvtcpkm/comm_os_linux.c-{
arch/arm/mvp/pvtcpkm/comm_os_linux.c-{
arch/arm/mvp/pvtcpkm/comm_os_linux.c-{
arch/arm/mvp/pvtcpkm/comm_os_linux.c-{
arch/arm/mvp/pvtcpkm/comm_os_linux.c-}
arch/arm/mvp/pvtcpkm/comm_os_linux.c-}
arch/arm/mvp/pvtcpkm/comm_os_linux.c-}
arch/arm/mvp/pvtcpkm/comm_os_linux.c-}
arch/arm/mvp/pvtcpkm/comm_os_linux.c:	cancel_delayed_work_sync(work);
arch/arm/mvp/pvtcpkm/comm_os_linux.c-FlushDelayedWork(CommOSWork *work)
arch/arm/mvp/pvtcpkm/comm_os_linux.c:	flush_delayed_work(work);
arch/arm/mvp/pvtcpkm/comm_os_linux.c:	return !queue_delayed_work_on(cpu, wq, work, jif) ? -1 : 0;
arch/arm/mvp/pvtcpkm/comm_os_linux.c:	return !queue_delayed_work(wq, work, jif) ? -1 : 0;
arch/arm/mvp/pvtcpkm/comm_os_linux.c-		   unsigned long jif)
arch/arm/mvp/pvtcpkm/comm_os_linux.c-		 unsigned long jif)
arch/arm/mvp/pvtcpkm/comm_os_linux.c-WaitForDelayedWork(CommOSWork *work)
arch/tile/kernel/smpboot.c-	 */
arch/tile/kernel/smpboot.c-	 * isolated from the scheduler, to keep init away from likely
arch/tile/kernel/smpboot.c-	 * more useful user code.  This also ensures that work scheduled
arch/tile/kernel/smpboot.c-	 * on this cpu.
arch/tile/kernel/smpboot.c:	 * via schedule_delayed_work() in the init routines will land
arch/um/drivers/chan_kern.c-		}
arch/um/drivers/chan_kern.c-	do {
arch/um/drivers/chan_kern.c-			goto out;
arch/um/drivers/chan_kern.c-		if (tty && !tty_buffer_request_room(tty, 1)) {
arch/um/drivers/chan_kern.c:			schedule_delayed_work(&line->task, 1);
arch/x86/kernel/check.c-
arch/x86/kernel/check.c-{
arch/x86/kernel/check.c-}
arch/x86/kernel/check.c-}
arch/x86/kernel/check.c-	check_for_bios_corruption();
arch/x86/kernel/check.c-	/* First time we run the checks right away */
arch/x86/kernel/check.c-	return 0;
arch/x86/kernel/check.c-		round_jiffies_relative(corruption_check_period*HZ));
arch/x86/kernel/check.c:	schedule_delayed_work(&bios_check_work,
arch/x86/kernel/check.c:	schedule_delayed_work(&bios_check_work, 0);
arch/x86/kernel/hpet.c-
arch/x86/kernel/hpet.c-};
arch/x86/kernel/hpet.c-		destroy_timer_on_stack(&work.work.timer);
arch/x86/kernel/hpet.c-		/* FIXME: add schedule_work_on() */
arch/x86/kernel/hpet.c-		init_completion(&work.complete);
arch/x86/kernel/hpet.c:		schedule_delayed_work_on(cpu, &work.work, 0);
arch/x86/kernel/hpet.c-	struct completion complete;
arch/x86/kernel/hpet.c:	struct delayed_work work;
arch/x86/kernel/hpet.c-struct hpet_work_struct {
arch/x86/kernel/hpet.c-		wait_for_completion(&work.complete);
arch/x86/kernel/tsc.c-
arch/x86/kernel/tsc.c-}
arch/x86/kernel/tsc.c-	}
arch/x86/kernel/tsc.c-		 */
arch/x86/kernel/tsc.c-		hpet = is_hpet_enabled();
arch/x86/kernel/tsc.c-		return;
arch/x86/kernel/tsc.c-	return 0;
arch/x86/kernel/tsc.c:	schedule_delayed_work(&tsc_irqwork, 0);
arch/x86/kernel/tsc.c:		schedule_delayed_work(&tsc_irqwork, HZ);
arch/x86/kernel/tsc.c-		tsc_start = tsc_read_refs(&ref_start, hpet);
block/blk-core.c-
block/blk-core.c-
block/blk-core.c-
block/blk-core.c-
block/blk-core.c-/**
block/blk-core.c-{
block/blk-core.c-{
block/blk-core.c-{
block/blk-core.c-{
block/blk-core.c-{
block/blk-core.c-}
block/blk-core.c-}
block/blk-core.c-}
block/blk-core.c-}
block/blk-core.c-}
block/blk-core.c-}
block/blk-core.c-	}
block/blk-core.c-		}
block/blk-core.c:	cancel_delayed_work(&q->delay_work);
block/blk-core.c:			cancel_delayed_work_sync(&hctx->delay_work);
block/blk-core.c:			cancel_delayed_work_sync(&hctx->run_work);
block/blk-core.c:		cancel_delayed_work_sync(&q->delay_work);
block/blk-core.c-	} else {
block/blk-core.c-EXPORT_SYMBOL(blk_run_queue_async);
block/blk-core.c:EXPORT_SYMBOL(kblockd_schedule_delayed_work);
block/blk-core.c:EXPORT_SYMBOL(kblockd_schedule_delayed_work_on);
block/blk-core.c-EXPORT_SYMBOL(kblockd_schedule_work_on);
block/blk-core.c-	if (likely(!blk_queue_dying(q)))
block/blk-core.c-	if (likely(!blk_queue_stopped(q) && !blk_queue_dying(q)))
block/blk-core.c:int kblockd_schedule_delayed_work_on(int cpu, struct delayed_work *dwork,
block/blk-core.c:int kblockd_schedule_delayed_work(struct delayed_work *dwork, unsigned long delay)
block/blk-core.c:		mod_delayed_work(kblockd_workqueue, &q->delay_work, 0);
block/blk-core.c-				   msecs_to_jiffies(msecs));
block/blk-core.c:		queue_delayed_work(kblockd_workqueue, &q->delay_work,
block/blk-core.c-	queue_flag_set(QUEUE_FLAG_STOPPED, q);
block/blk-core.c-		queue_for_each_hw_ctx(q, hctx, i) {
block/blk-core.c:	return queue_delayed_work(kblockd_workqueue, dwork, delay);
block/blk-core.c:	return queue_delayed_work_on(cpu, kblockd_workqueue, dwork, delay);
block/blk-core.c-				     unsigned long delay)
block/blk-core.c-void blk_stop_queue(struct request_queue *q)
block/blk-mq.c-
block/blk-mq.c-
block/blk-mq.c-{
block/blk-mq.c-}
block/blk-mq.c-}
block/blk-mq.c-}
block/blk-mq.c-	}
block/blk-mq.c:	cancel_delayed_work(&hctx->delay_work);
block/blk-mq.c:	cancel_delayed_work(&hctx->run_work);
block/blk-mq.c-			&hctx->delay_work, msecs_to_jiffies(msecs));
block/blk-mq.c-			&hctx->run_work, 0);
block/blk-mq.c:	kblockd_schedule_delayed_work_on(blk_mq_hctx_next_cpu(hctx),
block/blk-mq.c:	kblockd_schedule_delayed_work_on(blk_mq_hctx_next_cpu(hctx),
block/blk-mq.c-		return;
block/blk-mq.c-	set_bit(BLK_MQ_S_STOPPED, &hctx->state);
block/blk-mq.c-void blk_mq_stop_hw_queue(struct blk_mq_hw_ctx *hctx)
block/blk-throttle.c-
block/blk-throttle.c-{
block/blk-throttle.c-}
block/blk-throttle.c-		}
block/blk-throttle.c-			/* allocation failed, try again after some time */
block/blk-throttle.c-	bool empty = false;
block/blk-throttle.c-		if (!stats_cpu) {
block/blk-throttle.c-	list_add(&tg->stats_alloc_node, &tg_stats_alloc_list);
block/blk-throttle.c-			return;
block/blk-throttle.c:			schedule_delayed_work(dwork, msecs_to_jiffies(10));
block/blk-throttle.c:	schedule_delayed_work(&tg_stats_alloc_work, 0);
block/blk-throttle.c-	spin_lock_irqsave(&tg_stats_alloc_lock, flags);
block/blk-throttle.c-	spin_unlock_irqrestore(&tg_stats_alloc_lock, flags);
block/blk-throttle.c-	static struct tg_stats_cpu *stats_cpu;	/* this fn is non-reentrant */
block/blk-throttle.c:	struct delayed_work *dwork = to_delayed_work(work);
block/genhd.c-
block/genhd.c-
block/genhd.c-
block/genhd.c-
block/genhd.c-
block/genhd.c-
block/genhd.c-{
block/genhd.c-};
block/genhd.c:		cancel_delayed_work_sync(&disk->ev->dwork);
block/genhd.c-	else if (intv)
block/genhd.c-	ev->clearing |= mask;
block/genhd.c-				&ev->dwork, 0);
block/genhd.c-				&ev->dwork, 0);
block/genhd.c-				&ev->dwork, intv);
block/genhd.c-				&ev->dwork, intv);
block/genhd.c-	if (cancel)
block/genhd.c-	if (check_now)
block/genhd.c-	if (!ev->block)
block/genhd.c-	if (!ev->block && intv)
block/genhd.c-	intv = disk_events_poll_jiffies(disk);
block/genhd.c-	intv = disk_events_poll_jiffies(disk);
block/genhd.c-	long			poll_msecs;	/* interval, -1 for default */
block/genhd.c:		mod_delayed_work(system_freezable_power_efficient_wq,
block/genhd.c-	mutex_unlock(&ev->block_mutex);
block/genhd.c-out_unlock:
block/genhd.c:		queue_delayed_work(system_freezable_power_efficient_wq,
block/genhd.c:		queue_delayed_work(system_freezable_power_efficient_wq,
block/genhd.c:		queue_delayed_work(system_freezable_power_efficient_wq,
block/genhd.c-	spin_unlock_irq(&ev->lock);
block/genhd.c-static void disk_events_workfn(struct work_struct *work)
block/genhd.c:	struct delayed_work	dwork;
block/genhd.c:	struct delayed_work *dwork = to_delayed_work(work);
block/genhd.c-	struct disk_events *ev = container_of(dwork, struct disk_events, dwork);
drivers/ata/libata-eh.c-
drivers/ata/libata-eh.c-		ap->pflags &= ~ATA_PFLAG_LOADING;
drivers/ata/libata-eh.c-	else if (ap->pflags & ATA_PFLAG_SCSI_HOTPLUG)
drivers/ata/libata-eh.c-	if (ap->pflags & ATA_PFLAG_RECOVERED)
drivers/ata/libata-eh.c:		schedule_delayed_work(&ap->hotplug_task, 0);
drivers/ata/libata-scsi.c-
drivers/ata/libata-scsi.c-}
drivers/ata/libata-scsi.c-	}
drivers/ata/libata-scsi.c:	queue_delayed_work(system_long_wq, &ap->hotplug_task,
drivers/ata/libata-scsi.c-			   round_jiffies_relative(HZ));
drivers/ata/libata-sff.c-
drivers/ata/libata-sff.c-
drivers/ata/libata-sff.c-
drivers/ata/libata-sff.c-
drivers/ata/libata-sff.c-
drivers/ata/libata-sff.c-{
drivers/ata/libata-sff.c-}
drivers/ata/libata-sff.c-}
drivers/ata/libata-sff.c-	/*
drivers/ata/libata-sff.c:	ata_sff_queue_delayed_work(&ap->sff_pio_task, msecs_to_jiffies(delay));
drivers/ata/libata-sff.c:	cancel_delayed_work_sync(&ap->sff_pio_task);
drivers/ata/libata-sff.c-	DPRINTK("ENTER\n");
drivers/ata/libata-sff.c:EXPORT_SYMBOL_GPL(ata_sff_queue_delayed_work);
drivers/ata/libata-sff.c-EXPORT_SYMBOL_GPL(ata_sff_queue_pio_task);
drivers/ata/libata-sff.c-EXPORT_SYMBOL_GPL(ata_sff_queue_work);
drivers/ata/libata-sff.c-	/* may fail if ata_sff_flush_pio_task() in progress */
drivers/ata/libata-sff.c:	queue_delayed_work(ata_sff_wq, dwork, delay);
drivers/ata/libata-sff.c:void ata_sff_queue_delayed_work(struct delayed_work *dwork, unsigned long delay)
drivers/ata/libata-sff.c-void ata_sff_queue_pio_task(struct ata_link *link, unsigned long delay)
drivers/ata/pata_arasan_cf.c-
drivers/ata/pata_arasan_cf.c-}
drivers/ata/pata_arasan_cf.c-	 */
drivers/ata/pata_arasan_cf.c-		}
drivers/ata/pata_arasan_cf.c:			ata_sff_queue_delayed_work(&acdev->dwork, 1);
drivers/ata/pata_arasan_cf.c:		ata_sff_queue_delayed_work(&acdev->dwork, 1);
drivers/ata/pata_arasan_cf.c:	cancel_delayed_work_sync(&acdev->dwork);
drivers/ata/pata_arasan_cf.c-	cancel_work_sync(&acdev->work);
drivers/ata/pata_arasan_cf.c-		dma_complete(acdev);
drivers/ata/pata_arasan_cf.c-	/* DMA delayed finish work */
drivers/ata/pata_arasan_cf.c-	else
drivers/ata/pata_arasan_cf.c-		if (status & (ATA_BUSY | ATA_DRQ)) {
drivers/ata/pata_arasan_cf.c-	if (status & (ATA_BUSY | ATA_DRQ))
drivers/ata/pata_arasan_cf.c-	/* qc to be transferred using DMA */
drivers/ata/pata_arasan_cf.c-			return;
drivers/ata/pata_arasan_cf.c-	return ata_sff_error_handler(ap);
drivers/ata/pata_arasan_cf.c-		spin_unlock_irqrestore(&acdev->host->lock, flags);
drivers/ata/pata_arasan_cf.c-	struct ata_queued_cmd *qc;
drivers/ata/pata_arasan_cf.c:	struct delayed_work dwork;
drivers/ata/pata_arasan_cf.c-	struct work_struct work;
drivers/ata/pata_octeon_cf.c-
drivers/ata/pata_octeon_cf.c-				   &cf_port->delayed_finish, 1);
drivers/ata/pata_octeon_cf.c-						   &cf_port->delayed_finish, 1);
drivers/ata/pata_octeon_cf.c-					       dma_int.u64);
drivers/ata/pata_octeon_cf.c-		goto out;
drivers/ata/pata_octeon_cf.c-				handled = 1;
drivers/ata/pata_octeon_cf.c-	if (status & (ATA_BUSY | ATA_DRQ)) {
drivers/ata/pata_octeon_cf.c-	int dma_finished;
drivers/ata/pata_octeon_cf.c:		queue_delayed_work(cf_port->wq,
drivers/ata/pata_octeon_cf.c:				queue_delayed_work(cf_port->wq,
drivers/ata/pata_octeon_cf.c-		/* Still busy, try again. */
drivers/ata/pata_octeon_cf.c-	struct ata_port *ap;
drivers/ata/pata_octeon_cf.c:	struct delayed_work delayed_finish;
drivers/ata/pata_octeon_cf.c-struct octeon_cf_port {
drivers/ata/pata_octeon_cf.c-	struct workqueue_struct *wq;
drivers/auxdisplay/cfag12864b.c-{
drivers/auxdisplay/cfag12864b.c-}
drivers/auxdisplay/cfag12864b.c-	}
drivers/auxdisplay/cfag12864b.c:		cancel_delayed_work(&cfag12864b_work);
drivers/auxdisplay/cfag12864b.c-		cfag12864b_updating = 0;
drivers/auxdisplay/cfag12864b.c-		flush_workqueue(cfag12864b_workqueue);
drivers/auxdisplay/cfag12864b.c-		HZ / cfag12864b_rate);
drivers/auxdisplay/cfag12864b.c-	if (cfag12864b_updating) {
drivers/auxdisplay/cfag12864b.c:	queue_delayed_work(cfag12864b_workqueue, &cfag12864b_work,
drivers/auxdisplay/cfag12864b.c-static DECLARE_DELAYED_WORK(cfag12864b_work, cfag12864b_update);
drivers/auxdisplay/cfag12864b.c-static DEFINE_MUTEX(cfag12864b_mutex);
drivers/auxdisplay/cfag12864b.c-static struct workqueue_struct *cfag12864b_workqueue;
drivers/auxdisplay/cfag12864b.c-static unsigned char cfag12864b_updating;
drivers/auxdisplay/cfag12864b.c-static void cfag12864b_queue(void)
drivers/auxdisplay/cfag12864b.c:static void cfag12864b_update(struct work_struct *delayed_work);
drivers/barcode_emul/barcode_emul_ice4_8930_442.c-
drivers/barcode_emul/barcode_emul_ice4_8930_442.c-	const struct firmware		*fw;
drivers/barcode_emul/barcode_emul_ice4_8930_442.c-			&data->fw_dl, msecs_to_jiffies(20));
drivers/barcode_emul/barcode_emul_ice4_8930_442.c-#if defined(CONFIG_IR_REMOCON_FPGA)
drivers/barcode_emul/barcode_emul_ice4_8930_442.c-	INIT_DELAYED_WORK(&data->fw_dl, fw_work);
drivers/barcode_emul/barcode_emul_ice4_8930_442.c-	/* min 1ms is needed */
drivers/barcode_emul/barcode_emul_ice4_8930_442.c:	queue_delayed_work(data->firmware_dl,
drivers/barcode_emul/barcode_emul_ice4_8930_442.c:	struct delayed_work		fw_dl;
drivers/barcode_emul/barcode_emul_ice4_8930_442.c-	struct i2c_client		*client;
drivers/barcode_emul/barcode_emul_ice4_8930_442.c-	struct workqueue_struct		*firmware_dl;
drivers/barcode_emul/barcode_emul_ice4_8930.c-
drivers/barcode_emul/barcode_emul_ice4_8930.c-	const struct firmware		*fw;
drivers/barcode_emul/barcode_emul_ice4_8930.c-			&data->fw_dl, msecs_to_jiffies(20));
drivers/barcode_emul/barcode_emul_ice4_8930.c-#if defined(CONFIG_IR_REMOCON_FPGA)
drivers/barcode_emul/barcode_emul_ice4_8930.c-	INIT_DELAYED_WORK(&data->fw_dl, fw_work);
drivers/barcode_emul/barcode_emul_ice4_8930.c-	/* min 1ms is needed */
drivers/barcode_emul/barcode_emul_ice4_8930.c:	queue_delayed_work(data->firmware_dl,
drivers/barcode_emul/barcode_emul_ice4_8930.c:	struct delayed_work		fw_dl;
drivers/barcode_emul/barcode_emul_ice4_8930.c-	struct i2c_client		*client;
drivers/barcode_emul/barcode_emul_ice4_8930.c-	struct workqueue_struct		*firmware_dl;
drivers/barcode_emul/barcode_emul_ice4.c-
drivers/barcode_emul/barcode_emul_ice4.c-	const struct firmware		*fw;
drivers/barcode_emul/barcode_emul_ice4.c-			&data->fw_dl, msecs_to_jiffies(20));
drivers/barcode_emul/barcode_emul_ice4.c-#if defined(CONFIG_IR_REMOCON_FPGA)
drivers/barcode_emul/barcode_emul_ice4.c-	INIT_DELAYED_WORK(&data->fw_dl, fw_work);
drivers/barcode_emul/barcode_emul_ice4.c-	/* min 1ms is needed */
drivers/barcode_emul/barcode_emul_ice4.c:	queue_delayed_work(data->firmware_dl,
drivers/barcode_emul/barcode_emul_ice4.c:	struct delayed_work		fw_dl;
drivers/barcode_emul/barcode_emul_ice4.c-	struct i2c_client		*client;
drivers/barcode_emul/barcode_emul_ice4.c-	struct workqueue_struct		*firmware_dl;
drivers/base/devcoredump.c-
drivers/base/devcoredump.c-
drivers/base/devcoredump.c-
drivers/base/devcoredump.c-
drivers/base/devcoredump.c-
drivers/base/devcoredump.c-}
drivers/base/devcoredump.c-};
drivers/base/devcoredump.c-			const void *data, size_t datalen);
drivers/base/devcoredump.c:	flush_delayed_work(&devcd->del_wk);
drivers/base/devcoredump.c-	INIT_DELAYED_WORK(&devcd->del_wk, devcd_del);
drivers/base/devcoredump.c:	mod_delayed_work(system_wq, &devcd->del_wk, 0);
drivers/base/devcoredump.c-	return;
drivers/base/devcoredump.c-	return 0;
drivers/base/devcoredump.c-	return count;
drivers/base/devcoredump.c:	schedule_delayed_work(&devcd->del_wk, DEVCD_TIMEOUT);
drivers/base/devcoredump.c:	struct delayed_work del_wk;
drivers/base/devcoredump.c-	struct devcd_entry *devcd = dev_to_devcd(dev);
drivers/base/devcoredump.c-	struct devcd_entry *devcd = dev_to_devcd(dev);
drivers/base/devcoredump.c-	struct device *failing_dev;
drivers/base/devcoredump.c-	void (*free)(const void *data);
drivers/base/firmware_class.c-
drivers/base/firmware_class.c-
drivers/base/firmware_class.c-
drivers/base/firmware_class.c-
drivers/base/firmware_class.c-
drivers/base/firmware_class.c-
drivers/base/firmware_class.c-{
drivers/base/firmware_class.c-}
drivers/base/firmware_class.c-	/*
drivers/base/firmware_class.c-	bool nowait;
drivers/base/firmware_class.c:	cancel_delayed_work_sync(&fwc->work);
drivers/base/firmware_class.c:	cancel_delayed_work_sync(&fw_priv->timeout_work);
drivers/base/firmware_class.c-	/* cancel uncache work */
drivers/base/firmware_class.c-		dev_dbg(f_dev, "firmware: requesting %s\n", buf->fw_id);
drivers/base/firmware_class.c-					   &fw_priv->timeout_work, timeout);
drivers/base/firmware_class.c-#ifdef CONFIG_FW_LOADER_USER_HELPER
drivers/base/firmware_class.c-	if (is_fw_load_aborted(buf))
drivers/base/firmware_class.c-		if (timeout != MAX_SCHEDULE_TIMEOUT)
drivers/base/firmware_class.c-			   msecs_to_jiffies(delay));
drivers/base/firmware_class.c:			queue_delayed_work(system_wq,
drivers/base/firmware_class.c:	queue_delayed_work(system_wq, &fw_cache.work,
drivers/base/firmware_class.c-		retval = -EAGAIN;
drivers/base/firmware_class.c-static void device_uncache_fw_images_delay(unsigned long delay)
drivers/base/firmware_class.c:	struct delayed_work timeout_work;
drivers/base/firmware_class.c:	struct delayed_work work;
drivers/base/firmware_class.c-	struct device dev;
drivers/base/firmware_class.c-struct firmware_priv {
drivers/base/firmware_class.c-	struct list_head fw_names;
drivers/base/firmware_class.c-	struct notifier_block   pm_notify;
drivers/base/firmware_class.c-	wait_for_completion(&buf->completion);
drivers/battery/max17050_fuelgauge.c-
drivers/battery/max17050_fuelgauge.c-
drivers/battery/max17050_fuelgauge.c-
drivers/battery/max17050_fuelgauge.c:	cancel_delayed_work(&fuelgauge->info.full_comp_work);
drivers/battery/max17050_fuelgauge.c:		cancel_delayed_work(&fuelgauge->info.full_comp_work);
drivers/battery/max17050_fuelgauge.c-		dev_info(&fuelgauge->client->dev,
drivers/battery/max17050_fuelgauge.c-	} else {
drivers/battery/max17050_fuelgauge.c-	if (avg_current >= 25) {
drivers/battery/max17050_fuelgauge.c-		(int)(value.intval == POWER_SUPPLY_STATUS_FULL), true);
drivers/battery/max17050_fuelgauge.c-	return false;
drivers/battery/max17050_fuelgauge.c:		schedule_delayed_work(&fuelgauge->info.full_comp_work, 100);
drivers/battery/max17050_fuelgauge.c:	schedule_delayed_work(&fuelgauge->info.full_comp_work, 100);
drivers/battery/max77693_charger_8930.c-
drivers/battery/max77693_charger_8930.c-
drivers/battery/max77693_charger_8930.c-
drivers/battery/max77693_charger_8930.c-
drivers/battery/max77693_charger_8930.c-	}
drivers/battery/max77693_charger_8930.c:		cancel_delayed_work_sync(&charger->recovery_work);
drivers/battery/max77693_charger_8930.c:				cancel_delayed_work_sync(&charger->wpc_work);
drivers/battery/max77693_charger_8930.c:	cancel_delayed_work_sync(&chg_data->wpc_work);
drivers/battery/max77693_charger_8930.c-	charger->irq_chgin = pdata->irq_base + MAX77693_CHG_IRQ_CHGIN_I;
drivers/battery/max77693_charger_8930.c-			(charger->pdata->ovp_uvlo_check_type ==
drivers/battery/max77693_charger_8930.c-					charger->wc_w_state = 0;
drivers/battery/max77693_charger_8930.c-			delay);
drivers/battery/max77693_charger_8930.c-		delay = msecs_to_jiffies(0);
drivers/battery/max77693_charger_8930.c-	else
drivers/battery/max77693_charger_8930.c-		} else {
drivers/battery/max77693_charger_8930.c-	/* enable chgin irq after sec_battery_probe */
drivers/battery/max77693_charger_8930.c-	if(charger->cable_type == POWER_SUPPLY_TYPE_MAINS) {
drivers/battery/max77693_charger_8930.c-				if (charger->wc_w_state) {
drivers/battery/max77693_charger_8930.c-			if (charger->wc_w_state) {
drivers/battery/max77693_charger_8930.c-		if (chg_data->soft_reg_recovery_cnt < RECOVERY_CNT) {
drivers/battery/max77693_charger_8930.c-	if (chg_data->wc_w_state)
drivers/battery/max77693_charger_8930.c-#if defined(CONFIG_CHARGER_MAX77803)
drivers/battery/max77693_charger_8930.c-							msecs_to_jiffies(0));
drivers/battery/max77693_charger_8930.c-			msecs_to_jiffies(3000));
drivers/battery/max77693_charger_8930.c-					msecs_to_jiffies(500));
drivers/battery/max77693_charger_8930.c-				msecs_to_jiffies(RECOVERY_DELAY));
drivers/battery/max77693_charger_8930.c-				msecs_to_jiffies(RECOVERY_DELAY));
drivers/battery/max77693_charger_8930.c-	/* mutex */
drivers/battery/max77693_charger_8930.c-			pr_info("%s: wpc uvlo, but charging\n",	__func__);
drivers/battery/max77693_charger_8930.c:	queue_delayed_work(charger->wqueue, &charger->chgin_init_work,
drivers/battery/max77693_charger_8930.c:		queue_delayed_work(charger->wqueue, &charger->recovery_work,
drivers/battery/max77693_charger_8930.c:					queue_delayed_work(charger->wqueue, &charger->wpc_work,
drivers/battery/max77693_charger_8930.c:			queue_delayed_work(chg_data->wqueue, &chg_data->recovery_work,
drivers/battery/max77693_charger_8930.c:			queue_delayed_work(chg_data->wqueue, &chg_data->wpc_work,
drivers/battery/max77693_charger_8930.c:	queue_delayed_work(chg_data->wqueue, &chg_data->wpc_work,
drivers/battery/max77693_charger_8930.c:				/* recheck after cancel_delayed_work_sync */
drivers/battery/max77693_charger_8930.c-			return;
drivers/battery/max77693_charger_8930.c-	return IRQ_HANDLED;
drivers/battery/max77693_charger_8930.c-	return IRQ_HANDLED;
drivers/battery/max77693_charger_8930.c:		schedule_delayed_work(&charger->isr_work, 0);
drivers/battery/max77693_charger_8930.c-		/* schedule softreg recovery wq */
drivers/battery/max77693_charger_8930.c-			 SEC_BATTERY_OVP_UVLO_CHGINT))
drivers/battery/max77693_charger_8930.c:	struct delayed_work	chgin_init_work;	/*  chgin init work */
drivers/battery/max77693_charger_8930.c:	struct delayed_work	isr_work;
drivers/battery/max77693_charger_8930.c:	struct delayed_work	recovery_work;	/*  softreg recovery work */
drivers/battery/max77693_charger_8930.c:	struct delayed_work	wpc_work;	/*  wpc detect work */
drivers/battery/max77693_charger_8930.c-	struct workqueue_struct *wqueue;
drivers/battery/max77693_charger_8930.c-	struct work_struct	chgin_work;
drivers/battery/max77693_charger_8930.c-	unsigned long delay;
drivers/battery/max77693_charger_8930.c-		wake_lock(&charger->recovery_wake_lock);
drivers/battery/max77693_charger_8930.c-					wake_lock(&charger->wpc_wake_lock);
drivers/battery/max77693_charger_8930.c-			wake_lock(&chg_data->recovery_wake_lock);
drivers/battery/max77693_charger_8930.c-	wake_lock(&chg_data->wpc_wake_lock);
drivers/battery/max77693_charger_8930.c-			wake_lock(&chg_data->wpc_wake_lock);
drivers/battery/max77693_charger.c-
drivers/battery/max77693_charger.c-
drivers/battery/max77693_charger.c-
drivers/battery/max77693_charger.c-
drivers/battery/max77693_charger.c-	}
drivers/battery/max77693_charger.c:				cancel_delayed_work_sync(&charger->wpc_work);
drivers/battery/max77693_charger.c-	charger->irq_chgin = pdata->irq_base + MAX77693_CHG_IRQ_CHGIN_I;
drivers/battery/max77693_charger.c-			(charger->pdata->ovp_uvlo_check_type ==
drivers/battery/max77693_charger.c-			delay);
drivers/battery/max77693_charger.c-		delay = msecs_to_jiffies(200);
drivers/battery/max77693_charger.c-		} else {
drivers/battery/max77693_charger.c-	/* enable chgin irq after sec_battery_probe */
drivers/battery/max77693_charger.c-#endif
drivers/battery/max77693_charger.c-					if (cable_type.intval != POWER_SUPPLY_TYPE_WIRELESS) {
drivers/battery/max77693_charger.c-				if (charger->wc_w_state) {
drivers/battery/max77693_charger.c-			if (charger->wc_w_state) {
drivers/battery/max77693_charger.c-		if (chg_data->soft_reg_recovery_cnt < RECOVERY_CNT) {
drivers/battery/max77693_charger.c:		mod_delayed_work(charger->wqueue, &charger->recovery_work,
drivers/battery/max77693_charger.c:	mod_delayed_work(chg_data->wqueue, &chg_data->wpc_work,
drivers/battery/max77693_charger.c-							msecs_to_jiffies(250));
drivers/battery/max77693_charger.c-			msecs_to_jiffies(3000));
drivers/battery/max77693_charger.c-					msecs_to_jiffies(500));
drivers/battery/max77693_charger.c-				msecs_to_jiffies(RECOVERY_DELAY));
drivers/battery/max77693_charger.c-				msecs_to_jiffies(RECOVERY_DELAY));
drivers/battery/max77693_charger.c-	/* mutex */
drivers/battery/max77693_charger.c-						POWER_SUPPLY_PROP_ONLINE, cable_type);
drivers/battery/max77693_charger.c-			pr_debug("%s: wpc uvlo, but charging\n",	__func__);
drivers/battery/max77693_charger.c:	queue_delayed_work(charger->wqueue, &charger->chgin_init_work,
drivers/battery/max77693_charger.c:					queue_delayed_work(charger->wqueue, &charger->wpc_work,
drivers/battery/max77693_charger.c:			queue_delayed_work(chg_data->wqueue, &chg_data->recovery_work,
drivers/battery/max77693_charger.c:			queue_delayed_work(chg_data->wqueue, &chg_data->wpc_work,
drivers/battery/max77693_charger.c:				/* recheck after cancel_delayed_work_sync */
drivers/battery/max77693_charger.c-			return;
drivers/battery/max77693_charger.c-	return IRQ_HANDLED;
drivers/battery/max77693_charger.c-	return IRQ_HANDLED;
drivers/battery/max77693_charger.c:		schedule_delayed_work(&charger->isr_work, 0);
drivers/battery/max77693_charger.c-		/* schedule softreg recovery wq */
drivers/battery/max77693_charger.c-			 SEC_BATTERY_OVP_UVLO_CHGINT))
drivers/battery/max77693_charger.c:	struct delayed_work	chgin_init_work;	/*  chgin init work */
drivers/battery/max77693_charger.c:	struct delayed_work	isr_work;
drivers/battery/max77693_charger.c:	struct delayed_work	recovery_work;	/*  softreg recovery work */
drivers/battery/max77693_charger.c:	struct delayed_work	wpc_work;	/*  wpc detect work */
drivers/battery/max77693_charger.c-	struct workqueue_struct *wqueue;
drivers/battery/max77693_charger.c-	struct work_struct	chgin_work;
drivers/battery/max77693_charger.c-					union power_supply_propval cable_type;
drivers/battery/max77693_charger.c-		wake_lock(&charger->recovery_wake_lock);
drivers/battery/max77693_charger.c-			wake_lock(&chg_data->recovery_wake_lock);
drivers/battery/max77693_charger.c-					wake_lock_timeout(&charger->wpc_wake_lock, 500);
drivers/battery/max77693_charger.c-			wake_lock_timeout(&chg_data->wpc_wake_lock, 1000);
drivers/battery/sec_battery_8930.c-
drivers/battery/sec_battery_8930.c-
drivers/battery/sec_battery_8930.c-
drivers/battery/sec_battery_8930.c-
drivers/battery/sec_battery_8930.c-
drivers/battery/sec_battery_8930.c-
drivers/battery/sec_battery_8930.c-
drivers/battery/sec_battery_8930.c-
drivers/battery/sec_battery_8930.c-
drivers/battery/sec_battery_8930.c-
drivers/battery/sec_battery_8930.c-}
drivers/battery/sec_battery_8930.c-	}
drivers/battery/sec_battery_8930.c-	}
drivers/battery/sec_battery_8930.c-	}
drivers/battery/sec_battery_8930.c-		}
drivers/battery/sec_battery_8930.c-				&battery->monitor_work, 0);
drivers/battery/sec_battery_8930.c-		&battery->monitor_work, 0);
drivers/battery/sec_battery_8930.c-			battery->pdata->monitor_initial_count--;
drivers/battery/sec_battery_8930.c-	battery->polling_in_sleep = true;
drivers/battery/sec_battery_8930.c-			battery->ps_status = false;
drivers/battery/sec_battery_8930.c-			battery->test_mode = x;
drivers/battery/sec_battery_8930.c-		break;
drivers/battery/sec_battery_8930.c-		break;
drivers/battery/sec_battery_8930.c-		break;
drivers/battery/sec_battery_8930.c-		break;
drivers/battery/sec_battery_8930.c-		break;
drivers/battery/sec_battery_8930.c:		cancel_delayed_work(&battery->polling_work);
drivers/battery/sec_battery_8930.c:		cancel_delayed_work(&battery->polling_work);
drivers/battery/sec_battery_8930.c:		cancel_delayed_work(&battery->polling_work);
drivers/battery/sec_battery_8930.c:	cancel_delayed_work_sync(&battery->monitor_work);
drivers/battery/sec_battery_8930.c-	case SEC_BATTERY_MONITOR_ALARM:
drivers/battery/sec_battery_8930.c-	case SEC_BATTERY_MONITOR_ALARM:
drivers/battery/sec_battery_8930.c-	case SEC_BATTERY_MONITOR_WORKQUEUE:
drivers/battery/sec_battery_8930.c-	case SEC_BATTERY_MONITOR_WORKQUEUE:
drivers/battery/sec_battery_8930.c-	dev_dbg(battery->dev,
drivers/battery/sec_battery_8930.c-		dev_dbg(battery->dev, "%s: Activated\n", __func__);
drivers/battery/sec_battery_8930.c-	dev_dbg(battery->dev, "%s: Activated\n", __func__);
drivers/battery/sec_battery_8930.c-	dev_dbg(battery->dev, "%s: End\n", __func__);
drivers/battery/sec_battery_8930.c-		} else
drivers/battery/sec_battery_8930.c-		} else {
drivers/battery/sec_battery_8930.c-end_of_cable_work:
drivers/battery/sec_battery_8930.c-		if (battery->pdata->monitor_initial_count) {
drivers/battery/sec_battery_8930.c-	if (battery->pdata->polling_type ==
drivers/battery/sec_battery_8930.c-	if (!battery->polling_in_sleep) {
drivers/battery/sec_battery_8930.c-					msecs_to_jiffies(500));
drivers/battery/sec_battery_8930.c-				polling_time_temp * HZ);
drivers/battery/sec_battery_8930.c:	queue_delayed_work(battery->monitor_wqueue,
drivers/battery/sec_battery_8930.c:			queue_delayed_work(battery->monitor_wqueue,
drivers/battery/sec_battery_8930.c:	queue_delayed_work(battery->monitor_wqueue, &battery->monitor_work,
drivers/battery/sec_battery_8930.c:			queue_delayed_work(battery->monitor_wqueue, &battery->monitor_work, 0);
drivers/battery/sec_battery_8930.c:			queue_delayed_work(battery->monitor_wqueue, &battery->monitor_work, 0);
drivers/battery/sec_battery_8930.c:		queue_delayed_work(battery->monitor_wqueue, &battery->monitor_work, 0);
drivers/battery/sec_battery_8930.c:		queue_delayed_work(battery->monitor_wqueue, &battery->monitor_work, 0);
drivers/battery/sec_battery_8930.c:	queue_delayed_work(battery->monitor_wqueue, &battery->monitor_work, 0);
drivers/battery/sec_battery_8930.c:	queue_delayed_work(battery->monitor_wqueue, &battery->monitor_work, 0);
drivers/battery/sec_battery_8930.c-			ret = count;
drivers/battery/sec_battery_8930.c:			schedule_delayed_work(&battery->polling_work,
drivers/battery/sec_battery_8930.c:			schedule_delayed_work(&battery->polling_work, HZ);
drivers/battery/sec_battery_8930.c-		SEC_BATTERY_MONITOR_WORKQUEUE)
drivers/battery/sec_battery_8930.c-				"%s: power sharing cable plugin (%d)\n", __func__, battery->ps_status);
drivers/battery/sec_battery_8930.c-				"%s: power sharing cable plugout (%d)\n", __func__, battery->ps_status);
drivers/battery/sec_battery_8930.c-	switch (battery->pdata->polling_type) {
drivers/battery/sec_battery_8930.c-	switch (battery->pdata->polling_type) {
drivers/battery/sec_battery_8930.c-	wake_lock(&battery->monitor_wake_lock);
drivers/battery/sec_battery_8930.c-	wake_lock(&battery->monitor_wake_lock);
drivers/battery/sec_battery_8930.c-	wake_lock(&battery->monitor_wake_lock);
drivers/battery/sec_battery_8930.c-	wake_lock(&battery->monitor_wake_lock);
drivers/battery/sec_battery_8930.c-		wake_lock(&battery->monitor_wake_lock);
drivers/battery/sec_battery_8930.c-		wake_lock(&battery->monitor_wake_lock);
drivers/battery/sec_battery_8930.c-			wake_lock(&battery->monitor_wake_lock);
drivers/battery/sec_battery_8930.c-			wake_lock(&battery->monitor_wake_lock);
drivers/battery/sec_battery_8930.c-			wake_lock(&battery->monitor_wake_lock);
drivers/battery/sec_battery.c-
drivers/battery/sec_battery.c-			battery->pdata->monitor_initial_count--;
drivers/battery/sec_battery.c-		break;
drivers/battery/sec_battery.c-		break;
drivers/battery/sec_battery.c-		break;
drivers/battery/sec_battery.c-		break;
drivers/battery/sec_battery.c:		cancel_delayed_work(&battery->polling_work);
drivers/battery/sec_battery.c:		cancel_delayed_work(&battery->polling_work);
drivers/battery/sec_battery.c:		cancel_delayed_work(&battery->polling_work);
drivers/battery/sec_battery.c:		cancel_delayed_work(&battery->polling_work);
drivers/battery/sec_battery.c-	case SEC_BATTERY_MONITOR_ALARM:
drivers/battery/sec_battery.c-	case SEC_BATTERY_MONITOR_ALARM:
drivers/battery/sec_battery.c-	case SEC_BATTERY_MONITOR_ALARM:
drivers/battery/sec_battery.c-	case SEC_BATTERY_MONITOR_WORKQUEUE:
drivers/battery/sec_battery.c-	case SEC_BATTERY_MONITOR_WORKQUEUE:
drivers/battery/sec_battery.c-	case SEC_BATTERY_MONITOR_WORKQUEUE:
drivers/battery/sec_battery.c-		} else
drivers/battery/sec_battery.c-		if (battery->pdata->monitor_initial_count) {
drivers/battery/sec_battery.c-	if (battery->pdata->polling_type ==
drivers/battery/sec_battery.c-				polling_time_temp * HZ);
drivers/battery/sec_battery.c-	return 0;
drivers/battery/sec_battery.c:			schedule_delayed_work(&battery->polling_work,
drivers/battery/sec_battery.c:			schedule_delayed_work(&battery->polling_work, HZ);
drivers/battery/sec_battery.c-		SEC_BATTERY_MONITOR_WORKQUEUE)
drivers/battery/sec_battery.c-	switch (battery->pdata->polling_type) {
drivers/battery/sec_battery.c-	switch (battery->pdata->polling_type) {
drivers/battery/sec_battery.c-	switch (battery->pdata->polling_type) {
drivers/battery/sec_charger_8930.c-
drivers/battery/sec_charger_8930.c-
drivers/battery/sec_charger_8930.c-	return IRQ_HANDLED;
drivers/battery/sec_charger_8930.c:	schedule_delayed_work(&charger->isr_work, 0);
drivers/battery/sec_charger_8930.c-	struct sec_charger_info *charger = irq_data;
drivers/battery/sec_charger.c-
drivers/battery/sec_charger.c-
drivers/battery/sec_charger.c-	return IRQ_HANDLED;
drivers/battery/sec_charger.c:	schedule_delayed_work(&charger->isr_work, 0);
drivers/battery/sec_charger.c-	struct sec_charger_info *charger = irq_data;
drivers/battery/sec_fuelgauge_8930.c-
drivers/battery/sec_fuelgauge_8930.c-
drivers/battery/sec_fuelgauge_8930.c-		fuelgauge->is_fuel_alerted = fuel_alerted;
drivers/battery/sec_fuelgauge_8930.c:		schedule_delayed_work(&fuelgauge->isr_work, 0);
drivers/battery/sec_fuelgauge_8930.c-			wake_unlock(&fuelgauge->fuel_alert_wake_lock);
drivers/battery/sec_fuelgauge.c-
drivers/battery/sec_fuelgauge.c-
drivers/battery/sec_fuelgauge.c-		fuelgauge->is_fuel_alerted = fuel_alerted;
drivers/battery/sec_fuelgauge.c:		schedule_delayed_work(&fuelgauge->isr_work, 0);
drivers/battery/sec_fuelgauge.c-			wake_unlock(&fuelgauge->fuel_alert_wake_lock);
drivers/block/paride/pd.c-
drivers/block/paride/pd.c-{
drivers/block/paride/pd.c-}
drivers/block/paride/pd.c-	else
drivers/block/paride/pd.c-	if (!nice)
drivers/block/paride/pd.c:		schedule_delayed_work(&fsm_tq, 0);
drivers/block/paride/pd.c:		schedule_delayed_work(&fsm_tq, nice-1);
drivers/block/paride/pseudo.h-}
drivers/block/paride/pseudo.h-	}
drivers/block/paride/pseudo.h-	else
drivers/block/paride/pseudo.h-		else
drivers/block/paride/pseudo.h-		if (!ps_nice)
drivers/block/paride/pseudo.h-	if (!ps_nice)
drivers/block/paride/pseudo.h-		ps_tq_active = 1;
drivers/block/paride/pseudo.h-	ps_tq_active = 1;
drivers/block/paride/pseudo.h:			schedule_delayed_work(&ps_tq, 0);
drivers/block/paride/pseudo.h:		schedule_delayed_work(&ps_tq, 0);
drivers/block/paride/pseudo.h:			schedule_delayed_work(&ps_tq, ps_nice-1);
drivers/block/paride/pseudo.h:		schedule_delayed_work(&ps_tq, ps_nice-1);
drivers/block/paride/pseudo.h-	spin_unlock_irqrestore(&ps_spinlock,flags);
drivers/block/paride/pseudo.h-	spin_unlock_irqrestore(&ps_spinlock,flags);
drivers/bluetooth/bluesleep_bcm.c-
drivers/bluetooth/bluesleep_bcm.c-
drivers/bluetooth/bluesleep_bcm.c-/* 10 second timeout */
drivers/bluetooth/bluesleep_bcm.c:#define bluesleep_rx_busy()     schedule_delayed_work(&sleep_workqueue, 0)
drivers/bluetooth/bluesleep_bcm.c:#define bluesleep_rx_idle()     schedule_delayed_work(&sleep_workqueue, 0)
drivers/bluetooth/bluesleep_bcm.c:#define bluesleep_tx_busy()     schedule_delayed_work(&sleep_workqueue, 0)
drivers/bluetooth/bluesleep_bcm.c:#define bluesleep_tx_idle()     schedule_delayed_work(&sleep_workqueue, 0)
drivers/bluetooth/bluesleep_bcm.c-/* Macros for handling sleep work */
drivers/bluetooth/bluesleep.c-
drivers/bluetooth/bluesleep.c-
drivers/bluetooth/bluesleep.c-
drivers/bluetooth/bluesleep.c-/* 3 second timeout */
drivers/bluetooth/bluesleep.c:#define bluesleep_rx_busy()     schedule_delayed_work(&sleep_workqueue, 0)
drivers/bluetooth/bluesleep.c:#define bluesleep_rx_idle()     schedule_delayed_work(&sleep_workqueue, 0)
drivers/bluetooth/bluesleep.c:#define bluesleep_tx_busy()     schedule_delayed_work(&sleep_workqueue, 0)
drivers/bluetooth/bluesleep.c:#define bluesleep_tx_idle()     schedule_delayed_work(&sleep_workqueue, 0)
drivers/bluetooth/bluesleep.c:#define bluesleep_tx_timer_expired()     schedule_delayed_work(&tx_timer_expired_workqueue, 0)
drivers/bluetooth/bluesleep.c-/* Macros for handling sleep work */
drivers/char/hw_random/n2-drv.c-
drivers/char/hw_random/n2-drv.c-
drivers/char/hw_random/n2-drv.c-
drivers/char/hw_random/n2-drv.c-
drivers/char/hw_random/n2-drv.c-
drivers/char/hw_random/n2-drv.c-
drivers/char/hw_random/n2-drv.c-}
drivers/char/hw_random/n2-drv.c-		}
drivers/char/hw_random/n2-drv.c:	cancel_delayed_work_sync(&np->work);
drivers/char/hw_random/n2-drv.c-	dev_set_drvdata(&op->dev, np);
drivers/char/hw_random/n2-drv.c-	hwrng_unregister(&np->hwrng);
drivers/char/hw_random/n2-drv.c-	if (err && !(np->flags & N2RNG_FLAG_SHUTDOWN))
drivers/char/hw_random/n2-drv.c-			if (!(np->flags & N2RNG_FLAG_SHUTDOWN))
drivers/char/hw_random/n2-drv.c-			len = 0;
drivers/char/hw_random/n2-drv.c-			np->flags &= ~N2RNG_FLAG_READY;
drivers/char/hw_random/n2-drv.c-	np->flags |= N2RNG_FLAG_SHUTDOWN;
drivers/char/hw_random/n2-drv.c-	return 0;
drivers/char/hw_random/n2-drv.c:				schedule_delayed_work(&np->work, 0);
drivers/char/hw_random/n2-drv.c:	schedule_delayed_work(&np->work, 0);
drivers/char/hw_random/n2-drv.c:		schedule_delayed_work(&np->work, HZ * 2);
drivers/char/msm_rotator.c-
drivers/char/msm_rotator.c-}
drivers/char/msm_rotator.c-	}
drivers/char/msm_rotator.c:		cancel_delayed_work(&msm_rotator_dev->imem_clk_work);
drivers/char/msm_rotator.c:	cancel_delayed_work(&msm_rotator_dev->rot_clk_work);
drivers/char/msm_rotator.c-	commit_info->acq_fen = NULL;
drivers/char/msm_rotator.c-#else
drivers/char/msm_rotator.c-		enable_rot_clks();
drivers/char/msm_rotator.c-#endif
drivers/char/msm_rotator.c-#endif
drivers/char/msm_rotator.c-#endif
drivers/char/msm_rotator.c-#ifdef CONFIG_MSM_ROTATOR_USE_IMEM
drivers/char/msm_rotator.c-		if (msm_rotator_dev->imem_clk_state != CLK_EN
drivers/char/msm_rotator.c-	if (msm_rotator_dev->imem_owner == requestor) {
drivers/char/msm_rotator.c-	if (msm_rotator_dev->rot_clk_state != CLK_EN) {
drivers/char/msm_rotator.c-	if (rc == 1) {
drivers/char/msm_rotator.c-	if (requestor == JPEG_REQUEST)
drivers/char/msm_rotator.c-		img_info->secure);
drivers/char/msm_rotator.c-	int imem_clk_state;
drivers/char/msm_rotator.c-	int rot_clk_state;
drivers/char/msm_rotator.c:		mod_delayed_work(system_wq, &msm_rotator_dev->imem_clk_work, msecs_to_jiffies(100));
drivers/char/msm_rotator.c:		mod_delayed_work(system_wq, &msm_rotator_dev->imem_clk_work, msecs_to_jiffies(100));
drivers/char/msm_rotator.c:	mod_delayed_work(system_wq, &msm_rotator_dev->rot_clk_work, msecs_to_jiffies(100));
drivers/char/msm_rotator.c-			&& msm_rotator_dev->imem_clk) {
drivers/char/msm_rotator.c-	msm_rotator_imem_free(ROTATOR_REQUEST);
drivers/char/msm_rotator.c-		mutex_unlock(&msm_rotator_dev->imem_lock);
drivers/char/msm_rotator.c-	put_img(dstp1_file, dstp1_ihdl, ROTATOR_DST_DOMAIN,
drivers/char/msm_rotator.c-	struct cdev cdev;
drivers/char/msm_rotator.c-	struct clk *imem_clk;
drivers/char/msm_rotator.c:	struct delayed_work imem_clk_work;
drivers/char/msm_rotator.c:	struct delayed_work rot_clk_work;
drivers/char/msm_rotator.c-	struct platform_device *pdev;
drivers/char/msm_rotator.c-	struct regulator *regulator;
drivers/cpufreq/cpu-boost.c-
drivers/cpufreq/cpu-boost.c-
drivers/cpufreq/cpu-boost.c-
drivers/cpufreq/cpu-boost.c-
drivers/cpufreq/cpu-boost.c-
drivers/cpufreq/cpu-boost.c-
drivers/cpufreq/cpu-boost.c-}
drivers/cpufreq/cpu-boost.c-}
drivers/cpufreq/cpu-boost.c-	}
drivers/cpufreq/cpu-boost.c-first_time:
drivers/cpufreq/cpu-boost.c-	last_input_time = ktime_to_us(ktime_get());
drivers/cpufreq/cpu-boost.c:	mod_delayed_work_on(0, cpu_boost_wq, &input_boost_rem,
drivers/cpufreq/cpu-boost.c:	mod_delayed_work_on(0, cpu_boost_wq, &input_boost_work, 0);
drivers/cpufreq/cpu-boost.c-module_param(input_boost_ms, uint, 0644);
drivers/cpufreq/cpu-boost.c-					msecs_to_jiffies(input_boost_ms));
drivers/cpufreq/cpu-boost.c-static bool input_boost_enabled = false;
drivers/cpufreq/cpu-boost.c:static struct delayed_work input_boost_rem;
drivers/cpufreq/cpu-boost.c:static struct delayed_work input_boost_rem;
drivers/cpufreq/cpu-boost.c:static struct delayed_work input_boost_work;
drivers/cpufreq/cpu-boost.c-static struct workqueue_struct *cpu_boost_wq;
drivers/cpufreq/cpu-boost.c-static u64 last_input_time;
drivers/cpufreq/cpufreq_abyssplugv2.c-
drivers/cpufreq/cpufreq_abyssplugv2.c-
drivers/cpufreq/cpufreq_abyssplugv2.c-{
drivers/cpufreq/cpufreq_abyssplugv2.c-}
drivers/cpufreq/cpufreq_abyssplugv2.c-}
drivers/cpufreq/cpufreq_abyssplugv2.c-}
drivers/cpufreq/cpufreq_abyssplugv2.c-	}
drivers/cpufreq/cpufreq_abyssplugv2.c-	bds_info->sample_type = BDS_NORMAL_SAMPLE;
drivers/cpufreq/cpufreq_abyssplugv2.c:	cancel_delayed_work_sync(&bds_info->work);
drivers/cpufreq/cpufreq_abyssplugv2.c-		delay = bds_info->freq_lo_jiffies;
drivers/cpufreq/cpufreq_abyssplugv2.c-	INIT_DEFERRABLE_WORK(&bds_info->work, do_bds_timer);
drivers/cpufreq/cpufreq_abyssplugv2.c-	mutex_unlock(&bds_info->timer_mutex);
drivers/cpufreq/cpufreq_abyssplugv2.c:	schedule_delayed_work_on(bds_info->cpu, &bds_info->work, delay);
drivers/cpufreq/cpufreq_abyssplugv2.c:	schedule_delayed_work_on(cpu, &bds_info->work, delay);
drivers/cpufreq/cpufreq_abyssplugv2.c-static inline void bds_timer_exit(struct cpu_bds_info_s *bds_info)
drivers/cpufreq/cpufreq_abyssplugv2.c-	struct cpufreq_frequency_table *freq_table;
drivers/cpufreq/cpufreq_abyssplugv2.c-	struct cpufreq_policy *cur_policy;
drivers/cpufreq/cpufreq_abyssplugv2.c:	struct delayed_work work;
drivers/cpufreq/cpufreq_abyssplugv2.c-	u64 prev_cpu_nice;
drivers/cpufreq/cpufreq_abyssplugv2.c-	unsigned int freq_lo;
drivers/cpufreq/cpufreq_adaptive.c-
drivers/cpufreq/cpufreq_adaptive.c-
drivers/cpufreq/cpufreq_adaptive.c-
drivers/cpufreq/cpufreq_adaptive.c-
drivers/cpufreq/cpufreq_adaptive.c-
drivers/cpufreq/cpufreq_adaptive.c-
drivers/cpufreq/cpufreq_adaptive.c-
drivers/cpufreq/cpufreq_adaptive.c-
drivers/cpufreq/cpufreq_adaptive.c-{
drivers/cpufreq/cpufreq_adaptive.c-}
drivers/cpufreq/cpufreq_adaptive.c-}
drivers/cpufreq/cpufreq_adaptive.c-	}
drivers/cpufreq/cpufreq_adaptive.c-		}
drivers/cpufreq/cpufreq_adaptive.c:			cancel_delayed_work(&dbs_info->work);
drivers/cpufreq/cpufreq_adaptive.c:	cancel_delayed_work_sync(&dbs_info->work);
drivers/cpufreq/cpufreq_adaptive.c-		cpufreq_adaptive_update_time();
drivers/cpufreq/cpufreq_adaptive.c-			cpufreq_adaptive_update_time();
drivers/cpufreq/cpufreq_adaptive.c-	cputime64_t prev_cpu_nice;
drivers/cpufreq/cpufreq_adaptive.c-	dbs_info->sample_type = DBS_NORMAL_SAMPLE;
drivers/cpufreq/cpufreq_adaptive.c-	delay = usecs_to_jiffies(dbs_tuners_ins.sampling_rate);
drivers/cpufreq/cpufreq_adaptive.c-	} else {
drivers/cpufreq/cpufreq_adaptive.c-	if (mutex_is_locked(&short_timer_mutex))
drivers/cpufreq/cpufreq_adaptive.c-	INIT_DEFERRABLE_WORK(&dbs_info->work, do_dbs_timer);
drivers/cpufreq/cpufreq_adaptive.c-			mod_timer(&cpu_timer, jiffies + 2);
drivers/cpufreq/cpufreq_adaptive.c-	mod_timer(&cpu_timer, jiffies + 2);
drivers/cpufreq/cpufreq_adaptive.c-		mutex_lock(&this_dbs_info->timer_mutex);
drivers/cpufreq/cpufreq_adaptive.c-			mutex_lock(&this_dbs_info->timer_mutex);
drivers/cpufreq/cpufreq_adaptive.c-	mutex_unlock(&dbs_info->timer_mutex);
drivers/cpufreq/cpufreq_adaptive.c-		mutex_unlock(&this_dbs_info->timer_mutex);
drivers/cpufreq/cpufreq_adaptive.c-			mutex_unlock(&this_dbs_info->timer_mutex);
drivers/cpufreq/cpufreq_adaptive.c:	schedule_delayed_work_on(0, &this_dbs_info->work, 10);
drivers/cpufreq/cpufreq_adaptive.c:			schedule_delayed_work_on(0, &this_dbs_info->work, delay);
drivers/cpufreq/cpufreq_adaptive.c:		schedule_delayed_work_on(0, &this_dbs_info->work, delay);
drivers/cpufreq/cpufreq_adaptive.c:		schedule_delayed_work_on(cpu, &dbs_info->work, delay);
drivers/cpufreq/cpufreq_adaptive.c:	schedule_delayed_work_on(dbs_info->cpu, &dbs_info->work, delay);
drivers/cpufreq/cpufreq_adaptive.c-static inline void dbs_timer_exit(struct cpu_dbs_info_s *dbs_info)
drivers/cpufreq/cpufreq_adaptive.c-	struct cpufreq_frequency_table *freq_table;
drivers/cpufreq/cpufreq_adaptive.c-	struct cpufreq_policy *cur_policy;
drivers/cpufreq/cpufreq_adaptive.c:	struct delayed_work work;
drivers/cpufreq/cpufreq_adaptive.c-	unsigned int freq_hi_jiffies;
drivers/cpufreq/cpufreq_alucard.c-
drivers/cpufreq/cpufreq_alucard.c-
drivers/cpufreq/cpufreq_alucard.c-
drivers/cpufreq/cpufreq_alucard.c-
drivers/cpufreq/cpufreq_alucard.c-
drivers/cpufreq/cpufreq_alucard.c-
drivers/cpufreq/cpufreq_alucard.c-		break;
drivers/cpufreq/cpufreq_alucard.c:		cancel_delayed_work_sync(&this_alucard_cpuinfo->work);
drivers/cpufreq/cpufreq_alucard.c-	case CPUFREQ_GOV_STOP:
drivers/cpufreq/cpufreq_alucard.c-		delay = usecs_to_jiffies(MIN_SAMPLING_RATE);
drivers/cpufreq/cpufreq_alucard.c-		INIT_DEFERRABLE_WORK(&this_alucard_cpuinfo->work, do_alucard_timer);
drivers/cpufreq/cpufreq_alucard.c:	mod_delayed_work_on(cpu, system_wq, &alucard_cpuinfo->work, delay);
drivers/cpufreq/cpufreq_alucard.c:		mod_delayed_work_on(this_alucard_cpuinfo->cpu, system_wq, &this_alucard_cpuinfo->work, delay);
drivers/cpufreq/cpufreq_alucard.c-		mutex_lock(&alucard_mutex);
drivers/cpufreq/cpufreq_alucard.c-	mutex_unlock(&alucard_cpuinfo->timer_mutex);
drivers/cpufreq/cpufreq_alucard.c-	struct cpufreq_frequency_table *freq_table;
drivers/cpufreq/cpufreq_alucard.c-	struct cpufreq_policy *cur_policy;
drivers/cpufreq/cpufreq_alucard.c:	struct delayed_work work;
drivers/cpufreq/cpufreq_alucard.c-	u64 prev_cpu_idle;
drivers/cpufreq/cpufreq_alucard.c-	unsigned int cpu;
drivers/cpufreq/cpufreq_bioshock.c-
drivers/cpufreq/cpufreq_bioshock.c-
drivers/cpufreq/cpufreq_bioshock.c-
drivers/cpufreq/cpufreq_bioshock.c-{
drivers/cpufreq/cpufreq_bioshock.c-}
drivers/cpufreq/cpufreq_bioshock.c-}
drivers/cpufreq/cpufreq_bioshock.c-}
drivers/cpufreq/cpufreq_bioshock.c:	cancel_delayed_work_sync(&dbs_info->work);
drivers/cpufreq/cpufreq_bioshock.c-	dbs_check_cpu(dbs_info);
drivers/cpufreq/cpufreq_bioshock.c-	dbs_info->enable = 0;
drivers/cpufreq/cpufreq_bioshock.c-	dbs_info->enable = 1;
drivers/cpufreq/cpufreq_bioshock.c-	INIT_DEFERRABLE_WORK(&dbs_info->work, do_dbs_timer);
drivers/cpufreq/cpufreq_bioshock.c-	mutex_unlock(&dbs_info->timer_mutex);
drivers/cpufreq/cpufreq_bioshock.c:	schedule_delayed_work_on(cpu, &dbs_info->work, delay);
drivers/cpufreq/cpufreq_bioshock.c:	schedule_delayed_work_on(dbs_info->cpu, &dbs_info->work, delay);
drivers/cpufreq/cpufreq_bioshock.c-	struct cpufreq_policy *cur_policy;
drivers/cpufreq/cpufreq_bioshock.c:	struct delayed_work work;
drivers/cpufreq/cpufreq_bioshock.c-	u64 prev_cpu_nice;
drivers/cpufreq/cpufreq_bioshock.c-	unsigned int down_skip;
drivers/cpufreq/cpufreq_bioshock.c-	unsigned int requested_freq;
drivers/cpufreq/cpufreq.c-
drivers/cpufreq/cpufreq.c-
drivers/cpufreq/cpufreq.c-
drivers/cpufreq/cpufreq.c-
drivers/cpufreq/cpufreq.c-
drivers/cpufreq/cpufreq.c-}
drivers/cpufreq/cpufreq.c-}
drivers/cpufreq/cpufreq.c-	}
drivers/cpufreq/cpufreq.c-first_time:
drivers/cpufreq/cpufreq.c-	last_input_time = ktime_to_us(ktime_get());
drivers/cpufreq/cpufreq.c:	mod_delayed_work_on(0, cpu_boost_wq, &input_boost_rem,
drivers/cpufreq/cpufreq.c:	mod_delayed_work_on(0, cpu_boost_wq, &input_boost_work, 0);
drivers/cpufreq/cpufreq.c-module_param(input_boost_ms, uint, 0644);
drivers/cpufreq/cpufreq.c-					msecs_to_jiffies(input_boost_ms));
drivers/cpufreq/cpufreq.c-static bool input_boost_enabled = false;
drivers/cpufreq/cpufreq.c:static struct delayed_work input_boost_rem;
drivers/cpufreq/cpufreq.c:static struct delayed_work input_boost_rem;
drivers/cpufreq/cpufreq.c:static struct delayed_work input_boost_work;
drivers/cpufreq/cpufreq.c-static struct workqueue_struct *cpu_boost_wq;
drivers/cpufreq/cpufreq.c-static u64 last_input_time;
drivers/cpufreq/cpufreq.c-unsigned int limited_max_freq_thermal[NR_CPUS] = { DEFAULT_HARD_MAX, DEFAULT_HARD_MAX, DEFAULT_HARD_MAX, DEFAULT_HARD_MAX };
drivers/cpufreq/cpufreq_dancedance.c-
drivers/cpufreq/cpufreq_dancedance.c-
drivers/cpufreq/cpufreq_dancedance.c-
drivers/cpufreq/cpufreq_dancedance.c-{
drivers/cpufreq/cpufreq_dancedance.c-}
drivers/cpufreq/cpufreq_dancedance.c-}
drivers/cpufreq/cpufreq_dancedance.c-}
drivers/cpufreq/cpufreq_dancedance.c-    }
drivers/cpufreq/cpufreq_dancedance.c:	cancel_delayed_work_sync(&dbs_info->work);
drivers/cpufreq/cpufreq_dancedance.c-    cputime64_t prev_cpu_nice;
drivers/cpufreq/cpufreq_dancedance.c-	dbs_info->enable = 0;
drivers/cpufreq/cpufreq_dancedance.c-	dbs_info->enable = 1;
drivers/cpufreq/cpufreq_dancedance.c-	INIT_DEFERRABLE_WORK(&dbs_info->work, do_dbs_timer);
drivers/cpufreq/cpufreq_dancedance.c-    mutex_unlock(&dbs_info->timer_mutex);
drivers/cpufreq/cpufreq_dancedance.c:    schedule_delayed_work_on(cpu, &dbs_info->work, delay);
drivers/cpufreq/cpufreq_dancedance.c:	schedule_delayed_work_on(dbs_info->cpu, &dbs_info->work, delay);
drivers/cpufreq/cpufreq_dancedance.c-    struct cpufreq_frequency_table *freq_table;
drivers/cpufreq/cpufreq_dancedance.c-    struct cpufreq_policy *cur_policy;
drivers/cpufreq/cpufreq_dancedance.c:    struct delayed_work work;
drivers/cpufreq/cpufreq_dancedance.c-	unsigned int down_skip;
drivers/cpufreq/cpufreq_darkness.c-
drivers/cpufreq/cpufreq_darkness.c-
drivers/cpufreq/cpufreq_darkness.c-
drivers/cpufreq/cpufreq_darkness.c-
drivers/cpufreq/cpufreq_darkness.c-
drivers/cpufreq/cpufreq_darkness.c-
drivers/cpufreq/cpufreq_darkness.c-		break;
drivers/cpufreq/cpufreq_darkness.c:		cancel_delayed_work_sync(&this_darkness_cpuinfo->work);
drivers/cpufreq/cpufreq_darkness.c-	case CPUFREQ_GOV_STOP:
drivers/cpufreq/cpufreq_darkness.c-		delay = usecs_to_jiffies(MIN_SAMPLING_RATE);
drivers/cpufreq/cpufreq_darkness.c-		INIT_DEFERRABLE_WORK(&this_darkness_cpuinfo->work, do_darkness_timer);
drivers/cpufreq/cpufreq_darkness.c-	int cpu;
drivers/cpufreq/cpufreq_darkness.c:	mod_delayed_work_on(cpu, system_wq, &darkness_cpuinfo->work, delay);
drivers/cpufreq/cpufreq_darkness.c:		mod_delayed_work_on(this_darkness_cpuinfo->cpu, system_wq, &this_darkness_cpuinfo->work, delay);
drivers/cpufreq/cpufreq_darkness.c-		mutex_lock(&darkness_mutex);
drivers/cpufreq/cpufreq_darkness.c-	mutex_unlock(&darkness_cpuinfo->timer_mutex);
drivers/cpufreq/cpufreq_darkness.c-	struct cpufreq_frequency_table *freq_table;
drivers/cpufreq/cpufreq_darkness.c-	struct cpufreq_policy *cur_policy;
drivers/cpufreq/cpufreq_darkness.c:	struct delayed_work work;
drivers/cpufreq/cpufreq_darkness.c-	u64 prev_cpu_idle;
drivers/cpufreq/cpufreq_electroactive.c-
drivers/cpufreq/cpufreq_electroactive.c-
drivers/cpufreq/cpufreq_electroactive.c-
drivers/cpufreq/cpufreq_electroactive.c-
drivers/cpufreq/cpufreq_electroactive.c-
drivers/cpufreq/cpufreq_electroactive.c-
drivers/cpufreq/cpufreq_electroactive.c-
drivers/cpufreq/cpufreq_electroactive.c-{
drivers/cpufreq/cpufreq_electroactive.c-}
drivers/cpufreq/cpufreq_electroactive.c-}
drivers/cpufreq/cpufreq_electroactive.c-}
drivers/cpufreq/cpufreq_electroactive.c:			cancel_delayed_work(&dbs_info->work);
drivers/cpufreq/cpufreq_electroactive.c:	cancel_delayed_work_sync(&dbs_info->work);
drivers/cpufreq/cpufreq_electroactive.c-			continue;
drivers/cpufreq/cpufreq_electroactive.c-	dbs_info->sample_type = DBS_NORMAL_SAMPLE;
drivers/cpufreq/cpufreq_electroactive.c:		if (!delayed_work_pending(&dbs_info->work)) {
drivers/cpufreq/cpufreq_electroactive.c-	INIT_DEFERRABLE_WORK(&dbs_info->work, do_dbs_timer);
drivers/cpufreq/cpufreq_electroactive.c-		mutex_lock(&dbs_info->timer_mutex);
drivers/cpufreq/cpufreq_electroactive.c-			mutex_lock(&dbs_info->timer_mutex);
drivers/cpufreq/cpufreq_electroactive.c-	mutex_unlock(&dbs_info->timer_mutex);
drivers/cpufreq/cpufreq_electroactive.c-			mutex_unlock(&dbs_info->timer_mutex);
drivers/cpufreq/cpufreq_electroactive.c-			mutex_unlock(&dbs_info->timer_mutex);
drivers/cpufreq/cpufreq_electroactive.c:	schedule_delayed_work_on(cpu, &dbs_info->work, delay);
drivers/cpufreq/cpufreq_electroactive.c:			schedule_delayed_work_on(dbs_info->cpu, &dbs_info->work,
drivers/cpufreq/cpufreq_electroactive.c:	schedule_delayed_work_on(dbs_info->cpu, &dbs_info->work, delay);
drivers/cpufreq/cpufreq_electroactive.c-sched_wait:
drivers/cpufreq/cpufreq_electroactive.c-static inline void dbs_timer_exit(struct cpu_dbs_info_s *dbs_info)
drivers/cpufreq/cpufreq_electroactive.c-	struct cpufreq_frequency_table *freq_table;
drivers/cpufreq/cpufreq_electroactive.c-	struct cpufreq_policy *cur_policy;
drivers/cpufreq/cpufreq_electroactive.c:	struct delayed_work work;
drivers/cpufreq/cpufreq_electroactive.c-	u64 prev_cpu_nice;
drivers/cpufreq/cpufreq_electroactive.c-	unsigned int freq_lo;
drivers/cpufreq/cpufreq_electroactive.c-						 usecs_to_jiffies(new_rate));
drivers/cpufreq/cpufreq_electrodemand.c-
drivers/cpufreq/cpufreq_electrodemand.c-
drivers/cpufreq/cpufreq_electrodemand.c-
drivers/cpufreq/cpufreq_electrodemand.c-
drivers/cpufreq/cpufreq_electrodemand.c-{
drivers/cpufreq/cpufreq_electrodemand.c-}
drivers/cpufreq/cpufreq_electrodemand.c-}
drivers/cpufreq/cpufreq_electrodemand.c-}
drivers/cpufreq/cpufreq_electrodemand.c-	}
drivers/cpufreq/cpufreq_electrodemand.c-		}
drivers/cpufreq/cpufreq_electrodemand.c-		 */
drivers/cpufreq/cpufreq_electrodemand.c-		 * before releasing dbs_mutex, which will trigger mutex_destroy
drivers/cpufreq/cpufreq_electrodemand.c-		 * called after checking dbs_info->activated above.
drivers/cpufreq/cpufreq_electrodemand.c:	cancel_delayed_work_sync(&dbs_info->work);
drivers/cpufreq/cpufreq_electrodemand.c:			cancel_delayed_work_sync(&dbs_info->work);
drivers/cpufreq/cpufreq_electrodemand.c:			cancel_delayed_work_sync(&dbs_info->work);
drivers/cpufreq/cpufreq_electrodemand.c-	dbs_info->activated = false;
drivers/cpufreq/cpufreq_electrodemand.c-	dbs_info->activated = true;
drivers/cpufreq/cpufreq_electrodemand.c-	dbs_info->sample_type = DBS_NORMAL_SAMPLE;
drivers/cpufreq/cpufreq_electrodemand.c:		 * dbs_timer_exit() before schedule_delayed_work_on() of this
drivers/cpufreq/cpufreq_electrodemand.c-		delay = dbs_info->freq_lo_jiffies;
drivers/cpufreq/cpufreq_electrodemand.c-		 * For the little possiblity that dbs_timer_exit() has been
drivers/cpufreq/cpufreq_electrodemand.c-		 * function, it should be revoked by calling cancel again
drivers/cpufreq/cpufreq_electrodemand.c:		 * If cancel_delayed_work_syn() has been calld by
drivers/cpufreq/cpufreq_electrodemand.c-		if (!dbs_info->activated)
drivers/cpufreq/cpufreq_electrodemand.c:		if (!delayed_work_pending(&dbs_info->work)) {
drivers/cpufreq/cpufreq_electrodemand.c-		if (time_before(next_sampling, appointed_at)) {
drivers/cpufreq/cpufreq_electrodemand.c-	INIT_DEFERRABLE_WORK(&dbs_info->work, do_dbs_timer);
drivers/cpufreq/cpufreq_electrodemand.c-		mutex_lock(&dbs_info->timer_mutex);
drivers/cpufreq/cpufreq_electrodemand.c-			mutex_lock(&dbs_info->timer_mutex);
drivers/cpufreq/cpufreq_electrodemand.c-	mutex_unlock(&dbs_info->timer_mutex);
drivers/cpufreq/cpufreq_electrodemand.c-			mutex_unlock(&dbs_info->timer_mutex);
drivers/cpufreq/cpufreq_electrodemand.c-			mutex_unlock(&dbs_info->timer_mutex);
drivers/cpufreq/cpufreq_electrodemand.c-		mutex_unlock(&dbs_mutex);
drivers/cpufreq/cpufreq_electrodemand.c-			mutex_unlock(&dbs_mutex);
drivers/cpufreq/cpufreq_electrodemand.c:	schedule_delayed_work_on(cpu, &dbs_info->work, delay);
drivers/cpufreq/cpufreq_electrodemand.c:			schedule_delayed_work_on(dbs_info->cpu, &dbs_info->work,
drivers/cpufreq/cpufreq_electrodemand.c:	schedule_delayed_work_on(dbs_info->cpu, &dbs_info->work, 10 * delay);
drivers/cpufreq/cpufreq_electrodemand.c-	struct cpufreq_frequency_table *freq_table;
drivers/cpufreq/cpufreq_electrodemand.c-	struct cpufreq_policy *cur_policy;
drivers/cpufreq/cpufreq_electrodemand.c:	struct delayed_work work;
drivers/cpufreq/cpufreq_electrodemand.c-	u64 prev_cpu_nice;
drivers/cpufreq/cpufreq_electrodemand.c-	unsigned int freq_lo;
drivers/cpufreq/cpufreq_electrodemand.c-						 usecs_to_jiffies(effective));
drivers/cpufreq/cpufreq_elementalx.c-
drivers/cpufreq/cpufreq_elementalx.c-
drivers/cpufreq/cpufreq_elementalx.c-
drivers/cpufreq/cpufreq_elementalx.c-
drivers/cpufreq/cpufreq_elementalx.c-
drivers/cpufreq/cpufreq_elementalx.c-
drivers/cpufreq/cpufreq_elementalx.c-
drivers/cpufreq/cpufreq_elementalx.c-{
drivers/cpufreq/cpufreq_elementalx.c-}
drivers/cpufreq/cpufreq_elementalx.c-}
drivers/cpufreq/cpufreq_elementalx.c-}
drivers/cpufreq/cpufreq_elementalx.c:			cancel_delayed_work(&dbs_info->work);
drivers/cpufreq/cpufreq_elementalx.c:	cancel_delayed_work_sync(&dbs_info->work);
drivers/cpufreq/cpufreq_elementalx.c-			continue;
drivers/cpufreq/cpufreq_elementalx.c-	dbs_info->sample_type = DBS_NORMAL_SAMPLE;
drivers/cpufreq/cpufreq_elementalx.c:		if (!delayed_work_pending(&dbs_info->work)) {
drivers/cpufreq/cpufreq_elementalx.c-	INIT_DEFERRABLE_WORK(&dbs_info->work, do_dbs_timer);
drivers/cpufreq/cpufreq_elementalx.c-		mutex_lock(&dbs_info->timer_mutex);
drivers/cpufreq/cpufreq_elementalx.c-			mutex_lock(&dbs_info->timer_mutex);
drivers/cpufreq/cpufreq_elementalx.c-	mutex_unlock(&dbs_info->timer_mutex);
drivers/cpufreq/cpufreq_elementalx.c-			mutex_unlock(&dbs_info->timer_mutex);
drivers/cpufreq/cpufreq_elementalx.c-			mutex_unlock(&dbs_info->timer_mutex);
drivers/cpufreq/cpufreq_elementalx.c:	schedule_delayed_work_on(cpu, &dbs_info->work, delay);
drivers/cpufreq/cpufreq_elementalx.c:			schedule_delayed_work_on(dbs_info->cpu, &dbs_info->work,
drivers/cpufreq/cpufreq_elementalx.c:	schedule_delayed_work_on(dbs_info->cpu, &dbs_info->work, delay);
drivers/cpufreq/cpufreq_elementalx.c-sched_wait:
drivers/cpufreq/cpufreq_elementalx.c-static inline void dbs_timer_exit(struct cpu_dbs_info_s *dbs_info)
drivers/cpufreq/cpufreq_elementalx.c-	struct cpufreq_frequency_table *freq_table;
drivers/cpufreq/cpufreq_elementalx.c-	struct cpufreq_policy *cur_policy;
drivers/cpufreq/cpufreq_elementalx.c:	struct delayed_work work;
drivers/cpufreq/cpufreq_elementalx.c-	u64 prev_cpu_nice;
drivers/cpufreq/cpufreq_elementalx.c-	unsigned int freq_lo;
drivers/cpufreq/cpufreq_elementalx.c-						 usecs_to_jiffies(new_rate));
drivers/cpufreq/cpufreq_lazy.c-
drivers/cpufreq/cpufreq_lazy.c-
drivers/cpufreq/cpufreq_lazy.c-{
drivers/cpufreq/cpufreq_lazy.c-}
drivers/cpufreq/cpufreq_lazy.c-}
drivers/cpufreq/cpufreq_lazy.c-}
drivers/cpufreq/cpufreq_lazy.c-    }
drivers/cpufreq/cpufreq_lazy.c:    cancel_delayed_work_sync(&dbs_info->work);
drivers/cpufreq/cpufreq_lazy.c-    cputime64_t prev_cpu_nice;
drivers/cpufreq/cpufreq_lazy.c-    dbs_info->sample_type = DBS_NORMAL_SAMPLE;
drivers/cpufreq/cpufreq_lazy.c-	    delay -= jiffies % delay;
drivers/cpufreq/cpufreq_lazy.c-    INIT_DEFERRABLE_WORK(&dbs_info->work, do_dbs_timer);
drivers/cpufreq/cpufreq_lazy.c-    mutex_unlock(&dbs_info->timer_mutex);
drivers/cpufreq/cpufreq_lazy.c:    schedule_delayed_work_on(cpu, &dbs_info->work, delay);
drivers/cpufreq/cpufreq_lazy.c:    schedule_delayed_work_on(dbs_info->cpu, &dbs_info->work, delay);
drivers/cpufreq/cpufreq_lazy.c-static inline void dbs_timer_exit(struct cpu_dbs_info_s *dbs_info)
drivers/cpufreq/cpufreq_lazy.c-    struct cpufreq_frequency_table *freq_table;
drivers/cpufreq/cpufreq_lazy.c-    struct cpufreq_policy *cur_policy;
drivers/cpufreq/cpufreq_lazy.c:    struct delayed_work work;
drivers/cpufreq/cpufreq_lazy.c-    unsigned int freq_lo;
drivers/cpufreq/cpufreq_lightning.c-
drivers/cpufreq/cpufreq_lightning.c-
drivers/cpufreq/cpufreq_lightning.c-
drivers/cpufreq/cpufreq_lightning.c-
drivers/cpufreq/cpufreq_lightning.c-
drivers/cpufreq/cpufreq_lightning.c-
drivers/cpufreq/cpufreq_lightning.c-{
drivers/cpufreq/cpufreq_lightning.c-}
drivers/cpufreq/cpufreq_lightning.c-}
drivers/cpufreq/cpufreq_lightning.c-}
drivers/cpufreq/cpufreq_lightning.c-	}
drivers/cpufreq/cpufreq_lightning.c:	cancel_delayed_work_sync(&lightning_info->work);
drivers/cpufreq/cpufreq_lightning.c:			cancel_delayed_work_sync(&lightning_info->work);
drivers/cpufreq/cpufreq_lightning.c-			continue;
drivers/cpufreq/cpufreq_lightning.c-		delay = lightning_info->freq_lo_jiffies;
drivers/cpufreq/cpufreq_lightning.c:		if (!delayed_work_pending(&lightning_info->work)) {
drivers/cpufreq/cpufreq_lightning.c-	INIT_DEFERRABLE_WORK(&lightning_info->work, do_lightning_timer);
drivers/cpufreq/cpufreq_lightning.c-	lightning_info->sample_type = lightning_NORMAL_SAMPLE;
drivers/cpufreq/cpufreq_lightning.c-		mutex_lock(&lightning_info->timer_mutex);
drivers/cpufreq/cpufreq_lightning.c-			mutex_lock(&lightning_info->timer_mutex);
drivers/cpufreq/cpufreq_lightning.c-	mutex_unlock(&lightning_info->timer_mutex);
drivers/cpufreq/cpufreq_lightning.c-			mutex_unlock(&lightning_info->timer_mutex);
drivers/cpufreq/cpufreq_lightning.c-			mutex_unlock(&lightning_info->timer_mutex);
drivers/cpufreq/cpufreq_lightning.c:	schedule_delayed_work_on(cpu, &lightning_info->work, delay);
drivers/cpufreq/cpufreq_lightning.c:			schedule_delayed_work_on(lightning_info->cpu, &lightning_info->work,
drivers/cpufreq/cpufreq_lightning.c:	schedule_delayed_work_on(lightning_info->cpu, &lightning_info->work, delay);
drivers/cpufreq/cpufreq_lightning.c-static inline void lightning_timer_exit(struct cpu_lightning_info_s *lightning_info)
drivers/cpufreq/cpufreq_lightning.c-	struct cpufreq_frequency_table *freq_table;
drivers/cpufreq/cpufreq_lightning.c-	struct cpufreq_policy *cur_policy;
drivers/cpufreq/cpufreq_lightning.c:	struct delayed_work work;
drivers/cpufreq/cpufreq_lightning.c-	u64 prev_cpu_nice;
drivers/cpufreq/cpufreq_lightning.c-	unsigned int freq_lo;
drivers/cpufreq/cpufreq_lightning.c-						 usecs_to_jiffies(new_rate));
drivers/cpufreq/cpufreq_lionfish.c-
drivers/cpufreq/cpufreq_lionfish.c-
drivers/cpufreq/cpufreq_lionfish.c-}
drivers/cpufreq/cpufreq_lionfish.c-}
drivers/cpufreq/cpufreq_lionfish.c-	}
drivers/cpufreq/cpufreq_lionfish.c:		cancel_delayed_work_sync(&cdbs->work);
drivers/cpufreq/cpufreq_lionfish.c-		cdbs = &per_cpu(lf_cpu_dbs_info, i).cdbs;
drivers/cpufreq/cpufreq_lionfish.c-	for_each_cpu(i, policy->cpus) {
drivers/cpufreq/cpufreq_lionfish.c:	mod_delayed_work_on(cpu, system_wq, &cdbs->work, delay);
drivers/cpufreq/cpufreq_lionfish.c-	struct cpu_dbs_common_info *cdbs = &per_cpu(lf_cpu_dbs_info, cpu).cdbs;
drivers/cpufreq/cpufreq_lionheart.c-
drivers/cpufreq/cpufreq_lionheart.c-
drivers/cpufreq/cpufreq_lionheart.c-
drivers/cpufreq/cpufreq_lionheart.c-{
drivers/cpufreq/cpufreq_lionheart.c-}
drivers/cpufreq/cpufreq_lionheart.c-}
drivers/cpufreq/cpufreq_lionheart.c-}
drivers/cpufreq/cpufreq_lionheart.c:	cancel_delayed_work_sync(&dbs_info->work);
drivers/cpufreq/cpufreq_lionheart.c-	dbs_check_cpu(dbs_info);
drivers/cpufreq/cpufreq_lionheart.c-	dbs_info->enable = 0;
drivers/cpufreq/cpufreq_lionheart.c-	dbs_info->enable = 1;
drivers/cpufreq/cpufreq_lionheart.c-	INIT_DEFERRABLE_WORK(&dbs_info->work, do_dbs_timer);
drivers/cpufreq/cpufreq_lionheart.c-	mutex_unlock(&dbs_info->timer_mutex);
drivers/cpufreq/cpufreq_lionheart.c:	schedule_delayed_work_on(cpu, &dbs_info->work, delay);
drivers/cpufreq/cpufreq_lionheart.c:	schedule_delayed_work_on(dbs_info->cpu, &dbs_info->work, delay);
drivers/cpufreq/cpufreq_lionheart.c-	struct cpufreq_policy *cur_policy;
drivers/cpufreq/cpufreq_lionheart.c:	struct delayed_work work;
drivers/cpufreq/cpufreq_lionheart.c-	u64 prev_cpu_nice;
drivers/cpufreq/cpufreq_lionheart.c-	unsigned int down_skip;
drivers/cpufreq/cpufreq_lionheart.c-	unsigned int requested_freq;
drivers/cpufreq/cpufreq_medusa.c-
drivers/cpufreq/cpufreq_medusa.c-
drivers/cpufreq/cpufreq_medusa.c-
drivers/cpufreq/cpufreq_medusa.c-
drivers/cpufreq/cpufreq_medusa.c-
drivers/cpufreq/cpufreq_medusa.c-{
drivers/cpufreq/cpufreq_medusa.c-}
drivers/cpufreq/cpufreq_medusa.c-}
drivers/cpufreq/cpufreq_medusa.c-	BUG_ON(!ret);
drivers/cpufreq/cpufreq_medusa.c-	BUG_ON(!ret);
drivers/cpufreq/cpufreq_medusa.c:	cancel_delayed_work_sync(&tick_work);
drivers/cpufreq/cpufreq_medusa.c:	cancel_delayed_work_sync(&update_work);
drivers/cpufreq/cpufreq_medusa.c-	mstats.tick++;
drivers/cpufreq/cpufreq_medusa.c-	mstats.total_running += running;
drivers/cpufreq/cpufreq_medusa.c-	mutex_lock(&medusa_lock);
drivers/cpufreq/cpufreq_medusa.c-	mutex_unlock(&medusa_lock);
drivers/cpufreq/cpufreq_medusa.c-	mutex_unlock(&medusa_lock);
drivers/cpufreq/cpufreq_medusa.c-	mutex_unlock(&medusa_lock);
drivers/cpufreq/cpufreq_medusa.c:	ret = schedule_delayed_work(&tick_work, usecs_to_jiffies(tick_rate_us));
drivers/cpufreq/cpufreq_medusa.c:	ret = schedule_delayed_work(&update_work, usecs_to_jiffies(update_rate_us));
drivers/cpufreq/cpufreq_medusa.c:	schedule_delayed_work(&tick_work, usecs_to_jiffies(tick_rate_us));
drivers/cpufreq/cpufreq_medusa.c:	schedule_delayed_work(&update_work, usecs_to_jiffies(update_rate_us));
drivers/cpufreq/cpufreq_medusa.c-	/* start the tick and update work items */
drivers/cpufreq/cpufreq_pegasusq.c-
drivers/cpufreq/cpufreq_pegasusq.c-
drivers/cpufreq/cpufreq_pegasusq.c-
drivers/cpufreq/cpufreq_pegasusq.c-
drivers/cpufreq/cpufreq_pegasusq.c-{
drivers/cpufreq/cpufreq_pegasusq.c-}
drivers/cpufreq/cpufreq_pegasusq.c-}
drivers/cpufreq/cpufreq_pegasusq.c-}
drivers/cpufreq/cpufreq_pegasusq.c:	cancel_delayed_work_sync(&dbs_info->work);
drivers/cpufreq/cpufreq_pegasusq.c-	cputime64_t prev_cpu_nice;
drivers/cpufreq/cpufreq_pegasusq.c-		delay -= jiffies % delay;
drivers/cpufreq/cpufreq_pegasusq.c-	INIT_DEFERRABLE_WORK(&dbs_info->work, do_dbs_timer);
drivers/cpufreq/cpufreq_pegasusq.c-	mutex_unlock(&dbs_info->timer_mutex);
drivers/cpufreq/cpufreq_pegasusq.c:	schedule_delayed_work_on(cpu, &dbs_info->work, delay);
drivers/cpufreq/cpufreq_pegasusq.c:	schedule_delayed_work_on(dbs_info->cpu, &dbs_info->work, delay);
drivers/cpufreq/cpufreq_pegasusq.c-static inline void dbs_timer_exit(struct cpu_dbs_info_s *dbs_info)
drivers/cpufreq/cpufreq_pegasusq.c-	struct cpufreq_frequency_table *freq_table;
drivers/cpufreq/cpufreq_pegasusq.c-	struct cpufreq_policy *cur_policy;
drivers/cpufreq/cpufreq_pegasusq.c:	struct delayed_work work;
drivers/cpufreq/cpufreq_pegasusq.c-	unsigned int rate_mult;
drivers/cpufreq/cpufreq_preservative.c-
drivers/cpufreq/cpufreq_preservative.c-
drivers/cpufreq/cpufreq_preservative.c-
drivers/cpufreq/cpufreq_preservative.c-{
drivers/cpufreq/cpufreq_preservative.c-}
drivers/cpufreq/cpufreq_preservative.c-}
drivers/cpufreq/cpufreq_preservative.c-}
drivers/cpufreq/cpufreq_preservative.c:	cancel_delayed_work_sync(&dbs_info->work);
drivers/cpufreq/cpufreq_preservative.c-	dbs_check_cpu(dbs_info);
drivers/cpufreq/cpufreq_preservative.c-	dbs_info->enable = 0;
drivers/cpufreq/cpufreq_preservative.c-	dbs_info->enable = 1;
drivers/cpufreq/cpufreq_preservative.c-	INIT_DEFERRABLE_WORK(&dbs_info->work, do_dbs_timer);
drivers/cpufreq/cpufreq_preservative.c:	mod_delayed_work_on(cpu, dbs_wq, &dbs_info->work, delay);
drivers/cpufreq/cpufreq_preservative.c:	mod_delayed_work_on(dbs_info->cpu, dbs_wq, &dbs_info->work, delay);
drivers/cpufreq/cpufreq_preservative.c-	mutex_unlock(&dbs_info->timer_mutex);
drivers/cpufreq/cpufreq_preservative.c-	struct cpufreq_policy *cur_policy;
drivers/cpufreq/cpufreq_preservative.c:	struct delayed_work work;
drivers/cpufreq/cpufreq_preservative.c-	u64 prev_cpu_nice;
drivers/cpufreq/cpufreq_preservative.c-	unsigned int down_skip;
drivers/cpufreq/cpufreq_preservative.c-	unsigned int requested_freq;
drivers/cpufreq/cpufreq_smartmax.c-
drivers/cpufreq/cpufreq_smartmax.c-
drivers/cpufreq/cpufreq_smartmax.c-
drivers/cpufreq/cpufreq_smartmax.c-
drivers/cpufreq/cpufreq_smartmax.c-}
drivers/cpufreq/cpufreq_smartmax.c-}
drivers/cpufreq/cpufreq_smartmax.c-}
drivers/cpufreq/cpufreq_smartmax.c:	cancel_delayed_work_sync(&this_smartmax->work);
drivers/cpufreq/cpufreq_smartmax.c-	cpufreq_smartmax_timer(this_smartmax);
drivers/cpufreq/cpufreq_smartmax.c-	cputime64_t prev_cpu_idle;
drivers/cpufreq/cpufreq_smartmax.c-	cputime64_t prev_cpu_iowait;
drivers/cpufreq/cpufreq_smartmax.c-	INIT_DEFERRABLE_WORK(&this_smartmax->work, do_dbs_timer);
drivers/cpufreq/cpufreq_smartmax.c-	mutex_unlock(&this_smartmax->timer_mutex);
drivers/cpufreq/cpufreq_smartmax.c:	schedule_delayed_work_on(cpu, &this_smartmax->work, delay);
drivers/cpufreq/cpufreq_smartmax.c:	schedule_delayed_work_on(this_smartmax->cpu, &this_smartmax->work, delay);
drivers/cpufreq/cpufreq_smartmax.c-static inline void dbs_timer_exit(struct smartmax_info_s *this_smartmax) {
drivers/cpufreq/cpufreq_smartmax.c-	struct cpufreq_frequency_table *freq_table;
drivers/cpufreq/cpufreq_smartmax.c-	struct cpufreq_policy *cur_policy;
drivers/cpufreq/cpufreq_smartmax.c:	struct delayed_work work;
drivers/cpufreq/cpufreq_smartmax_eps.c-
drivers/cpufreq/cpufreq_smartmax_eps.c-
drivers/cpufreq/cpufreq_smartmax_eps.c-
drivers/cpufreq/cpufreq_smartmax_eps.c-
drivers/cpufreq/cpufreq_smartmax_eps.c-}
drivers/cpufreq/cpufreq_smartmax_eps.c-}
drivers/cpufreq/cpufreq_smartmax_eps.c-}
drivers/cpufreq/cpufreq_smartmax_eps.c:	cancel_delayed_work_sync(&this_smartmax_eps->work);
drivers/cpufreq/cpufreq_smartmax_eps.c-	cpufreq_smartmax_eps_timer(this_smartmax_eps);
drivers/cpufreq/cpufreq_smartmax_eps.c-	INIT_DEFERRABLE_WORK(&this_smartmax_eps->work, do_dbs_timer);
drivers/cpufreq/cpufreq_smartmax_eps.c-	mutex_unlock(&this_smartmax_eps->timer_mutex);
drivers/cpufreq/cpufreq_smartmax_eps.c:	queue_delayed_work_on(cpu, smartmax_eps_wq, &this_smartmax_eps->work, delay);
drivers/cpufreq/cpufreq_smartmax_eps.c:	schedule_delayed_work_on(this_smartmax_eps->cpu, &this_smartmax_eps->work, delay);
drivers/cpufreq/cpufreq_smartmax_eps.c-static inline void dbs_timer_exit(struct smartmax_eps_info_s *this_smartmax_eps) {
drivers/cpufreq/cpufreq_smartmax_eps.c-	struct cpufreq_frequency_table *freq_table;
drivers/cpufreq/cpufreq_smartmax_eps.c-	struct cpufreq_policy *cur_policy;
drivers/cpufreq/cpufreq_smartmax_eps.c:	struct delayed_work work;
drivers/cpufreq/cpufreq_smartmax_eps.c-	u64 prev_cpu_idle;
drivers/cpufreq/cpufreq_smartmax_eps.c-	u64 prev_cpu_iowait;
drivers/cpufreq/cpufreq_stockdemand.c-
drivers/cpufreq/cpufreq_stockdemand.c-
drivers/cpufreq/cpufreq_stockdemand.c-
drivers/cpufreq/cpufreq_stockdemand.c-
drivers/cpufreq/cpufreq_stockdemand.c-
drivers/cpufreq/cpufreq_stockdemand.c-
drivers/cpufreq/cpufreq_stockdemand.c-
drivers/cpufreq/cpufreq_stockdemand.c-{
drivers/cpufreq/cpufreq_stockdemand.c-}
drivers/cpufreq/cpufreq_stockdemand.c-}
drivers/cpufreq/cpufreq_stockdemand.c-}
drivers/cpufreq/cpufreq_stockdemand.c-	}
drivers/cpufreq/cpufreq_stockdemand.c-			/*
drivers/cpufreq/cpufreq_stockdemand.c:	cancel_delayed_work_sync(&dbs_info->work);
drivers/cpufreq/cpufreq_stockdemand.c:			cancel_delayed_work_sync(&dbs_info->work);
drivers/cpufreq/cpufreq_stockdemand.c:			cancel_delayed_work_sync(&this_dbs_info->work);
drivers/cpufreq/cpufreq_stockdemand.c-			/* cancel the next stockdemand sample */
drivers/cpufreq/cpufreq_stockdemand.c-			continue;
drivers/cpufreq/cpufreq_stockdemand.c-	dbs_info->sample_type = DBS_NORMAL_SAMPLE;
drivers/cpufreq/cpufreq_stockdemand.c-				&dbs_info->work, usecs_to_jiffies(new_rate));
drivers/cpufreq/cpufreq_stockdemand.c-		delay = dbs_info->freq_lo_jiffies;
drivers/cpufreq/cpufreq_stockdemand.c:		if (!delayed_work_pending(&dbs_info->work)) {
drivers/cpufreq/cpufreq_stockdemand.c-		if (policy->cur < src_freq) {
drivers/cpufreq/cpufreq_stockdemand.c-	INIT_DEFERRABLE_WORK(&dbs_info->work, do_dbs_timer);
drivers/cpufreq/cpufreq_stockdemand.c:			mod_delayed_work_on(cpu, dbs_wq,
drivers/cpufreq/cpufreq_stockdemand.c:	mod_delayed_work_on(cpu, dbs_wq, &dbs_info->work, delay);
drivers/cpufreq/cpufreq_stockdemand.c:			mod_delayed_work_on(dbs_info->cpu, dbs_wq,
drivers/cpufreq/cpufreq_stockdemand.c:	mod_delayed_work_on(dbs_info->cpu, dbs_wq, &dbs_info->work, delay);
drivers/cpufreq/cpufreq_stockdemand.c-		mutex_lock(&dbs_info->timer_mutex);
drivers/cpufreq/cpufreq_stockdemand.c-			mutex_lock(&dbs_info->timer_mutex);
drivers/cpufreq/cpufreq_stockdemand.c-			mutex_lock(&this_dbs_info->timer_mutex);
drivers/cpufreq/cpufreq_stockdemand.c-	mutex_unlock(&dbs_info->timer_mutex);
drivers/cpufreq/cpufreq_stockdemand.c-			mutex_unlock(&dbs_info->timer_mutex);
drivers/cpufreq/cpufreq_stockdemand.c-			mutex_unlock(&dbs_info->timer_mutex);
drivers/cpufreq/cpufreq_stockdemand.c-			mutex_unlock(&this_dbs_info->timer_mutex);
drivers/cpufreq/cpufreq_stockdemand.c-			/* reschedule the next stockdemand sample */
drivers/cpufreq/cpufreq_stockdemand.c-static inline void dbs_timer_exit(struct cpu_dbs_info_s *dbs_info)
drivers/cpufreq/cpufreq_stockdemand.c-	struct cpufreq_frequency_table *freq_table;
drivers/cpufreq/cpufreq_stockdemand.c-	struct cpufreq_policy *cur_policy;
drivers/cpufreq/cpufreq_stockdemand.c:	struct delayed_work work;
drivers/cpufreq/cpufreq_stockdemand.c-					      &this_dbs_info->work, delay);
drivers/cpufreq/cpufreq_stockdemand.c-	u64 prev_cpu_nice;
drivers/cpufreq/cpufreq_stockdemand.c-	unsigned int freq_lo;
drivers/cpufreq/cpufreq_uberdemand.c-
drivers/cpufreq/cpufreq_uberdemand.c-
drivers/cpufreq/cpufreq_uberdemand.c-{
drivers/cpufreq/cpufreq_uberdemand.c-}
drivers/cpufreq/cpufreq_uberdemand.c-}
drivers/cpufreq/cpufreq_uberdemand.c-}
drivers/cpufreq/cpufreq_uberdemand.c-	}
drivers/cpufreq/cpufreq_uberdemand.c:	cancel_delayed_work_sync(&dbs_info->work);
drivers/cpufreq/cpufreq_uberdemand.c-	dbs_info->sample_type = DBS_NORMAL_SAMPLE;
drivers/cpufreq/cpufreq_uberdemand.c-		delay = dbs_info->freq_lo_jiffies;
drivers/cpufreq/cpufreq_uberdemand.c-	INIT_DEFERRABLE_WORK(&dbs_info->work, do_dbs_timer);
drivers/cpufreq/cpufreq_uberdemand.c-	mutex_unlock(&dbs_info->timer_mutex);
drivers/cpufreq/cpufreq_uberdemand.c:	schedule_delayed_work_on(cpu, &dbs_info->work, delay);
drivers/cpufreq/cpufreq_uberdemand.c:	schedule_delayed_work_on(dbs_info->cpu, &dbs_info->work, delay);
drivers/cpufreq/cpufreq_uberdemand.c-static inline void dbs_timer_exit(struct cpu_dbs_info_s *dbs_info)
drivers/cpufreq/cpufreq_uberdemand.c-	struct cpufreq_frequency_table *freq_table;
drivers/cpufreq/cpufreq_uberdemand.c-	struct cpufreq_policy *cur_policy;
drivers/cpufreq/cpufreq_uberdemand.c:	struct delayed_work work;
drivers/cpufreq/cpufreq_uberdemand.c-	u64 prev_cpu_nice;
drivers/cpufreq/cpufreq_uberdemand.c-	unsigned int freq_lo;
drivers/cpufreq/cpufreq_wheatley.c-
drivers/cpufreq/cpufreq_wheatley.c-
drivers/cpufreq/cpufreq_wheatley.c-{
drivers/cpufreq/cpufreq_wheatley.c-}
drivers/cpufreq/cpufreq_wheatley.c-}
drivers/cpufreq/cpufreq_wheatley.c-}
drivers/cpufreq/cpufreq_wheatley.c-    }
drivers/cpufreq/cpufreq_wheatley.c:    cancel_delayed_work_sync(&dbs_info->work);
drivers/cpufreq/cpufreq_wheatley.c-    dbs_info->sample_type = DBS_NORMAL_SAMPLE;
drivers/cpufreq/cpufreq_wheatley.c-	delay = dbs_info->freq_lo_jiffies;
drivers/cpufreq/cpufreq_wheatley.c-    INIT_DEFERRABLE_WORK(&dbs_info->work, do_dbs_timer);
drivers/cpufreq/cpufreq_wheatley.c-    mutex_unlock(&dbs_info->timer_mutex);
drivers/cpufreq/cpufreq_wheatley.c:    schedule_delayed_work_on(cpu, &dbs_info->work, delay);
drivers/cpufreq/cpufreq_wheatley.c:    schedule_delayed_work_on(dbs_info->cpu, &dbs_info->work, delay);
drivers/cpufreq/cpufreq_wheatley.c-static inline void dbs_timer_exit(struct cpu_dbs_info_s *dbs_info)
drivers/cpufreq/cpufreq_wheatley.c-    struct cpufreq_frequency_table *freq_table;
drivers/cpufreq/cpufreq_wheatley.c-    struct cpufreq_policy *cur_policy;
drivers/cpufreq/cpufreq_wheatley.c:    struct delayed_work work;
drivers/cpufreq/cpufreq_wheatley.c-    u64 prev_cpu_nice;
drivers/cpufreq/cpufreq_wheatley.c-    unsigned int freq_lo;
drivers/cpufreq/cpufreq_zzmoove.c-
drivers/cpufreq/cpufreq_zzmoove.c-
drivers/cpufreq/cpufreq_zzmoove.c-
drivers/cpufreq/cpufreq_zzmoove.c-
drivers/cpufreq/cpufreq_zzmoove.c-
drivers/cpufreq/cpufreq_zzmoove.c-
drivers/cpufreq/cpufreq_zzmoove.c-
drivers/cpufreq/cpufreq_zzmoove.c-}
drivers/cpufreq/cpufreq_zzmoove.c-}
drivers/cpufreq/cpufreq_zzmoove.c-}
drivers/cpufreq/cpufreq_zzmoove.c:	cancel_delayed_work_sync(&dbs_info->work);
drivers/cpufreq/cpufreq_zzmoove.c:	cancel_delayed_work_sync(&dbs_info->work);
drivers/cpufreq/cpufreq_zzmoove.c:	cancel_delayed_work(&tmu_read_work);					// ZZ: cancel cpu temperature reading
drivers/cpufreq/cpufreq_zzmoove.c:	    cancel_delayed_work(&tmu_read_work);						// ZZ: cancel work
drivers/cpufreq/cpufreq_zzmoove.c:		cancel_delayed_work(&tmu_read_work);						// ZZ: cancel work
drivers/cpufreq/cpufreq_zzmoove.c-		cancel_temp_reading = false;							// ZZ: reset cancel flag
drivers/cpufreq/cpufreq_zzmoove.c-		cancel_temp_reading = false;							// ZZ: reset cancel flag
drivers/cpufreq/cpufreq_zzmoove.c-	dbs_check_cpu(dbs_info);
drivers/cpufreq/cpufreq_zzmoove.c-	dbs_info_enabled = false;
drivers/cpufreq/cpufreq_zzmoove.c-	} else {
drivers/cpufreq/cpufreq_zzmoove.c-		else
drivers/cpufreq/cpufreq_zzmoove.c-#endif
drivers/cpufreq/cpufreq_zzmoove.c-#endif
drivers/cpufreq/cpufreq_zzmoove.c-#endif
drivers/cpufreq/cpufreq_zzmoove.c-#endif
drivers/cpufreq/cpufreq_zzmoove.c-	flush_workqueue(dbs_wq);
drivers/cpufreq/cpufreq_zzmoove.c-	if (dbs_tuners_ins.scaling_block_temp == 0 && temp_reading_started)			// ZZ: if temp reading was disabled via sysfs and work was started
drivers/cpufreq/cpufreq_zzmoove.c-	if (dbs_tuners_ins.scaling_block_temp != 0) {						// ZZ: only if it is enabled and we are not at suspend
drivers/cpufreq/cpufreq_zzmoove.c-#ifdef CONFIG_EXYNOS4_EXPORT_TEMP
drivers/cpufreq/cpufreq_zzmoove.c-	    if (!suspend_flag) {
drivers/cpufreq/cpufreq_zzmoove.c-	    if (temp_reading_started && cancel_temp_reading) {					// ZZ: if work was started and cancel flag was set
drivers/cpufreq/cpufreq_zzmoove.c-	INIT_DEFERRABLE_WORK(&dbs_info->work, do_dbs_timer);
drivers/cpufreq/cpufreq_zzmoove.c-	mutex_unlock(&dbs_info->timer_mutex);
drivers/cpufreq/cpufreq_zzmoove.c-	pr_info("[zzmoove/zz_restartloop_work] restarting cycle\n");
drivers/cpufreq/cpufreq_zzmoove.c:	queue_delayed_work_on(cpu, dbs_wq, &dbs_info->work, 0);
drivers/cpufreq/cpufreq_zzmoove.c:	queue_delayed_work_on(cpu, dbs_wq, &dbs_info->work, delay);
drivers/cpufreq/cpufreq_zzmoove.c:	queue_delayed_work_on(dbs_info->cpu, dbs_wq, &dbs_info->work, delay);
drivers/cpufreq/cpufreq_zzmoove.c:		schedule_delayed_work(&tmu_read_work, msecs_to_jiffies(DEF_TMU_READ_DELAY));	// ZZ: start work
drivers/cpufreq/cpufreq_zzmoove.c:		schedule_delayed_work(&work_tmu_check, msecs_to_jiffies(tmu_check_delay));
drivers/cpufreq/cpufreq_zzmoove.c-	struct cpufreq_policy *cur_policy;
drivers/cpufreq/cpufreq_zzmoove.c:	struct delayed_work work;
drivers/cpufreq/cpufreq_zzmoove.c-		temp_reading_started = false;							// ZZ: reset started flag
drivers/cpufreq/cpufreq_zzmoove.c-		temp_reading_started = true;							// ZZ: set work started flag
drivers/cpufreq/cpufreq_zzmoove.c-			tmu_check_delay = DEF_TMU_CHECK_DELAY_SLEEP;
drivers/cpufreq/cpufreq_zzmoove.c-		tt_reset();
drivers/cpufreq/cpufreq_zzmoove.c-	u64 prev_cpu_nice;
drivers/cpufreq/cpufreq_zzmoove.c-	unsigned int down_skip;					// ZZ: Sampling Down reactivated
drivers/cpufreq/cpufreq_zzmoove.c-	unsigned int requested_freq;
drivers/cpufreq/cpufreq_zzmoove.c-	work_restartloop_in_progress = false;
drivers/cpu_hotplug/autosmp.c-
drivers/cpu_hotplug/autosmp.c-
drivers/cpu_hotplug/autosmp.c-
drivers/cpu_hotplug/autosmp.c-
drivers/cpu_hotplug/autosmp.c-
drivers/cpu_hotplug/autosmp.c-
drivers/cpu_hotplug/autosmp.c-}
drivers/cpu_hotplug/autosmp.c-}
drivers/cpu_hotplug/autosmp.c-}
drivers/cpu_hotplug/autosmp.c-	}
drivers/cpu_hotplug/autosmp.c:		cancel_delayed_work(&asmp_work);
drivers/cpu_hotplug/autosmp.c:		cancel_delayed_work(&prework);
drivers/cpu_hotplug/autosmp.c-		destroy_workqueue(asmp_workq);
drivers/cpu_hotplug/autosmp.c-	} else {
drivers/cpu_hotplug/autosmp.c-	if (!hotplug_ready) {
drivers/cpu_hotplug/autosmp.c-		INIT_DELAYED_WORK(&asmp_work, asmp_work_fn);
drivers/cpu_hotplug/autosmp.c-	last_boost_time = ktime_get();
drivers/cpu_hotplug/autosmp.c:	mod_delayed_work_on(0, asmp_workq, &asmp_work,
drivers/cpu_hotplug/autosmp.c:		mod_delayed_work_on(0, asmp_workq, &prework,
drivers/cpu_hotplug/autosmp.c:	mod_delayed_work_on(0, asmp_workq, &prework,
drivers/cpu_hotplug/autosmp.c:	mod_delayed_work_on(0, asmp_workq, &prework,
drivers/cpu_hotplug/autosmp.c:	mod_delayed_work_on(0, asmp_workq, &prework,
drivers/cpu_hotplug/autosmp.c-			msecs_to_jiffies(delay));
drivers/cpu_hotplug/autosmp.c-			msecs_to_jiffies(delay));
drivers/cpu_hotplug/autosmp.c-			msecs_to_jiffies(delay));
drivers/cpu_hotplug/autosmp.c-			msecs_to_jiffies(delay));
drivers/cpu_hotplug/autosmp.c-				msecs_to_jiffies(delay));
drivers/cpu_hotplug/autosmp.c-				msecs_to_jiffies(delay * 2));
drivers/cpu_hotplug/autosmp.c:		queue_delayed_work_on(0, asmp_workq, &prework,
drivers/cpu_hotplug/autosmp.c-		register_power_suspend(&asmp_suspend_data);
drivers/cpu_hotplug/autosmp.c-resched:
drivers/cpu_hotplug/autosmp.c-		return;
drivers/cpu_hotplug/autosmp.c-		return;
drivers/cpu_hotplug/autosmp.c-static DEFINE_SPINLOCK(asmp_lock);
drivers/cpu_hotplug/autosmp.c:static struct delayed_work asmp_work;
drivers/cpu_hotplug/autosmp.c:static struct delayed_work prework;
drivers/cpu_hotplug/autosmp.c-static struct workqueue_struct *asmp_workq;
drivers/cpu_hotplug/autosmp.c-static unsigned int asmp_enabled = 0;
drivers/cpu_hotplug/autosmp.c-		unregister_power_suspend(&asmp_suspend_data);
drivers/cpu_hotplug/autosmp.c-	WRITE_ONCE(should_boost, 1);
drivers/cpu_hotplug/blu_plug.c-
drivers/cpu_hotplug/blu_plug.c-
drivers/cpu_hotplug/blu_plug.c-
drivers/cpu_hotplug/blu_plug.c-
drivers/cpu_hotplug/blu_plug.c-
drivers/cpu_hotplug/blu_plug.c-
drivers/cpu_hotplug/blu_plug.c-}
drivers/cpu_hotplug/blu_plug.c-}
drivers/cpu_hotplug/blu_plug.c-	}
drivers/cpu_hotplug/blu_plug.c:		cancel_delayed_work(&dyn_work);
drivers/cpu_hotplug/blu_plug.c-		destroy_workqueue(dyn_workq);
drivers/cpu_hotplug/blu_plug.c-		down_one();
drivers/cpu_hotplug/blu_plug.c-	} else {
drivers/cpu_hotplug/blu_plug.c:	mod_delayed_work_on(0, dyn_workq, &dyn_work, msecs_to_jiffies(delay));
drivers/cpu_hotplug/blu_plug.c-				 msecs_to_jiffies(INIT_DELAY));
drivers/cpu_hotplug/blu_plug.c-					 msecs_to_jiffies(INIT_DELAY));
drivers/cpu_hotplug/blu_plug.c:		queue_delayed_work_on(0, dyn_workq, &dyn_work,
drivers/cpu_hotplug/blu_plug.c:	queue_delayed_work_on(0, dyn_workq, &dyn_work,
drivers/cpu_hotplug/blu_plug.c-		register_power_suspend(&blu_suspend_data);
drivers/cpu_hotplug/blu_plug.c-		return;
drivers/cpu_hotplug/blu_plug.c:static struct delayed_work dyn_work;
drivers/cpu_hotplug/blu_plug.c-static struct notifier_block notify;
drivers/cpu_hotplug/blu_plug.c-static struct workqueue_struct *dyn_workq;
drivers/cpu_hotplug/blu_plug.c-static unsigned int plug_threshold[NR_CPUS] = {[0 ... NR_CPUS-1] = DEF_PLUG_THRESHOLD};
drivers/cpu_hotplug/blu_plug.c-		unregister_power_suspend(&blu_suspend_data);
drivers/cpu_hotplug/bricked_hotplug.c-
drivers/cpu_hotplug/bricked_hotplug.c-
drivers/cpu_hotplug/bricked_hotplug.c-
drivers/cpu_hotplug/bricked_hotplug.c-
drivers/cpu_hotplug/bricked_hotplug.c-
drivers/cpu_hotplug/bricked_hotplug.c-
drivers/cpu_hotplug/bricked_hotplug.c-{
drivers/cpu_hotplug/bricked_hotplug.c-}
drivers/cpu_hotplug/bricked_hotplug.c-}
drivers/cpu_hotplug/bricked_hotplug.c-};
drivers/cpu_hotplug/bricked_hotplug.c-};
drivers/cpu_hotplug/bricked_hotplug.c-	}
drivers/cpu_hotplug/bricked_hotplug.c:		cancel_delayed_work_sync(&dl->lock_rem);
drivers/cpu_hotplug/bricked_hotplug.c:	cancel_delayed_work_sync(&hotplug_work);
drivers/cpu_hotplug/bricked_hotplug.c-	dl->locked = 1;
drivers/cpu_hotplug/bricked_hotplug.c-		dl = &per_cpu(lock_info, cpu);
drivers/cpu_hotplug/bricked_hotplug.c-	for_each_possible_cpu(cpu) {
drivers/cpu_hotplug/bricked_hotplug.c-	if (bricked_enabled)
drivers/cpu_hotplug/bricked_hotplug.c-	if (bricked_enabled)
drivers/cpu_hotplug/bricked_hotplug.c-				msecs_to_jiffies(hotplug.delay));
drivers/cpu_hotplug/bricked_hotplug.c-					msecs_to_jiffies(hotplug.delay));
drivers/cpu_hotplug/bricked_hotplug.c-			      msecs_to_jiffies(hotplug.down_lock_dur));
drivers/cpu_hotplug/bricked_hotplug.c-					msecs_to_jiffies(hotplug.startdelay));
drivers/cpu_hotplug/bricked_hotplug.c-	mutex_destroy(&hotplug.bricked_cpu_mutex);
drivers/cpu_hotplug/bricked_hotplug.c-	mutex_destroy(&hotplug.bricked_hotplug_mutex);
drivers/cpu_hotplug/bricked_hotplug.c-out:
drivers/cpu_hotplug/bricked_hotplug.c:		queue_delayed_work(hotplug_wq, &hotplug_work,
drivers/cpu_hotplug/bricked_hotplug.c:		queue_delayed_work(hotplug_wq, &hotplug_work,
drivers/cpu_hotplug/bricked_hotplug.c:	queue_delayed_work(hotplug_wq, &hotplug_work,
drivers/cpu_hotplug/bricked_hotplug.c:	queue_delayed_work_on(0, hotplug_wq, &dl->lock_rem,
drivers/cpu_hotplug/bricked_hotplug.c-	return;
drivers/cpu_hotplug/bricked_hotplug.c-static DEFINE_PER_CPU(struct down_lock, lock_info);
drivers/cpu_hotplug/bricked_hotplug.c:static struct delayed_work hotplug_work;
drivers/cpu_hotplug/bricked_hotplug.c-static struct workqueue_struct *hotplug_wq;
drivers/cpu_hotplug/bricked_hotplug.c-static void bricked_resume(struct power_suspend * h)
drivers/cpu_hotplug/bricked_hotplug.c:	struct delayed_work lock_rem;
drivers/cpu_hotplug/bricked_hotplug.c-struct down_lock {
drivers/cpu_hotplug/bricked_hotplug.c-	unsigned int locked;
drivers/cpu_hotplug/dyn_hotplug.c-
drivers/cpu_hotplug/dyn_hotplug.c-
drivers/cpu_hotplug/dyn_hotplug.c-
drivers/cpu_hotplug/dyn_hotplug.c-
drivers/cpu_hotplug/dyn_hotplug.c-{
drivers/cpu_hotplug/dyn_hotplug.c-}
drivers/cpu_hotplug/dyn_hotplug.c:	cancel_delayed_work(&hp_data->work);
drivers/cpu_hotplug/dyn_hotplug.c:	cancel_delayed_work(&hp_data->work);
drivers/cpu_hotplug/dyn_hotplug.c-		down_one();
drivers/cpu_hotplug/dyn_hotplug.c-	flush_scheduled_work();
drivers/cpu_hotplug/dyn_hotplug.c-	flush_scheduled_work();
drivers/cpu_hotplug/dyn_hotplug.c-} *hp_data;
drivers/cpu_hotplug/dyn_hotplug.c-	hp_data->enabled = 1;
drivers/cpu_hotplug/dyn_hotplug.c-	if (!hp_data->enabled)
drivers/cpu_hotplug/dyn_hotplug.c-	if (hp_data->enabled)
drivers/cpu_hotplug/dyn_hotplug.c-	INIT_DELAYED_WORK(&hp_data->work, load_timer);
drivers/cpu_hotplug/dyn_hotplug.c-	pr_info("%s: activated\n", __func__);
drivers/cpu_hotplug/dyn_hotplug.c-	register_power_suspend(&hp_data->suspend);
drivers/cpu_hotplug/dyn_hotplug.c-		return;
drivers/cpu_hotplug/dyn_hotplug.c-		return;
drivers/cpu_hotplug/dyn_hotplug.c:	schedule_delayed_work_on(0, &hp_data->work, hp_data->delay);
drivers/cpu_hotplug/dyn_hotplug.c:	schedule_delayed_work_on(0, &hp_data->work, hp_data->delay);
drivers/cpu_hotplug/dyn_hotplug.c:	schedule_delayed_work_on(0, &hp_data->work, INIT_DELAY);
drivers/cpu_hotplug/dyn_hotplug.c-static void __exit dyn_hp_exit(void)
drivers/cpu_hotplug/dyn_hotplug.c:	struct delayed_work work;
drivers/cpu_hotplug/dyn_hotplug.c-	struct power_suspend suspend;
drivers/cpu_hotplug/dyn_hotplug.c-	unregister_power_suspend(&hp_data->suspend);
drivers/cpu_hotplug/dyn_hotplug.c-	unregister_power_suspend(&hp_data->suspend);
drivers/cpu_hotplug/dyn_hotplug.c-	unsigned int enabled;
drivers/cpu_hotplug/dyn_hotplug.c-	unsigned int saved_min_cpus_online;
drivers/cpu_hotplug/intelli_hotplug.c-
drivers/cpu_hotplug/intelli_hotplug.c-
drivers/cpu_hotplug/intelli_hotplug.c-
drivers/cpu_hotplug/intelli_hotplug.c-
drivers/cpu_hotplug/intelli_hotplug.c-}
drivers/cpu_hotplug/intelli_hotplug.c-}
drivers/cpu_hotplug/intelli_hotplug.c-}
drivers/cpu_hotplug/intelli_hotplug.c-}
drivers/cpu_hotplug/intelli_hotplug.c-}
drivers/cpu_hotplug/intelli_hotplug.c-};
drivers/cpu_hotplug/intelli_hotplug.c-	}
drivers/cpu_hotplug/intelli_hotplug.c-	}
drivers/cpu_hotplug/intelli_hotplug.c-	}
drivers/cpu_hotplug/intelli_hotplug.c-		atomic_set(&from_boost, 0);
drivers/cpu_hotplug/intelli_hotplug.c-	bool locked;
drivers/cpu_hotplug/intelli_hotplug.c-			break;
drivers/cpu_hotplug/intelli_hotplug.c:	cancel_delayed_work(&intelli_plug_work);
drivers/cpu_hotplug/intelli_hotplug.c:	cancel_delayed_work(&intelli_plug_work);
drivers/cpu_hotplug/intelli_hotplug.c:		cancel_delayed_work_sync(&dl->lock_rem);
drivers/cpu_hotplug/intelli_hotplug.c:	cancel_delayed_work(&up_down_work);
drivers/cpu_hotplug/intelli_hotplug.c-					def_sampling_ms);
drivers/cpu_hotplug/intelli_hotplug.c-			dl->locked = false;
drivers/cpu_hotplug/intelli_hotplug.c-		dl = &per_cpu(lock_info, cpu);
drivers/cpu_hotplug/intelli_hotplug.c-		      duration);
drivers/cpu_hotplug/intelli_hotplug.c-	else
drivers/cpu_hotplug/intelli_hotplug.c-	} else
drivers/cpu_hotplug/intelli_hotplug.c-	for_each_possible_cpu(cpu) {
drivers/cpu_hotplug/intelli_hotplug.c-	hardplug_all_cpus();
drivers/cpu_hotplug/intelli_hotplug.c-		if (check_down_lock(cpu))
drivers/cpu_hotplug/intelli_hotplug.c-		if (cpu_out_of_range(cpu))
drivers/cpu_hotplug/intelli_hotplug.c-	if (intelli_suspended == INTELLI_AWAKE)
drivers/cpu_hotplug/intelli_hotplug.c-	intellinit = false;
drivers/cpu_hotplug/intelli_hotplug.c-	intellinit = false;
drivers/cpu_hotplug/intelli_hotplug.c-	last_boost_time = ktime_get();
drivers/cpu_hotplug/intelli_hotplug.c:		mod_delayed_work_on(0, intelliplug_wq, &intelli_plug_work,
drivers/cpu_hotplug/intelli_hotplug.c:	mod_delayed_work_on(0, intelliplug_wq, &intelli_plug_work, def_sampling_ms);
drivers/cpu_hotplug/intelli_hotplug.c:		mod_delayed_work_on(0, updown_wq, &up_down_work, 0);
drivers/cpu_hotplug/intelli_hotplug.c:	mod_delayed_work_on(0, updown_wq, &up_down_work, 0);
drivers/cpu_hotplug/intelli_hotplug.c:	mod_delayed_work_on(0, updown_wq, &up_down_work, 0);
drivers/cpu_hotplug/intelli_hotplug.c:		mod_delayed_work_on(cpu, intelliplug_wq, &dl->lock_rem,
drivers/cpu_hotplug/intelli_hotplug.c-	mutex_lock(&intellisleep_mutex);
drivers/cpu_hotplug/intelli_hotplug.c-		recycle_cpus();
drivers/cpu_hotplug/intelli_hotplug.c-	register_omniboost(&intelli_nb);
drivers/cpu_hotplug/intelli_hotplug.c-	report_current_cpus();
drivers/cpu_hotplug/intelli_hotplug.c-reschedule:
drivers/cpu_hotplug/intelli_hotplug.c-		return;
drivers/cpu_hotplug/intelli_hotplug.c-			rm_down_lock(cpu, 0);
drivers/cpu_hotplug/intelli_hotplug.c-	sanitize_min_max(cpus_boosted, min_cpus_online, max_cpus_online);
drivers/cpu_hotplug/intelli_hotplug.c:		schedule_delayed_work(&delayed_recycle, 1000);
drivers/cpu_hotplug/intelli_hotplug.c-static DEFINE_PER_CPU(struct down_lock, lock_info);
drivers/cpu_hotplug/intelli_hotplug.c-static ktime_t last_input;
drivers/cpu_hotplug/intelli_hotplug.c:static struct delayed_work intelli_plug_work;
drivers/cpu_hotplug/intelli_hotplug.c:static struct delayed_work up_down_work;
drivers/cpu_hotplug/intelli_hotplug.c-static struct workqueue_struct *intelliplug_wq;
drivers/cpu_hotplug/intelli_hotplug.c-static struct workqueue_struct *updown_wq;
drivers/cpu_hotplug/intelli_hotplug.c:	struct delayed_work lock_rem;
drivers/cpu_hotplug/intelli_hotplug.c-struct down_lock {
drivers/cpu_hotplug/intelli_hotplug.c-	unregister_power_suspend(&intelli_suspend_data);
drivers/cpu_hotplug/intelli_hotplug.c-	wake_unlock(&ipwlock);
drivers/cpu_hotplug/intelli_hotplug.c-	wake_unlock(&ipwlock);
drivers/cpu_hotplug/intelli_hotplug.c-		WRITE_ONCE(target_cpus, calculate_thread_stats());
drivers/cpu_hotplug/intelli_hotplug.c-	WRITE_ONCE(target_cpus, cpus_boosted);
drivers/cpu_hotplug/mako_hotplug.c-
drivers/cpu_hotplug/mako_hotplug.c-
drivers/cpu_hotplug/mako_hotplug.c-
drivers/cpu_hotplug/mako_hotplug.c-
drivers/cpu_hotplug/mako_hotplug.c-
drivers/cpu_hotplug/mako_hotplug.c-
drivers/cpu_hotplug/mako_hotplug.c-}
drivers/cpu_hotplug/mako_hotplug.c-	}
drivers/cpu_hotplug/mako_hotplug.c-	 */
drivers/cpu_hotplug/mako_hotplug.c-err:
drivers/cpu_hotplug/mako_hotplug.c-	INIT_DELAYED_WORK(&decide_hotplug, decide_hotplug_func);
drivers/cpu_hotplug/mako_hotplug.c:	mod_delayed_work(wq, &decide_hotplug,
drivers/cpu_hotplug/mako_hotplug.c:	mod_delayed_work(wq, &decide_hotplug, msecs_to_jiffies(200));
drivers/cpu_hotplug/mako_hotplug.c-		msecs_to_jiffies(100));
drivers/cpu_hotplug/mako_hotplug.c-	 * once every 2 seconds
drivers/cpu_hotplug/mako_hotplug.c:	queue_delayed_work(wq, &decide_hotplug, msecs_to_jiffies(3000));
drivers/cpu_hotplug/mako_hotplug.c-	return ret;
drivers/cpu_hotplug/mako_hotplug.c-static inline void cpus_online_work(void)
drivers/cpu_hotplug/mako_hotplug.c:static struct delayed_work decide_hotplug;
drivers/cpu_hotplug/mako_hotplug.c-static struct workqueue_struct *wq;
drivers/cpu_hotplug/msm_hotplug.c-
drivers/cpu_hotplug/msm_hotplug.c-
drivers/cpu_hotplug/msm_hotplug.c-
drivers/cpu_hotplug/msm_hotplug.c-
drivers/cpu_hotplug/msm_hotplug.c-
drivers/cpu_hotplug/msm_hotplug.c-
drivers/cpu_hotplug/msm_hotplug.c-
drivers/cpu_hotplug/msm_hotplug.c-
drivers/cpu_hotplug/msm_hotplug.c-}
drivers/cpu_hotplug/msm_hotplug.c-}
drivers/cpu_hotplug/msm_hotplug.c-}
drivers/cpu_hotplug/msm_hotplug.c-};
drivers/cpu_hotplug/msm_hotplug.c-	}
drivers/cpu_hotplug/msm_hotplug.c-	}
drivers/cpu_hotplug/msm_hotplug.c-	}
drivers/cpu_hotplug/msm_hotplug.c:		cancel_delayed_work_sync(&dl->lock_rem);
drivers/cpu_hotplug/msm_hotplug.c:	cancel_delayed_work_sync(&hotplug_work);
drivers/cpu_hotplug/msm_hotplug.c-	delay = load_to_update_rate(stats.cur_avg_load);
drivers/cpu_hotplug/msm_hotplug.c-	dl->locked = 1;
drivers/cpu_hotplug/msm_hotplug.c-		dl = &per_cpu(lock_info, cpu);
drivers/cpu_hotplug/msm_hotplug.c-		dl = &per_cpu(lock_info, cpu);
drivers/cpu_hotplug/msm_hotplug.c-	for_each_possible_cpu(cpu) {
drivers/cpu_hotplug/msm_hotplug.c-		if (check_down_lock(cpu))
drivers/cpu_hotplug/msm_hotplug.c:			mod_delayed_work(hotplug_wq, &dl->lock_rem, 0);
drivers/cpu_hotplug/msm_hotplug.c:	mod_delayed_work_on(0, hotplug_wq, &dl->lock_rem,
drivers/cpu_hotplug/msm_hotplug.c:	mod_delayed_work_on(0, hotplug_wq, &hotplug_work,
drivers/cpu_hotplug/msm_hotplug.c-			      msecs_to_jiffies(delay));
drivers/cpu_hotplug/msm_hotplug.c-			      msecs_to_jiffies(hotplug.down_lock_dur));
drivers/cpu_hotplug/msm_hotplug.c-			      msecs_to_jiffies(START_DELAY));
drivers/cpu_hotplug/msm_hotplug.c-	mutex_destroy(&hotplug.msm_hotplug_mutex);
drivers/cpu_hotplug/msm_hotplug.c:	queue_delayed_work_on(0, hotplug_wq, &hotplug_work,
drivers/cpu_hotplug/msm_hotplug.c:static struct delayed_work hotplug_work;
drivers/cpu_hotplug/msm_hotplug.c-static struct workqueue_struct *hotplug_wq;
drivers/cpu_hotplug/msm_hotplug.c-static unsigned int msmhp_suspended;
drivers/cpu_hotplug/msm_hotplug.c:	struct delayed_work lock_rem;
drivers/cpu_hotplug/msm_hotplug.c-struct down_lock {
drivers/cpu_hotplug/msm_hotplug.c-	unsigned int locked;
drivers/cpu_hotplug/mx_hotplug.c-
drivers/cpu_hotplug/mx_hotplug.c-
drivers/cpu_hotplug/mx_hotplug.c-
drivers/cpu_hotplug/mx_hotplug.c-
drivers/cpu_hotplug/mx_hotplug.c-
drivers/cpu_hotplug/mx_hotplug.c-}
drivers/cpu_hotplug/mx_hotplug.c-}
drivers/cpu_hotplug/mx_hotplug.c-}
drivers/cpu_hotplug/mx_hotplug.c:	cancel_delayed_work_sync(&motor);
drivers/cpu_hotplug/mx_hotplug.c:		cancel_delayed_work_sync(&motor);
drivers/cpu_hotplug/mx_hotplug.c-		destroy_workqueue(mx_hp_engine);
drivers/cpu_hotplug/mx_hotplug.c-	} else
drivers/cpu_hotplug/mx_hotplug.c-	hotplug_suspended = true;
drivers/cpu_hotplug/mx_hotplug.c-		INIT_DELAYED_WORK(&motor, mx_motor);
drivers/cpu_hotplug/mx_hotplug.c-		kthread_stop(transmission);
drivers/cpu_hotplug/mx_hotplug.c:		mod_delayed_work_on(0, mx_hp_engine, &motor, 0);
drivers/cpu_hotplug/mx_hotplug.c-	mutex_unlock(&mx_mutex);
drivers/cpu_hotplug/mx_hotplug.c-	mutex_unlock(&mx_mutex);
drivers/cpu_hotplug/mx_hotplug.c-		mutex_unlock(&mx_mutex);
drivers/cpu_hotplug/mx_hotplug.c-		mutex_unlock(&mx_mutex);
drivers/cpu_hotplug/mx_hotplug.c-out:
drivers/cpu_hotplug/mx_hotplug.c:		queue_delayed_work_on(0, mx_hp_engine, &motor, sampling_rate);
drivers/cpu_hotplug/mx_hotplug.c:	queue_delayed_work_on(0, mx_hp_engine, &motor, sampling_rate);
drivers/cpu_hotplug/mx_hotplug.c:	queue_delayed_work_on(0, mx_hp_engine, &motor, sampling_rate);
drivers/cpu_hotplug/mx_hotplug.c-		register_omniboost(&mx_nb);
drivers/cpu_hotplug/mx_hotplug.c-		register_power_suspend(&mx_suspend_data);
drivers/cpu_hotplug/mx_hotplug.c-	release_clutch();
drivers/cpu_hotplug/mx_hotplug.c-		should_boost = true;
drivers/cpu_hotplug/mx_hotplug.c-static bool hotplug_suspended;
drivers/cpu_hotplug/mx_hotplug.c:static struct delayed_work motor;
drivers/cpu_hotplug/mx_hotplug.c-static struct task_struct *transmission;
drivers/cpu_hotplug/mx_hotplug.c-static struct workqueue_struct *mx_hp_engine;
drivers/cpu_hotplug/mx_hotplug.c-		unregister_omniboost(&mx_nb);
drivers/cpu_hotplug/mx_hotplug.c-		unregister_power_suspend(&mx_suspend_data);
drivers/cpu_hotplug/mx_hotplug.c-	wake_up_process(transmission);
drivers/cpuquiet/governors/balanced.c-		}
drivers/cpuquiet/governors/balanced.c-				balanced_state = DOWN;
drivers/cpuquiet/governors/balanced.c-				balanced_state = DOWN;
drivers/cpuquiet/governors/balanced.c-	balanced_state = IDLE;
drivers/cpuquiet/governors/balanced.c-				balanced_state = UP;
drivers/cpuquiet/governors/balanced.c-				balanced_state = UP;
drivers/cpuquiet/governors/balanced.c-						 &balanced_work, up_delay);
drivers/cpuquiet/governors/balanced.c-					&balanced_work, up_delay);
drivers/cpuquiet/governors/balanced.c-					balanced_wq, &balanced_work,
drivers/cpuquiet/governors/balanced.c-					balanced_wq, &balanced_work, up_delay);
drivers/cpuquiet/governors/balanced.c-					balanced_wq, &balanced_work, up_delay);
drivers/cpuquiet/governors/balanced.c-			balanced_wq, &balanced_work, up_delay);
drivers/cpuquiet/governors/balanced.c-		break;
drivers/cpuquiet/governors/balanced.c-			break;
drivers/cpuquiet/governors/balanced.c:	cancel_delayed_work_sync(&balanced_work);
drivers/cpuquiet/governors/balanced.c-	del_timer(&load_timer);
drivers/cpuquiet/governors/balanced.c-	destroy_workqueue(balanced_wq);
drivers/cpuquiet/governors/balanced.c-					down_delay);
drivers/cpuquiet/governors/balanced.c-		} else
drivers/cpuquiet/governors/balanced.c-			} else if (cpu_freq <= idle_bottom_freq) {
drivers/cpuquiet/governors/balanced.c-			if (cpu_freq <= idle_bottom_freq) {
drivers/cpuquiet/governors/balanced.c-			if (cpu_freq >= idle_top_freq) {
drivers/cpuquiet/governors/balanced.c-			if (cpu_freq >= idle_top_freq) {
drivers/cpuquiet/governors/balanced.c-		if (cpu < nr_cpu_ids) {
drivers/cpuquiet/governors/balanced.c-	/* now we can force the governor to be idle */
drivers/cpuquiet/governors/balanced.c:		queue_delayed_work(
drivers/cpuquiet/governors/balanced.c:				queue_delayed_work(
drivers/cpuquiet/governors/balanced.c:				queue_delayed_work(
drivers/cpuquiet/governors/balanced.c:				queue_delayed_work(
drivers/cpuquiet/governors/balanced.c:			queue_delayed_work(balanced_wq,
drivers/cpuquiet/governors/balanced.c:				queue_delayed_work(balanced_wq,
drivers/cpuquiet/governors/balanced.c-				start_load_timer();
drivers/cpuquiet/governors/balanced.c-				start_load_timer();
drivers/cpuquiet/governors/balanced.c-				start_load_timer();
drivers/cpuquiet/governors/balanced.c-static BALANCED_STATE balanced_state;
drivers/cpuquiet/governors/balanced.c:static struct delayed_work balanced_work;
drivers/cpuquiet/governors/balanced.c-static struct kobject *balanced_kobject;
drivers/cpuquiet/governors/balanced.c-static struct workqueue_struct *balanced_wq;
drivers/cpuquiet/governors/balanced.c-static unsigned int  load_sample_rate = 20; /* msec */
drivers/cpuquiet/governors/balanced.c-			up = false;
drivers/cpuquiet/governors/rqbalance.c-
drivers/cpuquiet/governors/rqbalance.c-
drivers/cpuquiet/governors/rqbalance.c-
drivers/cpuquiet/governors/rqbalance.c-
drivers/cpuquiet/governors/rqbalance.c-{
drivers/cpuquiet/governors/rqbalance.c-}
drivers/cpuquiet/governors/rqbalance.c-		}
drivers/cpuquiet/governors/rqbalance.c-		break;
drivers/cpuquiet/governors/rqbalance.c-		break;
drivers/cpuquiet/governors/rqbalance.c-			break;
drivers/cpuquiet/governors/rqbalance.c:		cancel_delayed_work(&rq_data->work);
drivers/cpuquiet/governors/rqbalance.c:	cancel_delayed_work_sync(&rqbalance_work);
drivers/cpuquiet/governors/rqbalance.c:		cancel_delayed_work_sync(&rqbalance_work);
drivers/cpuquiet/governors/rqbalance.c-	case PM_POST_SUSPEND:
drivers/cpuquiet/governors/rqbalance.c-	case PM_SUSPEND_PREPARE:
drivers/cpuquiet/governors/rqbalance.c-			create_freezable_workqueue("nr_run_avg");
drivers/cpuquiet/governors/rqbalance.c-	del_timer(&load_timer);
drivers/cpuquiet/governors/rqbalance.c-	destroy_workqueue(rqbalance_wq);
drivers/cpuquiet/governors/rqbalance.c-					down_delay);
drivers/cpuquiet/governors/rqbalance.c-		} else
drivers/cpuquiet/governors/rqbalance.c-			} else if (cpu_freq <= idle_bottom_freq) {
drivers/cpuquiet/governors/rqbalance.c-			if (cpu_freq <= idle_bottom_freq) {
drivers/cpuquiet/governors/rqbalance.c-			if (cpu_freq >= idle_top_freq) {
drivers/cpuquiet/governors/rqbalance.c-			if (cpu_freq >= idle_top_freq) {
drivers/cpuquiet/governors/rqbalance.c-		if (cpu < nr_cpu_ids) {
drivers/cpuquiet/governors/rqbalance.c-	if (likely(rq_data->update_rate != 0))
drivers/cpuquiet/governors/rqbalance.c-	if (rq_data->nr_run_wq)
drivers/cpuquiet/governors/rqbalance.c-			   msecs_to_jiffies(rq_data->update_rate));
drivers/cpuquiet/governors/rqbalance.c-				   msecs_to_jiffies(rq_data->update_rate));
drivers/cpuquiet/governors/rqbalance.c-	/* now we can force the governor to be idle */
drivers/cpuquiet/governors/rqbalance.c:		queue_delayed_work(
drivers/cpuquiet/governors/rqbalance.c:				queue_delayed_work(
drivers/cpuquiet/governors/rqbalance.c:				queue_delayed_work(
drivers/cpuquiet/governors/rqbalance.c:				queue_delayed_work(
drivers/cpuquiet/governors/rqbalance.c:			queue_delayed_work(rqbalance_wq,
drivers/cpuquiet/governors/rqbalance.c:				queue_delayed_work(rqbalance_wq,
drivers/cpuquiet/governors/rqbalance.c:		queue_delayed_work(rq_data->nr_run_wq, &rq_data->work,
drivers/cpuquiet/governors/rqbalance.c:	queue_delayed_work(rq_data->nr_run_wq, &rq_data->work,
drivers/cpuquiet/governors/rqbalance.c-	return;
drivers/cpuquiet/governors/rqbalance.c-	return;
drivers/cpuquiet/governors/rqbalance.c-				rqbalance_state = DOWN;
drivers/cpuquiet/governors/rqbalance.c-				rqbalance_state = DOWN;
drivers/cpuquiet/governors/rqbalance.c-		rqbalance_state = IDLE;
drivers/cpuquiet/governors/rqbalance.c-	rqbalance_state = IDLE;
drivers/cpuquiet/governors/rqbalance.c-				rqbalance_state = UP;
drivers/cpuquiet/governors/rqbalance.c-				rqbalance_state = UP;
drivers/cpuquiet/governors/rqbalance.c-						 &rqbalance_work, up_delay);
drivers/cpuquiet/governors/rqbalance.c-					&rqbalance_work, up_delay);
drivers/cpuquiet/governors/rqbalance.c-					rqbalance_wq, &rqbalance_work,
drivers/cpuquiet/governors/rqbalance.c-					rqbalance_wq, &rqbalance_work, up_delay);
drivers/cpuquiet/governors/rqbalance.c-					rqbalance_wq, &rqbalance_work, up_delay);
drivers/cpuquiet/governors/rqbalance.c-			rqbalance_wq, &rqbalance_work, up_delay);
drivers/cpuquiet/governors/rqbalance.c-	spinlock_t lock;
drivers/cpuquiet/governors/rqbalance.c-				start_load_timer();
drivers/cpuquiet/governors/rqbalance.c-				start_load_timer();
drivers/cpuquiet/governors/rqbalance.c-				start_load_timer();
drivers/cpuquiet/governors/rqbalance.c-static RQBALANCE_STATE rqbalance_state;
drivers/cpuquiet/governors/rqbalance.c:static struct delayed_work rqbalance_work;
drivers/cpuquiet/governors/rqbalance.c-static struct kobject *rqbalance_kobject;
drivers/cpuquiet/governors/rqbalance.c-static struct workqueue_struct *rqbalance_wq;
drivers/cpuquiet/governors/rqbalance.c-static unsigned int  userspace_suspend_state = 0;
drivers/cpuquiet/governors/rqbalance.c:	struct delayed_work work;
drivers/cpuquiet/governors/rqbalance.c-	struct workqueue_struct *nr_run_wq;
drivers/cpuquiet/governors/rqbalance.c-	uint8_t nr_run_sample_count;
drivers/cpuquiet/governors/rqbalance.c-			up = false;
drivers/crypto/hifn_795x.c-
drivers/crypto/hifn_795x.c-
drivers/crypto/hifn_795x.c-
drivers/crypto/hifn_795x.c-
drivers/crypto/hifn_795x.c-
drivers/crypto/hifn_795x.c-
drivers/crypto/hifn_795x.c-{
drivers/crypto/hifn_795x.c-}
drivers/crypto/hifn_795x.c-	}
drivers/crypto/hifn_795x.c:		cancel_delayed_work_sync(&dev->work);
drivers/crypto/hifn_795x.c-	dprintk("HIFN crypto accelerator card at %s has been "
drivers/crypto/hifn_795x.c-		hifn_unregister_rng(dev);
drivers/crypto/hifn_795x.c-	if (dev) {
drivers/crypto/hifn_795x.c-	INIT_DELAYED_WORK(&dev->work, hifn_work);
drivers/crypto/hifn_795x.c-	int			active, started;
drivers/crypto/hifn_795x.c:	schedule_delayed_work(&dev->work, HZ);
drivers/crypto/hifn_795x.c:	schedule_delayed_work(&dev->work, HZ);
drivers/crypto/hifn_795x.c-static void hifn_work(struct work_struct *work)
drivers/crypto/hifn_795x.c:	struct delayed_work *dw = to_delayed_work(work);
drivers/crypto/hifn_795x.c:	struct delayed_work	work;
drivers/crypto/hifn_795x.c-	struct hifn_device *dev = container_of(dw, struct hifn_device, work);
drivers/crypto/hifn_795x.c-	u32			flags;
drivers/crypto/hifn_795x.c-	unsigned long flags;
drivers/crypto/hifn_795x.c-	unsigned long		reset;
drivers/crypto/hifn_795x.c-	unsigned long		success;
drivers/devfreq/devfreq.c-
drivers/devfreq/devfreq.c-
drivers/devfreq/devfreq.c-{
drivers/devfreq/devfreq.c-}
drivers/devfreq/devfreq.c-}
drivers/devfreq/devfreq.c-}
drivers/devfreq/devfreq.c-	}
drivers/devfreq/devfreq.c-	}
drivers/devfreq/devfreq.c:	cancel_delayed_work_sync(&devfreq->work);
drivers/devfreq/devfreq.c:	cancel_delayed_work_sync(&devfreq->work);
drivers/devfreq/devfreq.c:		cancel_delayed_work_sync(&devfreq->work);
drivers/devfreq/devfreq.c:		cancel_delayed_work_sync(&devfreq->work);
drivers/devfreq/devfreq.c-		dev_err(&devfreq->dev, "dvfs failed with (%d) error\n", err);
drivers/devfreq/devfreq.c-	devfreq->stop_polling = false;
drivers/devfreq/devfreq.c-	devfreq->stop_polling = true;
drivers/devfreq/devfreq.c-EXPORT_SYMBOL(devfreq_monitor_stop);
drivers/devfreq/devfreq.c-EXPORT_SYMBOL(devfreq_monitor_suspend);
drivers/devfreq/devfreq.c-		goto out;
drivers/devfreq/devfreq.c-	if (!cur_delay) {
drivers/devfreq/devfreq.c-	if (cur_delay > new_delay) {
drivers/devfreq/devfreq.c-	/* if current delay is zero, start polling with new delay */
drivers/devfreq/devfreq.c-	if (devfreq->profile->polling_ms)
drivers/devfreq/devfreq.c-	if (devfreq->profile->polling_ms)
drivers/devfreq/devfreq.c-		if (!devfreq->stop_polling)
drivers/devfreq/devfreq.c-	if (!new_delay) {
drivers/devfreq/devfreq.c-	INIT_DEFERRABLE_WORK(&devfreq->work, devfreq_monitor);
drivers/devfreq/devfreq.c-			msecs_to_jiffies(devfreq->profile->polling_ms));
drivers/devfreq/devfreq.c-			msecs_to_jiffies(devfreq->profile->polling_ms));
drivers/devfreq/devfreq.c-			msecs_to_jiffies(devfreq->profile->polling_ms));
drivers/devfreq/devfreq.c-			      msecs_to_jiffies(devfreq->profile->polling_ms));
drivers/devfreq/devfreq.c-				msecs_to_jiffies(devfreq->profile->polling_ms));
drivers/devfreq/devfreq.c-		mutex_lock(&devfreq->lock);
drivers/devfreq/devfreq.c-	mutex_unlock(&devfreq->lock);
drivers/devfreq/devfreq.c-	mutex_unlock(&devfreq->lock);
drivers/devfreq/devfreq.c-		mutex_unlock(&devfreq->lock);
drivers/devfreq/devfreq.c-		mutex_unlock(&devfreq->lock);
drivers/devfreq/devfreq.c:			queue_delayed_work(devfreq_wq, &devfreq->work,
drivers/devfreq/devfreq.c:		queue_delayed_work(devfreq_wq, &devfreq->work,
drivers/devfreq/devfreq.c:		queue_delayed_work(devfreq_wq, &devfreq->work,
drivers/devfreq/devfreq.c:		queue_delayed_work(devfreq_wq, &devfreq->work,
drivers/devfreq/devfreq.c:	queue_delayed_work(devfreq_wq, &devfreq->work,
drivers/devfreq/devfreq.c-		return;
drivers/devfreq/devfreq.c-void devfreq_monitor_stop(struct devfreq *devfreq)
drivers/edac/edac_device.c-
drivers/edac/edac_device.c-
drivers/edac/edac_device.c-{
drivers/edac/edac_device.c-}
drivers/edac/edac_device.c-}
drivers/edac/edac_device.c-	 */
drivers/edac/edac_device.c-	 */
drivers/edac/edac_device.c-				edac_dev->delay);
drivers/edac/edac_device.c-				edac_dev->delay);
drivers/edac/edac_device.c-	else
drivers/edac/edac_device.c-	else
drivers/edac/edac_device.c-	if (edac_dev->poll_msec == 1000)
drivers/edac/edac_device.c-	if (edac_dev->poll_msec == 1000)
drivers/edac/edac_device.c-	if (status == 0) {
drivers/edac/edac_device.c-	int status;
drivers/edac/edac_device.c:		queue_delayed_work(edac_workqueue, &edac_dev->work,
drivers/edac/edac_device.c:		queue_delayed_work(edac_workqueue, &edac_dev->work,
drivers/edac/edac_device.c:		queue_delayed_work(edac_workqueue, &edac_dev->work,
drivers/edac/edac_device.c:		queue_delayed_work(edac_workqueue, &edac_dev->work,
drivers/edac/edac_device.c-				round_jiffies_relative(edac_dev->delay));
drivers/edac/edac_device.c-				round_jiffies_relative(edac_dev->delay));
drivers/edac/edac_device.c-static void edac_device_workq_function(struct work_struct *work_req)
drivers/edac/edac_device.c:	status = cancel_delayed_work(&edac_dev->work);
drivers/edac/edac_device.c:	struct delayed_work *d_work = to_delayed_work(work_req);
drivers/edac/edac_device.c-	struct edac_device_ctl_info *edac_dev = to_edac_device_ctl_work(d_work);
drivers/edac/edac_device.c-		/* workq instance might be running, wait for it */
drivers/edac/edac_mc.c-
drivers/edac/edac_mc.c-
drivers/edac/edac_mc.c-
drivers/edac/edac_mc.c-
drivers/edac/edac_mc.c-
drivers/edac/edac_mc.c-{
drivers/edac/edac_mc.c-}
drivers/edac/edac_mc.c-}
drivers/edac/edac_mc.c-		debugf0("%s() not canceled, flush the queue\n",
drivers/edac/edac_mc.c-	if (status == 0) {
drivers/edac/edac_mc.c-	INIT_DELAYED_WORK(&mci->work, edac_mc_workq_function);
drivers/edac/edac_mc.c-			msecs_to_jiffies(edac_mc_get_poll_msec()));
drivers/edac/edac_mc.c:	queue_delayed_work(edac_workqueue, &mci->work,
drivers/edac/edac_mc.c:	queue_delayed_work(edac_workqueue, &mci->work, msecs_to_jiffies(msec));
drivers/edac/edac_mc.c-	/* Reschedule */
drivers/edac/edac_mc.c-		return;
drivers/edac/edac_mc.c-static void edac_mc_workq_function(struct work_struct *work_req)
drivers/edac/edac_mc.c:	status = cancel_delayed_work(&mci->work);
drivers/edac/edac_mc.c:	struct delayed_work *d_work = to_delayed_work(work_req);
drivers/edac/edac_mc.c-	struct mem_ctl_info *mci = to_edac_mem_ctl_work(d_work);
drivers/edac/edac_pci.c-
drivers/edac/edac_pci.c-
drivers/edac/edac_pci.c-
drivers/edac/edac_pci.c-
drivers/edac/edac_pci.c-{
drivers/edac/edac_pci.c-}
drivers/edac/edac_pci.c-	}
drivers/edac/edac_pci.c-	debugf0("%s()\n", __func__);
drivers/edac/edac_pci.c-		flush_workqueue(edac_workqueue);
drivers/edac/edac_pci.c-	if (status == 0)
drivers/edac/edac_pci.c-	INIT_DELAYED_WORK(&pci->work, edac_pci_workq_function);
drivers/edac/edac_pci.c-	int msec;
drivers/edac/edac_pci.c-			msecs_to_jiffies(edac_pci_get_poll_msec()));
drivers/edac/edac_pci.c:	queue_delayed_work(edac_workqueue, &pci->work,
drivers/edac/edac_pci.c:		queue_delayed_work(edac_workqueue, &pci->work, delay);
drivers/edac/edac_pci.c-		/* Reschedule only if we are in POLL mode */
drivers/edac/edac_pci.c-static void edac_pci_workq_function(struct work_struct *work_req)
drivers/edac/edac_pci.c:	status = cancel_delayed_work(&pci->work);
drivers/edac/edac_pci.c:	struct delayed_work *d_work = to_delayed_work(work_req);
drivers/edac/edac_pci.c-	struct edac_pci_ctl_info *pci = to_edac_pci_ctl_work(d_work);
drivers/edac/i5100_edac.c-
drivers/edac/i5100_edac.c-
drivers/edac/i5100_edac.c-
drivers/edac/i5100_edac.c-
drivers/edac/i5100_edac.c-
drivers/edac/i5100_edac.c-{
drivers/edac/i5100_edac.c-};
drivers/edac/i5100_edac.c-	}
drivers/edac/i5100_edac.c-	}
drivers/edac/i5100_edac.c-	}
drivers/edac/i5100_edac.c-		}
drivers/edac/i5100_edac.c-bail_scrub:
drivers/edac/i5100_edac.c:		cancel_delayed_work(&(priv->i5100_scrubbing));
drivers/edac/i5100_edac.c:	cancel_delayed_work_sync(&(priv->i5100_scrubbing));
drivers/edac/i5100_edac.c:	cancel_delayed_work_sync(&(priv->i5100_scrubbing));
drivers/edac/i5100_edac.c-		dw |= I5100_MC_SCRBEN_MASK;
drivers/edac/i5100_edac.c-		dw &= ~I5100_MC_SCRBEN_MASK;
drivers/edac/i5100_edac.c-	edac_mc_free(mci);
drivers/edac/i5100_edac.c-	} else {
drivers/edac/i5100_edac.c-				      I5100_SCRUB_REFRESH_RATE);
drivers/edac/i5100_edac.c-				      I5100_SCRUB_REFRESH_RATE);
drivers/edac/i5100_edac.c-				      I5100_SCRUB_REFRESH_RATE);
drivers/edac/i5100_edac.c-	if (i5100_mc_scrben(dw)) {
drivers/edac/i5100_edac.c-	int scrub_enable;
drivers/edac/i5100_edac.c-	pci_disable_device(pdev);
drivers/edac/i5100_edac.c-	pci_write_config_dword(priv->mc, I5100_MC, dw);
drivers/edac/i5100_edac.c-		priv->scrub_enable = 0;
drivers/edac/i5100_edac.c-	priv->scrub_enable = 0;
drivers/edac/i5100_edac.c-	priv->scrub_enable = 0;
drivers/edac/i5100_edac.c-		priv->scrub_enable = 1;
drivers/edac/i5100_edac.c-		priv->scrub_enable = 1;
drivers/edac/i5100_edac.c:		schedule_delayed_work(&(priv->i5100_scrubbing),
drivers/edac/i5100_edac.c:		schedule_delayed_work(&(priv->i5100_scrubbing),
drivers/edac/i5100_edac.c:		schedule_delayed_work(&(priv->i5100_scrubbing),
drivers/edac/i5100_edac.c-static void i5100_refresh_scrubbing(struct work_struct *work)
drivers/edac/i5100_edac.c:							    struct delayed_work,
drivers/edac/i5100_edac.c:	struct delayed_work i5100_scrubbing;
drivers/edac/i5100_edac.c:	struct delayed_work *i5100_scrubbing = container_of(work,
drivers/edac/i5100_edac.c-	struct i5100_priv *priv = container_of(i5100_scrubbing,
drivers/edac/i5100_edac.c-	struct pci_dev *ch1mm;	/* device 22 func 0 */
drivers/edac/i5100_edac.c-							    work);
drivers/felica/felica.c-
drivers/felica/felica.c-
drivers/felica/felica.c-
drivers/felica/felica.c-
drivers/felica/felica.c-
drivers/felica/felica.c-
drivers/felica/felica.c-
drivers/felica/felica.c-	
drivers/felica/felica.c-	
drivers/felica/felica.c-	
drivers/felica/felica.c-	
drivers/felica/felica.c-	
drivers/felica/felica.c-	
drivers/felica/felica.c:	cancel_delayed_work(&intu_d->work);
drivers/felica/felica.c:	cancel_delayed_work(&rfs_d->work);
drivers/felica/felica.c-	disable_irq_nosync(gpio_to_irq(felica_varying_gpio_intu));
drivers/felica/felica.c-	disable_irq_nosync(gpio_to_irq(GPIO_PINID_FELICA_INT_REV03));
drivers/felica/felica.c-	disable_irq_nosync(gpio_to_irq(GPIO_PINID_NFC_RFS_POLL));
drivers/felica/felica.c-	felica_i2c_init();
drivers/felica/felica.c-	FELICA_LOG_DEBUG("[MFDD] %s END",__func__);
drivers/felica/felica.c-	FELICA_LOG_DEBUG("[MFDD] %s END", __func__);
drivers/felica/felica.c-	FELICA_LOG_DEBUG("[MFDD] %s END", __func__);
drivers/felica/felica.c-	FELICA_LOG_DEBUG("[MFDD] %s START", __func__);
drivers/felica/felica.c-	FELICA_LOG_DEBUG("[MFDD] %s START", __func__);
drivers/felica/felica.c-#ifdef CONFIG_NFC_FELICA
drivers/felica/felica.c-	if (disable_irq_wake(gpio_to_irq(GPIO_PINID_NFC_RFS_POLL))){
drivers/felica/felica.c-	if(system_rev > 0 && system_rev < 15) {
drivers/felica/felica.c-	int device_status;
drivers/felica/felica.c-	int device_status;
drivers/felica/felica.c-	int handler_done;
drivers/felica/felica.c-	int irq_done;
drivers/felica/felica.c-	int irq_handler_done;
drivers/felica/felica.c-	int read_error;
drivers/felica/felica.c-	int read_error;
drivers/felica/felica.c-	int rsp_done;
drivers/felica/felica.c-	intu_poll_init();
drivers/felica/felica.c-/* IRQ data storage for INT terminal monitoring */
drivers/felica/felica.c-	/* MFC UID registration */
drivers/felica/felica.c-			      msecs_to_jiffies(FELICA_INT_DELAY_TIME));
drivers/felica/felica.c-	rfs_poll_init();
drivers/felica/felica.c:	schedule_delayed_work(&g_intu_d->work, msecs_to_jiffies(10));
drivers/felica/felica.c:	schedule_delayed_work(&g_rfs_d->work, msecs_to_jiffies(10));
drivers/felica/felica.c:	schedule_delayed_work(&intu_d->work, 0);
drivers/felica/felica.c:	schedule_delayed_work(&pgint_irq->work,
drivers/felica/felica.c:	schedule_delayed_work(&pgint_irq->work, msecs_to_jiffies(10));
drivers/felica/felica.c:	schedule_delayed_work(&rfs_d->work, msecs_to_jiffies(RFS_POLL_DELAY));
drivers/felica/felica.c:	struct delayed_work work;
drivers/felica/felica.c:	struct delayed_work work;
drivers/felica/felica.c:	struct delayed_work work;
drivers/felica/felica.c-struct felica_int_irqdata {
drivers/felica/felica.c-	wait_queue_head_t read_wait;
drivers/felica/felica.c-	wait_queue_head_t read_wait;
drivers/firewire/core-card.c-{
drivers/firewire/core-card.c-}
drivers/firewire/core-card.c-				delayed ? DIV_ROUND_UP(HZ, 100) : 0))
drivers/firewire/core-card.c-	fw_card_get(card);
drivers/firewire/core-card.c-	fw_card_get(card);
drivers/firewire/core-card.c-		fw_card_put(card);
drivers/firewire/core-card.c-		fw_card_put(card);
drivers/firewire/core-card.c-			fw_card_put(card);
drivers/firewire/core-card.c-	if (card->reset_jiffies != 0 &&
drivers/firewire/core-card.c:	if (!queue_delayed_work(fw_workqueue, &card->br_work,
drivers/firewire/core-card.c:		if (!queue_delayed_work(fw_workqueue, &card->br_work, 2 * HZ))
drivers/firewire/core-card.c:	if (!schedule_delayed_work(&card->bm_work, delay))
drivers/firewire/core-card.c-		return;
drivers/firewire/core-card.c-	    time_before64(get_jiffies_64(), card->reset_jiffies + 2 * HZ)) {
drivers/firewire/core-card.c-	/* Use an arbitrary short delay to combine multiple reset requests. */
drivers/firewire/core-cdev.c-
drivers/firewire/core-cdev.c-{
drivers/firewire/core-cdev.c-}
drivers/firewire/core-cdev.c:		cancel_delayed_work(&r->work);
drivers/firewire/core-cdev.c-	client_get(r->client);
drivers/firewire/core-cdev.c-		client_put(r->client);
drivers/firewire/core-cdev.c-	enum {ISO_RES_ALLOC, ISO_RES_REALLOC, ISO_RES_DEALLOC,
drivers/firewire/core-cdev.c-	if (free) {
drivers/firewire/core-cdev.c:	if (!queue_delayed_work(fw_workqueue, &r->work, delay))
drivers/firewire/core-cdev.c-	      ISO_RES_ALLOC_ONCE, ISO_RES_DEALLOC_ONCE,} todo;
drivers/firewire/core-cdev.c-		kfree(r->e_alloc);
drivers/firewire/core-cdev.c-		kfree(r->e_dealloc);
drivers/firewire/core-cdev.c-	/* Schedule work and access todo only with client->lock held. */
drivers/firewire/core-cdev.c-	struct client *client;
drivers/firewire/core-cdev.c:	struct delayed_work work;
drivers/firewire/core-device.c-
drivers/firewire/core-device.c-{
drivers/firewire/core-device.c-{
drivers/firewire/core-device.c-}
drivers/firewire/core-device.c-	device->workfn(work);
drivers/firewire/core-device.c:	queue_delayed_work(fw_workqueue, &device->work, delay);
drivers/firewire/core-device.c-static void fw_device_workfn(struct work_struct *work)
drivers/firewire/core-device.c:	struct fw_device *device = container_of(to_delayed_work(work),
drivers/firewire/core-device.c-						struct fw_device, work);
drivers/firewire/core-device.c-				    unsigned long delay)
drivers/firewire/sbp2.c-
drivers/firewire/sbp2.c-
drivers/firewire/sbp2.c-{
drivers/firewire/sbp2.c-{
drivers/firewire/sbp2.c-}
drivers/firewire/sbp2.c-	bool blocked;
drivers/firewire/sbp2.c-	bool has_sdev;
drivers/firewire/sbp2.c:		cancel_delayed_work_sync(&lu->work);
drivers/firewire/sbp2.c-		if (sdev) {
drivers/firewire/sbp2.c-	int retries;
drivers/firewire/sbp2.c-	list_for_each_entry_safe(lu, next, &tgt->lu_list, link) {
drivers/firewire/sbp2.c-	lu->workfn(work);
drivers/firewire/sbp2.c:	queue_delayed_work(fw_workqueue, &lu->work, delay);
drivers/firewire/sbp2.c-		sdev = scsi_device_lookup(shost, 0, 0, sbp2_lun2int(lu->lun));
drivers/firewire/sbp2.c-static void sbp2_lu_workfn(struct work_struct *work)
drivers/firewire/sbp2.c-static void sbp2_queue_work(struct sbp2_logical_unit *lu, unsigned long delay)
drivers/firewire/sbp2.c:	struct delayed_work work;
drivers/firewire/sbp2.c:	struct sbp2_logical_unit *lu = container_of(to_delayed_work(work),
drivers/firewire/sbp2.c-						struct sbp2_logical_unit, work);
drivers/firewire/sbp2.c-	work_func_t workfn;
drivers/gpu/drm/drm_crtc_helper.c-
drivers/gpu/drm/drm_crtc_helper.c-
drivers/gpu/drm/drm_crtc_helper.c-
drivers/gpu/drm/drm_crtc_helper.c-
drivers/gpu/drm/drm_crtc_helper.c-{
drivers/gpu/drm/drm_crtc_helper.c-}
drivers/gpu/drm/drm_crtc_helper.c-}
drivers/gpu/drm/drm_crtc_helper.c-}
drivers/gpu/drm/drm_crtc_helper.c-}
drivers/gpu/drm/drm_crtc_helper.c:	cancel_delayed_work(&dev->mode_config.output_poll_work);
drivers/gpu/drm/drm_crtc_helper.c:	cancel_delayed_work_sync(&dev->mode_config.output_poll_work);
drivers/gpu/drm/drm_crtc_helper.c-	enum drm_connector_status old_status;
drivers/gpu/drm/drm_crtc_helper.c-EXPORT_SYMBOL(drm_helper_hpd_irq_event);
drivers/gpu/drm/drm_crtc_helper.c-EXPORT_SYMBOL(drm_kms_helper_poll_disable);
drivers/gpu/drm/drm_crtc_helper.c-EXPORT_SYMBOL(drm_kms_helper_poll_enable);
drivers/gpu/drm/drm_crtc_helper.c-	if (!dev->mode_config.poll_enabled)
drivers/gpu/drm/drm_crtc_helper.c-	if (drm_kms_helper_poll)
drivers/gpu/drm/drm_crtc_helper.c-	if (poll)
drivers/gpu/drm/drm_crtc_helper.c-	if (repoll)
drivers/gpu/drm/drm_crtc_helper.c-	/* kill timer and schedule immediate execution, this doesn't block */
drivers/gpu/drm/drm_crtc_helper.c-		return;
drivers/gpu/drm/drm_crtc_helper.c:		schedule_delayed_work(delayed_work, DRM_OUTPUT_POLL_PERIOD);
drivers/gpu/drm/drm_crtc_helper.c:		schedule_delayed_work(&dev->mode_config.output_poll_work, 0);
drivers/gpu/drm/drm_crtc_helper.c:		schedule_delayed_work(&dev->mode_config.output_poll_work, DRM_OUTPUT_POLL_PERIOD);
drivers/gpu/drm/drm_crtc_helper.c-static void output_poll_execute(struct work_struct *work)
drivers/gpu/drm/drm_crtc_helper.c:	struct delayed_work *delayed_work = to_delayed_work(work);
drivers/gpu/drm/drm_crtc_helper.c-	struct drm_connector *connector;
drivers/gpu/drm/drm_crtc_helper.c:	struct drm_device *dev = container_of(delayed_work, struct drm_device, mode_config.output_poll_work);
drivers/gpu/drm/i915/i915_gem.c-
drivers/gpu/drm/i915/i915_gem.c-
drivers/gpu/drm/i915/i915_gem.c-
drivers/gpu/drm/i915/i915_gem.c-
drivers/gpu/drm/i915/i915_gem.c-
drivers/gpu/drm/i915/i915_gem.c-
drivers/gpu/drm/i915/i915_gem.c-	}
drivers/gpu/drm/i915/i915_gem.c-	}
drivers/gpu/drm/i915/i915_gem.c-		}
drivers/gpu/drm/i915/i915_gem.c:	cancel_delayed_work_sync(&dev_priv->mm.retire_work);
drivers/gpu/drm/i915/i915_gem.c-	/* Cancel the retire work handler, which should be idle now. */
drivers/gpu/drm/i915/i915_gem.c-	/* Come back later if the device is busy... */
drivers/gpu/drm/i915/i915_gem.c-					   &dev_priv->mm.retire_work, HZ);
drivers/gpu/drm/i915/i915_gem.c-	if (!dev_priv->mm.suspended && !idle)
drivers/gpu/drm/i915/i915_gem.c-	if (!mutex_trylock(&dev->struct_mutex)) {
drivers/gpu/drm/i915/i915_gem.c-	if (ret == 0)
drivers/gpu/drm/i915/i915_gem.c-		if (was_empty)
drivers/gpu/drm/i915/i915_gem.c-	mutex_unlock(&dev->struct_mutex);
drivers/gpu/drm/i915/i915_gem.c:			queue_delayed_work(dev_priv->wq,
drivers/gpu/drm/i915/i915_gem.c:		queue_delayed_work(dev_priv->wq, &dev_priv->mm.retire_work, 0);
drivers/gpu/drm/i915/i915_gem.c:		queue_delayed_work(dev_priv->wq, &dev_priv->mm.retire_work, HZ);
drivers/gpu/drm/i915/i915_gem.c:		queue_delayed_work(dev_priv->wq, &dev_priv->mm.retire_work, HZ);
drivers/gpu/drm/i915/i915_gem.c-		return;
drivers/gpu/drm/i915/i915_gem.c-	return 0;
drivers/gpu/drm/i915/i915_gem.c-	return ret;
drivers/gpu/drm/i915/intel_display.c-
drivers/gpu/drm/i915/intel_display.c-{
drivers/gpu/drm/i915/intel_display.c-}
drivers/gpu/drm/i915/intel_display.c-	 */
drivers/gpu/drm/i915/intel_display.c-	 */
drivers/gpu/drm/i915/intel_display.c:		container_of(to_delayed_work(__work),
drivers/gpu/drm/i915/intel_display.c-	 * entirely asynchronously.
drivers/gpu/drm/i915/intel_display.c:	if (cancel_delayed_work(&dev_priv->fbc_work->work))
drivers/gpu/drm/i915/intel_display.c-		kfree(dev_priv->fbc_work);
drivers/gpu/drm/i915/intel_display.c:	schedule_delayed_work(&work->work, msecs_to_jiffies(50));
drivers/gpu/drm/i915/intel_display.c-	struct drm_device *dev = work->crtc->dev;
drivers/gpu/drm/i915/intel_display.c-			     struct intel_fbc_work, work);
drivers/gpu/drm/i915/intel_display.c-	struct intel_fbc_work *work =
drivers/gpu/drm/i915/intel_display.c-		/* tasklet was killed before being run, clean up */
drivers/gpu/drm/i915/intel_display.c-	 * waiting synchronously upon the vblank.
drivers/gpu/drm/i915/intel_dp.c-{
drivers/gpu/drm/i915/intel_dp.c-};
drivers/gpu/drm/i915/intel_dp.c-	}
drivers/gpu/drm/i915/intel_dp.c-	}
drivers/gpu/drm/i915/intel_dp.c-		 */
drivers/gpu/drm/i915/intel_dp.c-	bool want_panel_vdd;
drivers/gpu/drm/i915/intel_dp.c:		cancel_delayed_work_sync(&intel_dp->panel_vdd_work);
drivers/gpu/drm/i915/intel_dp.c-	drm_encoder_cleanup(encoder);
drivers/gpu/drm/i915/intel_dp.c-	if (is_edp(intel_dp)) {
drivers/gpu/drm/i915/intel_dp.c-	int backlight_off_delay;
drivers/gpu/drm/i915/intel_dp.c-		ironlake_panel_vdd_off_sync(intel_dp);
drivers/gpu/drm/i915/intel_dp.c-				      msecs_to_jiffies(intel_dp->panel_power_cycle_delay * 5));
drivers/gpu/drm/i915/intel_dp.c:		schedule_delayed_work(&intel_dp->panel_vdd_work,
drivers/gpu/drm/i915/intel_dp.c-static void ironlake_panel_vdd_work(struct work_struct *__work)
drivers/gpu/drm/i915/intel_dp.c:	struct delayed_work panel_vdd_work;
drivers/gpu/drm/i915/intel_dp.c-	struct drm_device *dev = intel_dp->base.base.dev;
drivers/gpu/drm/i915/intel_dp.c-	struct drm_display_mode *panel_fixed_mode;  /* for eDP */
drivers/gpu/drm/i915/intel_dp.c:	struct intel_dp *intel_dp = container_of(to_delayed_work(__work),
drivers/gpu/drm/i915/intel_dp.c-						 struct intel_dp, panel_vdd_work);
drivers/gpu/drm/i915/intel_dp.c-		 * to keep the panel power up across a sequence of operations
drivers/gpu/drm/radeon/radeon_pm.c-
drivers/gpu/drm/radeon/radeon_pm.c-
drivers/gpu/drm/radeon/radeon_pm.c-
drivers/gpu/drm/radeon/radeon_pm.c-
drivers/gpu/drm/radeon/radeon_pm.c-
drivers/gpu/drm/radeon/radeon_pm.c-
drivers/gpu/drm/radeon/radeon_pm.c-
drivers/gpu/drm/radeon/radeon_pm.c-
drivers/gpu/drm/radeon/radeon_pm.c-
drivers/gpu/drm/radeon/radeon_pm.c-
drivers/gpu/drm/radeon/radeon_pm.c-}
drivers/gpu/drm/radeon/radeon_pm.c-}
drivers/gpu/drm/radeon/radeon_pm.c-	}
drivers/gpu/drm/radeon/radeon_pm.c-	}
drivers/gpu/drm/radeon/radeon_pm.c-		}
drivers/gpu/drm/radeon/radeon_pm.c:					cancel_delayed_work(&rdev->pm.dynpm_idle_work);
drivers/gpu/drm/radeon/radeon_pm.c:					cancel_delayed_work(&rdev->pm.dynpm_idle_work);
drivers/gpu/drm/radeon/radeon_pm.c:	cancel_delayed_work_sync(&rdev->pm.dynpm_idle_work);
drivers/gpu/drm/radeon/radeon_pm.c:		cancel_delayed_work_sync(&rdev->pm.dynpm_idle_work);
drivers/gpu/drm/radeon/radeon_pm.c:		cancel_delayed_work_sync(&rdev->pm.dynpm_idle_work);
drivers/gpu/drm/radeon/radeon_pm.c-		count = -EINVAL;
drivers/gpu/drm/radeon/radeon_pm.c-		device_remove_file(rdev->dev, &dev_attr_power_profile);
drivers/gpu/drm/radeon/radeon_pm.c-					DRM_DEBUG_DRIVER("radeon: dynamic power management activated\n");
drivers/gpu/drm/radeon/radeon_pm.c-	} else {
drivers/gpu/drm/radeon/radeon_pm.c-			} else { /* count == 0 */
drivers/gpu/drm/radeon/radeon_pm.c-				} else if (rdev->pm.dynpm_state == DYNPM_STATE_PAUSED) {
drivers/gpu/drm/radeon/radeon_pm.c-			if (rdev->pm.active_crtc_count > 1) {
drivers/gpu/drm/radeon/radeon_pm.c-				if (rdev->pm.dynpm_state == DYNPM_STATE_ACTIVE) {
drivers/gpu/drm/radeon/radeon_pm.c-	if (rdev->pm.dynpm_state == DYNPM_STATE_ACTIVE) {
drivers/gpu/drm/radeon/radeon_pm.c-				if (rdev->pm.dynpm_state != DYNPM_STATE_MINIMUM) {
drivers/gpu/drm/radeon/radeon_pm.c-				      msecs_to_jiffies(RADEON_IDLE_LOOP_MS));
drivers/gpu/drm/radeon/radeon_pm.c-				      msecs_to_jiffies(RADEON_IDLE_LOOP_MS));
drivers/gpu/drm/radeon/radeon_pm.c-							      msecs_to_jiffies(RADEON_IDLE_LOOP_MS));
drivers/gpu/drm/radeon/radeon_pm.c-							      msecs_to_jiffies(RADEON_IDLE_LOOP_MS));
drivers/gpu/drm/radeon/radeon_pm.c-	mutex_lock(&rdev->pm.mutex);
drivers/gpu/drm/radeon/radeon_pm.c-	mutex_unlock(&rdev->pm.mutex);
drivers/gpu/drm/radeon/radeon_pm.c-	mutex_unlock(&rdev->pm.mutex);
drivers/gpu/drm/radeon/radeon_pm.c-		mutex_unlock(&rdev->pm.mutex);
drivers/gpu/drm/radeon/radeon_pm.c-		mutex_unlock(&rdev->pm.mutex);
drivers/gpu/drm/radeon/radeon_pm.c-				pm.dynpm_idle_work.work);
drivers/gpu/drm/radeon/radeon_pm.c-					radeon_pm_set_clocks(rdev);
drivers/gpu/drm/radeon/radeon_pm.c-					rdev->pm.dynpm_state = DYNPM_STATE_ACTIVE;
drivers/gpu/drm/radeon/radeon_pm.c-		rdev->pm.dynpm_state = DYNPM_STATE_ACTIVE;
drivers/gpu/drm/radeon/radeon_pm.c-					rdev->pm.dynpm_state = DYNPM_STATE_MINIMUM;
drivers/gpu/drm/radeon/radeon_pm.c-					rdev->pm.dynpm_state = DYNPM_STATE_PAUSED;
drivers/gpu/drm/radeon/radeon_pm.c-	    && rdev->pm.dynpm_state == DYNPM_STATE_SUSPENDED) {
drivers/gpu/drm/radeon/radeon_pm.c-		rdev->pm.pm_method = PM_METHOD_PROFILE;
drivers/gpu/drm/radeon/radeon_pm.c:	resched = ttm_bo_lock_delayed_workqueue(&rdev->mman.bdev);
drivers/gpu/drm/radeon/radeon_pm.c:		schedule_delayed_work(&rdev->pm.dynpm_idle_work,
drivers/gpu/drm/radeon/radeon_pm.c:		schedule_delayed_work(&rdev->pm.dynpm_idle_work,
drivers/gpu/drm/radeon/radeon_pm.c:					schedule_delayed_work(&rdev->pm.dynpm_idle_work,
drivers/gpu/drm/radeon/radeon_pm.c:					schedule_delayed_work(&rdev->pm.dynpm_idle_work,
drivers/gpu/drm/radeon/radeon_pm.c:	ttm_bo_unlock_delayed_workqueue(&rdev->mman.bdev, resched);
drivers/gpu/drm/ttm/ttm_bo.c-
drivers/gpu/drm/ttm/ttm_bo.c-
drivers/gpu/drm/ttm/ttm_bo.c-
drivers/gpu/drm/ttm/ttm_bo.c-
drivers/gpu/drm/ttm/ttm_bo.c-
drivers/gpu/drm/ttm/ttm_bo.c-
drivers/gpu/drm/ttm/ttm_bo.c-
drivers/gpu/drm/ttm/ttm_bo.c-
drivers/gpu/drm/ttm/ttm_bo.c-{
drivers/gpu/drm/ttm/ttm_bo.c-{
drivers/gpu/drm/ttm/ttm_bo.c-{
drivers/gpu/drm/ttm/ttm_bo.c-}
drivers/gpu/drm/ttm/ttm_bo.c-}
drivers/gpu/drm/ttm/ttm_bo.c-}
drivers/gpu/drm/ttm/ttm_bo.c-}
drivers/gpu/drm/ttm/ttm_bo.c-	}
drivers/gpu/drm/ttm/ttm_bo.c-	}
drivers/gpu/drm/ttm/ttm_bo.c-	bdev->nice_mode = true;
drivers/gpu/drm/ttm/ttm_bo.c:	cancel_delayed_work_sync(&bdev->wq);
drivers/gpu/drm/ttm/ttm_bo.c-		driver->sync_obj_unref(&sync_obj);
drivers/gpu/drm/ttm/ttm_bo.c:EXPORT_SYMBOL(ttm_bo_lock_delayed_workqueue);
drivers/gpu/drm/ttm/ttm_bo.c:EXPORT_SYMBOL(ttm_bo_unlock_delayed_workqueue);
drivers/gpu/drm/ttm/ttm_bo.c-EXPORT_SYMBOL(ttm_bo_unref);
drivers/gpu/drm/ttm/ttm_bo.c-		goto out_no_addr_mm;
drivers/gpu/drm/ttm/ttm_bo.c-			      ((HZ / 100) < 1) ? 1 : HZ / 100);
drivers/gpu/drm/ttm/ttm_bo.c-				      ((HZ / 100) < 1) ? 1 : HZ / 100);
drivers/gpu/drm/ttm/ttm_bo.c-				      ((HZ / 100) < 1) ? 1 : HZ / 100);
drivers/gpu/drm/ttm/ttm_bo.c-	if (resched)
drivers/gpu/drm/ttm/ttm_bo.c-	if (ttm_bo_delayed_delete(bdev, false)) {
drivers/gpu/drm/ttm/ttm_bo.c:	INIT_DELAYED_WORK(&bdev->wq, ttm_bo_delayed_workqueue);
drivers/gpu/drm/ttm/ttm_bo.c-	INIT_LIST_HEAD(&bdev->ddestroy);
drivers/gpu/drm/ttm/ttm_bo.c:int ttm_bo_lock_delayed_workqueue(struct ttm_bo_device *bdev)
drivers/gpu/drm/ttm/ttm_bo.c-	mutex_unlock(&glob->device_list_mutex);
drivers/gpu/drm/ttm/ttm_bo.c:	return cancel_delayed_work_sync(&bdev->wq);
drivers/gpu/drm/ttm/ttm_bo.c:	schedule_delayed_work(&bdev->wq,
drivers/gpu/drm/ttm/ttm_bo.c:		schedule_delayed_work(&bdev->wq,
drivers/gpu/drm/ttm/ttm_bo.c:		schedule_delayed_work(&bdev->wq,
drivers/gpu/drm/ttm/ttm_bo.c-static int ttm_bo_evict(struct ttm_buffer_object *bo, bool interruptible,
drivers/gpu/drm/ttm/ttm_bo.c:static void ttm_bo_delayed_workqueue(struct work_struct *work)
drivers/gpu/drm/ttm/ttm_bo.c-	struct ttm_bo_device *bdev =
drivers/gpu/drm/ttm/ttm_bo.c:void ttm_bo_unlock_delayed_workqueue(struct ttm_bo_device *bdev, int resched)
drivers/gpu/drm/ttm/ttm_bo.c-	while (ttm_bo_delayed_delete(bdev, true))
drivers/gpu/drm/udl/udl_main.c-	 */
drivers/gpu/drm/udl/udl_main.c-	else
drivers/gpu/drm/udl/udl_main.c-#endif
drivers/gpu/drm/udl/udl_main.c-	if (fb_defio)
drivers/gpu/drm/udl/udl_main.c:		schedule_delayed_work(&unode->release_urb_work, 0);
drivers/gpu/drm/vmwgfx/vmwgfx_fb.c-
drivers/gpu/drm/vmwgfx/vmwgfx_fb.c-
drivers/gpu/drm/vmwgfx/vmwgfx_fb.c-
drivers/gpu/drm/vmwgfx/vmwgfx_fb.c-	} else {
drivers/gpu/drm/vmwgfx/vmwgfx_fb.c:	flush_delayed_work(&info->deferred_work);
drivers/gpu/drm/vmwgfx/vmwgfx_fb.c-		if (par->dirty.active)
drivers/gpu/drm/vmwgfx/vmwgfx_fb.c-	/* If there already was stuff dirty we wont
drivers/gpu/drm/vmwgfx/vmwgfx_fb.c-		if (x1 < par->dirty.x1)
drivers/gpu/drm/vmwgfx/vmwgfx_fb.c-	par->bo_ptr = NULL;
drivers/gpu/drm/vmwgfx/vmwgfx_fb.c-	return 0;
drivers/gpu/drm/vmwgfx/vmwgfx_fb.c-	 * schedule a new work, so lets do it now */
drivers/gpu/drm/vmwgfx/vmwgfx_fb.c:	schedule_delayed_work(&info->deferred_work, 0);
drivers/gpu/drm/vmwgfx/vmwgfx_fb.c:			schedule_delayed_work(&info->deferred_work, VMW_DIRTY_DELAY);
drivers/gpu/drm/vmwgfx/vmwgfx_fb.c-	spin_unlock_irqrestore(&par->dirty.lock, flags);
drivers/gpu/drm/vmwgfx/vmwgfx_fb.c-		 * we share the work with the defio system */
drivers/hid/hid-picolcd.c-
drivers/hid/hid-picolcd.c-
drivers/hid/hid-picolcd.c-
drivers/hid/hid-picolcd.c-
drivers/hid/hid-picolcd.c-
drivers/hid/hid-picolcd.c-
drivers/hid/hid-picolcd.c-
drivers/hid/hid-picolcd.c-
drivers/hid/hid-picolcd.c-
drivers/hid/hid-picolcd.c-}
drivers/hid/hid-picolcd.c-}
drivers/hid/hid-picolcd.c-}
drivers/hid/hid-picolcd.c-}
drivers/hid/hid-picolcd.c-	data->fb_force = 1;
drivers/hid/hid-picolcd.c-#endif /* CONFIG_HID_PICOLCD_FB */
drivers/hid/hid-picolcd.c-	if (data->fb_info)
drivers/hid/hid-picolcd.c-	if (data->fb_info)
drivers/hid/hid-picolcd.c-#ifdef CONFIG_HID_PICOLCD_FB
drivers/hid/hid-picolcd.c-	if (ret >= 0)
drivers/hid/hid-picolcd.c-	ret = fb_sys_write(info, buf, count, ppos);
drivers/hid/hid-picolcd.c-	return 0;
drivers/hid/hid-picolcd.c-	return 0;
drivers/hid/hid-picolcd.c-	return ret;
drivers/hid/hid-picolcd.c:		schedule_delayed_work(&data->fb_info->deferred_work, 0);
drivers/hid/hid-picolcd.c:		schedule_delayed_work(&data->fb_info->deferred_work, 0);
drivers/hid/hid-picolcd.c:		schedule_delayed_work(&info->deferred_work, 0);
drivers/hid/hid-picolcd.c:	schedule_delayed_work(&info->deferred_work, 0);
drivers/hid/hid-picolcd.c:	schedule_delayed_work(&info->deferred_work, 0);
drivers/hid/hid-picolcd.c:	schedule_delayed_work(&info->deferred_work, 0);
drivers/hid/hid-picolcd.c:	schedule_delayed_work(&info->deferred_work, 0);
drivers/hid/hid-picolcd.c-	/* schedule first output of framebuffer */
drivers/hid/hid-picolcd.c-	/* schedule first output of framebuffer */
drivers/hid/hid-picolcd.c-	sys_copyarea(info, area);
drivers/hid/hid-picolcd.c-	sys_fillrect(info, rect);
drivers/hid/hid-picolcd.c-	sys_imageblit(info, image);
drivers/hv/hv_kvp.c-
drivers/hv/hv_kvp.c-{
drivers/hv/hv_kvp.c-}
drivers/hv/hv_kvp.c-		 */
drivers/hv/hv_kvp.c-			 */
drivers/hv/hv_kvp.c:	cancel_delayed_work_sync(&kvp_work);
drivers/hv/hv_kvp.c-	cancel_work_sync(&kvp_sendkey_work);
drivers/hv/hv_kvp.c-	cn_del_callback(&kvp_id);
drivers/hv/hv_kvp.c-					 data->data.value,
drivers/hv/hv_kvp.c:		if (cancel_delayed_work_sync(&kvp_work))
drivers/hv/hv_kvp.c-			kvp_respond_to_host(data->data.key,
drivers/hv/hv_kvp.c-			return;
drivers/hv/hv_kvp.c:			schedule_delayed_work(&kvp_work, 5*HZ);
drivers/hv/hv_kvp.c-			schedule_work(&kvp_sendkey_work);
drivers/hv/hv_kvp.c-		 * to the host. But first, cancel the timeout.
drivers/infiniband/core/addr.c-
drivers/infiniband/core/addr.c-
drivers/infiniband/core/addr.c-}
drivers/infiniband/core/addr.c-		delay = 1;
drivers/infiniband/core/addr.c:	queue_delayed_work(addr_wq, &work, delay);
drivers/infiniband/core/cm.c-
drivers/infiniband/core/cm.c-
drivers/infiniband/core/cm.c-
drivers/infiniband/core/cm.c-}
drivers/infiniband/core/cm.c:		cancel_delayed_work(&timewait_info->work.work);
drivers/infiniband/core/cm.c-	cm_id_priv->id.state = IB_CM_TIMEWAIT;
drivers/infiniband/core/cm.c-	cm_id_priv->timewait_info = NULL;
drivers/infiniband/core/cm.c-	list_for_each_entry(timewait_info, &cm.timewait_list, list)
drivers/infiniband/core/cm.c-			   msecs_to_jiffies(wait_time));
drivers/infiniband/core/cm.c-out:
drivers/infiniband/core/cm.c:	queue_delayed_work(cm.wq, &cm_id_priv->timewait_info->work.work,
drivers/infiniband/core/cm.c:	queue_delayed_work(cm.wq, &work->work, 0);
drivers/infiniband/core/cm.c:	queue_delayed_work(cm.wq, &work->work, 0);
drivers/infiniband/core/cm.c-	return ret;
drivers/infiniband/core/cm.c-	spin_lock_irq(&cm.lock);
drivers/infiniband/core/cm.c-	spin_unlock_irq(&cm.lock);
drivers/infiniband/core/cm.c-	struct cm_port *port;
drivers/infiniband/core/cm.c-struct cm_work {
drivers/infiniband/core/cm.c:	struct delayed_work work;
drivers/infiniband/core/cm.c-	struct list_head list;
drivers/infiniband/core/cm.c-	wait_time = cm_convert_to_ms(cm_id_priv->av.timeout);
drivers/infiniband/core/cm.c-	work->cm_event.event = IB_CM_USER_ESTABLISHED;
drivers/infiniband/core/cm.c-	work->mad_recv_wc = mad_recv_wc;
drivers/infiniband/core/cm.c-	work->mad_recv_wc = NULL;
drivers/infiniband/core/cm.c-	work->port = port;
drivers/infiniband/core/mad.c-
drivers/infiniband/core/mad.c-
drivers/infiniband/core/mad.c-}
drivers/infiniband/core/mad.c-		}
drivers/infiniband/core/mad.c:	cancel_delayed_work(&mad_agent_priv->timed_work);
drivers/infiniband/core/mad.c:		cancel_delayed_work(&mad_agent_priv->timed_work);
drivers/infiniband/core/mad.c-	cancel_mads(mad_agent_priv);
drivers/infiniband/core/mad.c-				delay = 1;
drivers/infiniband/core/mad.c-				delay = 1;
drivers/infiniband/core/mad.c-	} else {
drivers/infiniband/core/mad.c-	if (list_empty(&mad_agent_priv->wait_list)) {
drivers/infiniband/core/mad.c-			if ((long)delay <= 0)
drivers/infiniband/core/mad.c-			if ((long)delay <= 0)
drivers/infiniband/core/mad.c-	if (mad_agent_priv->wait_list.next == &mad_send_wr->agent_list)
drivers/infiniband/core/mad.c-				 &mad_agent_priv->timed_work, delay);
drivers/infiniband/core/mad.c-					   &mad_agent_priv->timed_work, delay);
drivers/infiniband/core/mad.c-					 &mad_agent_priv->timed_work, delay);
drivers/infiniband/core/mad.c-		mad_send_wr = list_entry(mad_agent_priv->wait_list.next,
drivers/infiniband/core/mad.c:		mod_delayed_work(mad_agent_priv->qp_info->port_priv->wq,
drivers/infiniband/core/mad.c:			mod_delayed_work(mad_agent_priv->qp_info->port_priv->wq,
drivers/infiniband/core/mad.c-	port_priv = mad_agent_priv->qp_info->port_priv;
drivers/infiniband/core/mad.c-					   port_priv->wq,
drivers/infiniband/core/mad.c:			queue_delayed_work(mad_agent_priv->qp_info->
drivers/infiniband/core/mad.c-	/* Reschedule a work item if we have a shorter timeout */
drivers/infiniband/core/mad.c-	spin_lock_irqsave(&port_priv->reg_lock, flags);
drivers/infiniband/core/mad_rmpp.c-
drivers/infiniband/core/mad_rmpp.c-
drivers/infiniband/core/mad_rmpp.c-
drivers/infiniband/core/mad_rmpp.c-	}
drivers/infiniband/core/mad_rmpp.c-	/* 10 seconds until we can find the packet lifetime */
drivers/infiniband/core/mad_rmpp.c-		/* 40 seconds until we can find the packet lifetimes */
drivers/infiniband/core/mad_rmpp.c-	ack_recv(rmpp_recv, rmpp_recv->rmpp_wc);
drivers/infiniband/core/mad_rmpp.c:		cancel_delayed_work(&rmpp_recv->cleanup_work);
drivers/infiniband/core/mad_rmpp.c:		cancel_delayed_work(&rmpp_recv->timeout_work);
drivers/infiniband/core/mad_rmpp.c:		cancel_delayed_work(&rmpp_recv->timeout_work);
drivers/infiniband/core/mad_rmpp.c-	enum rmpp_state state;
drivers/infiniband/core/mad_rmpp.c-	if (rmpp_recv->seg_num > 1)
drivers/infiniband/core/mad_rmpp.c-	list_for_each_entry(rmpp_recv, &agent->rmpp_list, list) {
drivers/infiniband/core/mad_rmpp.c-				   msecs_to_jiffies(40000));
drivers/infiniband/core/mad_rmpp.c:		queue_delayed_work(agent->qp_info->port_priv->wq,
drivers/infiniband/core/mad_rmpp.c:	queue_delayed_work(rmpp_recv->agent->qp_info->port_priv->wq,
drivers/infiniband/core/mad_rmpp.c-	return rmpp_wc;
drivers/infiniband/core/mad_rmpp.c-			   &rmpp_recv->cleanup_work, msecs_to_jiffies(10000));
drivers/infiniband/core/mad_rmpp.c-				   &rmpp_recv->timeout_work,
drivers/infiniband/core/mad_rmpp.c-	rmpp_wc->mad_len = get_mad_len(rmpp_recv);
drivers/infiniband/core/mad_rmpp.c-	rmpp_wc = rmpp_recv->rmpp_wc;
drivers/infiniband/core/mad_rmpp.c-		spin_unlock_irqrestore(&agent->lock, flags);
drivers/infiniband/core/mad_rmpp.c-	struct completion comp;
drivers/infiniband/core/mad_rmpp.c:	struct delayed_work cleanup_work;
drivers/infiniband/core/mad_rmpp.c:	struct delayed_work timeout_work;
drivers/infiniband/core/mad_rmpp.c-	struct ib_mad_agent_private *agent;
drivers/infiniband/core/mad_rmpp.c-	struct list_head list;
drivers/infiniband/hw/cxgb3/iwch.c-		 */
drivers/infiniband/hw/cxgb3/iwch.c-		break;
drivers/infiniband/hw/cxgb3/iwch.c:			cancel_delayed_work_sync(&dev->db_drop_task);
drivers/infiniband/hw/cxgb3/iwch.c-		 * delay is between 1000-2023 usecs.
drivers/infiniband/hw/cxgb3/iwch.c-			dev->rdev.flags = CXIO_ERROR_FATAL;
drivers/infiniband/hw/cxgb3/iwch.c-			iwch_unregister_device(dev);
drivers/infiniband/hw/cxgb3/iwch.c-			list_del(&dev->entry);
drivers/infiniband/hw/cxgb3/iwch.c:		schedule_delayed_work(&rnicp->db_drop_task,
drivers/infiniband/hw/cxgb3/iwch.c-			synchronize_net();
drivers/infiniband/hw/cxgb3/iwch.c-			usecs_to_jiffies(delay));
drivers/infiniband/hw/nes/nes_hw.c-	}
drivers/infiniband/hw/nes/nes_hw.c-		}
drivers/infiniband/hw/nes/nes_hw.c-	else
drivers/infiniband/hw/nes/nes_hw.c-		if (nesadapter->phy_type[mac_index] == NES_PHY_TYPE_SFP_D) {
drivers/infiniband/hw/nes/nes_hw.c-	if (nesdev->link_recheck++ < NES_LINK_RECHECK_MAX)
drivers/infiniband/hw/nes/nes_hw.c:			mod_delayed_work(system_wq, &nesdev->work,
drivers/infiniband/hw/nes/nes_hw.c-		nesdev->link_recheck = 0;
drivers/infiniband/hw/nes/nes_hw.c-			nesdev->link_recheck = 1;
drivers/infiniband/hw/nes/nes_hw.c-					 NES_LINK_RECHECK_DELAY);
drivers/infiniband/hw/nes/nes_hw.c:		schedule_delayed_work(&nesdev->work, NES_LINK_RECHECK_DELAY);
drivers/infiniband/hw/nes/nes_nic.c-	}
drivers/infiniband/hw/nes/nes_nic.c-	if (nesdev->nesadapter->phy_type[nesdev->mac_index] == NES_PHY_TYPE_SFP_D) {
drivers/infiniband/hw/nes/nes_nic.c:		mod_delayed_work(system_wq, &nesdev->work,
drivers/infiniband/hw/nes/nes_nic.c-		nesdev->link_recheck = 1;
drivers/infiniband/hw/nes/nes_nic.c-				 NES_LINK_RECHECK_DELAY);
drivers/infiniband/hw/qib/qib_iba7220.c-
drivers/infiniband/hw/qib/qib_iba7220.c-}
drivers/infiniband/hw/qib/qib_iba7220.c-	/* 2 msec is minimum length of a poll cycle */
drivers/infiniband/hw/qib/qib_iba7220.c:	cancel_delayed_work_sync(&ppd->cpspec->autoneg_work);
drivers/infiniband/hw/qib/qib_iba7220.c-			   msecs_to_jiffies(2));
drivers/infiniband/hw/qib/qib_iba7220.c:	queue_delayed_work(ib_wq, &ppd->cpspec->autoneg_work,
drivers/infiniband/hw/qib/qib_iba7220.c-	shutdown_7220_relock_poll(ppd->dd);
drivers/infiniband/hw/qib/qib_iba7220.c-	spin_unlock_irqrestore(&ppd->lflags_lock, flags);
drivers/infiniband/hw/qib/qib_iba7220.c-	toggle_7220_rclkrls(ppd->dd);
drivers/infiniband/hw/qib/qib_iba7220.c-	wake_up(&ppd->cpspec->autoneg_wait);
drivers/infiniband/hw/qib/qib_iba7322.c-
drivers/infiniband/hw/qib/qib_iba7322.c-}
drivers/infiniband/hw/qib/qib_iba7322.c-}
drivers/infiniband/hw/qib/qib_iba7322.c-	/*
drivers/infiniband/hw/qib/qib_iba7322.c-		}
drivers/infiniband/hw/qib/qib_iba7322.c-	/* 2 msec is minimum length of a poll cycle */
drivers/infiniband/hw/qib/qib_iba7322.c:			cancel_delayed_work(&ppd->cpspec->ipg_work);
drivers/infiniband/hw/qib/qib_iba7322.c:	cancel_delayed_work_sync(&ppd->cpspec->autoneg_work);
drivers/infiniband/hw/qib/qib_iba7322.c:		cancel_delayed_work_sync(&ppd->cpspec->ipg_work);
drivers/infiniband/hw/qib/qib_iba7322.c-	delay = 2 << ppd->cpspec->ipg_tries;
drivers/infiniband/hw/qib/qib_iba7322.c-		if (ppd->dd->cspec->r1) {
drivers/infiniband/hw/qib/qib_iba7322.c-	if (ppd->dd->cspec->r1)
drivers/infiniband/hw/qib/qib_iba7322.c-			   msecs_to_jiffies(2));
drivers/infiniband/hw/qib/qib_iba7322.c-			   msecs_to_jiffies(delay));
drivers/infiniband/hw/qib/qib_iba7322.c-	ppd->cpspec->chase_end = 0;
drivers/infiniband/hw/qib/qib_iba7322.c-			ppd->cpspec->ipg_tries = 0;
drivers/infiniband/hw/qib/qib_iba7322.c-	qib_7322_mini_pcs_reset(ppd);
drivers/infiniband/hw/qib/qib_iba7322.c:	queue_delayed_work(ib_wq, &ppd->cpspec->autoneg_work,
drivers/infiniband/hw/qib/qib_iba7322.c:	queue_delayed_work(ib_wq, &ppd->cpspec->ipg_work,
drivers/infiniband/hw/qib/qib_iba7322.c-retry:
drivers/infiniband/hw/qib/qib_iba7322.c-	spin_unlock_irqrestore(&ppd->lflags_lock, flags);
drivers/infiniband/hw/qib/qib_iba7322.c:	struct delayed_work autoneg_work;
drivers/infiniband/hw/qib/qib_iba7322.c:	struct delayed_work ipg_work;
drivers/infiniband/hw/qib/qib_iba7322.c-	struct qib_pportdata *ppd;
drivers/infiniband/hw/qib/qib_iba7322.c-	struct timer_list chase_timer;
drivers/infiniband/hw/qib/qib_iba7322.c-		/* val is the port number of the switch we are connected to. */
drivers/infiniband/hw/qib/qib_iba7322.c-	wait_queue_head_t autoneg_wait;
drivers/infiniband/hw/qib/qib_iba7322.c-	wake_up(&ppd->cpspec->autoneg_wait);
drivers/infiniband/ulp/ipoib/ipoib_cm.c-
drivers/infiniband/ulp/ipoib/ipoib_cm.c-
drivers/infiniband/ulp/ipoib/ipoib_cm.c-
drivers/infiniband/ulp/ipoib/ipoib_cm.c-
drivers/infiniband/ulp/ipoib/ipoib_cm.c-}
drivers/infiniband/ulp/ipoib/ipoib_cm.c-	/* Add this entry to passive ids list head, but do not re-add it
drivers/infiniband/ulp/ipoib/ipoib_cm.c:	cancel_delayed_work(&priv->cm.stale_task);
drivers/infiniband/ulp/ipoib/ipoib_cm.c-	if (!list_empty(&priv->cm.passive_ids))
drivers/infiniband/ulp/ipoib/ipoib_cm.c-	ipoib_cm_free_rx_reap_list(dev);
drivers/infiniband/ulp/ipoib/ipoib_cm.c-			   &priv->cm.stale_task, IPOIB_CM_RX_DELAY);
drivers/infiniband/ulp/ipoib/ipoib_cm.c-				   &priv->cm.stale_task, IPOIB_CM_RX_DELAY);
drivers/infiniband/ulp/ipoib/ipoib_cm.c:	queue_delayed_work(ipoib_workqueue,
drivers/infiniband/ulp/ipoib/ipoib_cm.c:		queue_delayed_work(ipoib_workqueue,
drivers/infiniband/ulp/ipoib/ipoib_cm.c-	spin_lock_irq(&priv->lock);
drivers/infiniband/ulp/ipoib/ipoib_cm.c-	spin_unlock_irq(&priv->lock);
drivers/infiniband/ulp/ipoib/ipoib_ib.c-
drivers/infiniband/ulp/ipoib/ipoib_ib.c-
drivers/infiniband/ulp/ipoib/ipoib_ib.c-
drivers/infiniband/ulp/ipoib/ipoib_ib.c-}
drivers/infiniband/ulp/ipoib/ipoib_ib.c:	cancel_delayed_work(&priv->ah_reap_task);
drivers/infiniband/ulp/ipoib/ipoib_ib.c:		cancel_delayed_work(&priv->pkey_poll_task);
drivers/infiniband/ulp/ipoib/ipoib_ib.c-		clear_bit(IPOIB_PKEY_STOP, &priv->flags);
drivers/infiniband/ulp/ipoib/ipoib_ib.c-	clear_bit(IPOIB_STOP_REAPER, &priv->flags);
drivers/infiniband/ulp/ipoib/ipoib_ib.c-		flush_workqueue(ipoib_workqueue);
drivers/infiniband/ulp/ipoib/ipoib_ib.c-				   HZ);
drivers/infiniband/ulp/ipoib/ipoib_ib.c-					   HZ);
drivers/infiniband/ulp/ipoib/ipoib_ib.c-		if (flush)
drivers/infiniband/ulp/ipoib/ipoib_ib.c-	if (flush)
drivers/infiniband/ulp/ipoib/ipoib_ib.c-		if (!test_bit(IPOIB_PKEY_STOP, &priv->flags))
drivers/infiniband/ulp/ipoib/ipoib_ib.c-	if (!test_bit(IPOIB_STOP_REAPER, &priv->flags))
drivers/infiniband/ulp/ipoib/ipoib_ib.c-		mutex_lock(&pkey_mutex);
drivers/infiniband/ulp/ipoib/ipoib_ib.c-		mutex_lock(&pkey_mutex);
drivers/infiniband/ulp/ipoib/ipoib_ib.c-		mutex_lock(&pkey_mutex);
drivers/infiniband/ulp/ipoib/ipoib_ib.c-		mutex_unlock(&pkey_mutex);
drivers/infiniband/ulp/ipoib/ipoib_ib.c-				   &priv->pkey_poll_task,
drivers/infiniband/ulp/ipoib/ipoib_ib.c-					   &priv->pkey_poll_task,
drivers/infiniband/ulp/ipoib/ipoib_ib.c:		queue_delayed_work(ipoib_workqueue,
drivers/infiniband/ulp/ipoib/ipoib_ib.c:			queue_delayed_work(ipoib_workqueue,
drivers/infiniband/ulp/ipoib/ipoib_ib.c:		queue_delayed_work(ipoib_workqueue, &priv->ah_reap_task,
drivers/infiniband/ulp/ipoib/ipoib_ib.c:	queue_delayed_work(ipoib_workqueue, &priv->ah_reap_task,
drivers/infiniband/ulp/ipoib/ipoib_ib.c-			   round_jiffies_relative(HZ));
drivers/infiniband/ulp/ipoib/ipoib_ib.c-				   round_jiffies_relative(HZ));
drivers/infiniband/ulp/ipoib/ipoib_ib.c-		set_bit(IPOIB_PKEY_STOP, &priv->flags);
drivers/infiniband/ulp/ipoib/ipoib_ib.c-	set_bit(IPOIB_STOP_REAPER, &priv->flags);
drivers/infiniband/ulp/ipoib/ipoib_ib.c-	/* Wait for all AHs to be reaped */
drivers/infiniband/ulp/ipoib/ipoib_multicast.c-
drivers/infiniband/ulp/ipoib/ipoib_multicast.c-
drivers/infiniband/ulp/ipoib/ipoib_multicast.c:	cancel_delayed_work(&priv->mcast_task);
drivers/infiniband/ulp/ipoib/ipoib_multicast.c-	clear_bit(IPOIB_MCAST_RUN, &priv->flags);
drivers/infiniband/ulp/ipoib/ipoib_multicast.c-	if (!test_and_set_bit(IPOIB_MCAST_RUN, &priv->flags))
drivers/infiniband/ulp/ipoib/ipoib_multicast.c-			if (test_bit(IPOIB_MCAST_RUN, &priv->flags))
drivers/infiniband/ulp/ipoib/ipoib_multicast.c-		if (test_bit(IPOIB_MCAST_RUN, &priv->flags))
drivers/infiniband/ulp/ipoib/ipoib_multicast.c-		if (test_bit(IPOIB_MCAST_RUN, &priv->flags))
drivers/infiniband/ulp/ipoib/ipoib_multicast.c-	if (test_bit(IPOIB_MCAST_RUN, &priv->flags))
drivers/infiniband/ulp/ipoib/ipoib_multicast.c-				   mcast->backoff * HZ);
drivers/infiniband/ulp/ipoib/ipoib_multicast.c-					   mcast->backoff * HZ);
drivers/infiniband/ulp/ipoib/ipoib_multicast.c-	mutex_lock(&mcast_mutex);
drivers/infiniband/ulp/ipoib/ipoib_multicast.c-	mutex_lock(&mcast_mutex);
drivers/infiniband/ulp/ipoib/ipoib_multicast.c-		mutex_lock(&mcast_mutex);
drivers/infiniband/ulp/ipoib/ipoib_multicast.c-		mutex_lock(&mcast_mutex);
drivers/infiniband/ulp/ipoib/ipoib_multicast.c-			mutex_lock(&mcast_mutex);
drivers/infiniband/ulp/ipoib/ipoib_multicast.c-	mutex_unlock(&mcast_mutex);
drivers/infiniband/ulp/ipoib/ipoib_multicast.c-	mutex_unlock(&mcast_mutex);
drivers/infiniband/ulp/ipoib/ipoib_multicast.c-		mutex_unlock(&mcast_mutex);
drivers/infiniband/ulp/ipoib/ipoib_multicast.c-			mutex_unlock(&mcast_mutex);
drivers/infiniband/ulp/ipoib/ipoib_multicast.c-					   &priv->mcast_task,
drivers/infiniband/ulp/ipoib/ipoib_multicast.c-					   &priv->mcast_task, 0);
drivers/infiniband/ulp/ipoib/ipoib_multicast.c-						   &priv->mcast_task, HZ);
drivers/infiniband/ulp/ipoib/ipoib_multicast.c:			queue_delayed_work(ipoib_workqueue,
drivers/infiniband/ulp/ipoib/ipoib_multicast.c:			queue_delayed_work(ipoib_workqueue,
drivers/infiniband/ulp/ipoib/ipoib_multicast.c:				queue_delayed_work(ipoib_workqueue,
drivers/infiniband/ulp/ipoib/ipoib_multicast.c:		queue_delayed_work(ipoib_workqueue, &priv->mcast_task,
drivers/infiniband/ulp/ipoib/ipoib_multicast.c:		queue_delayed_work(ipoib_workqueue, &priv->mcast_task, 0);
drivers/infiniband/ulp/ipoib/ipoib_multicast.c-	spin_lock_irq(&priv->lock);
drivers/infiniband/ulp/ipoib/ipoib_multicast.c-	spin_unlock_irq(&priv->lock);
drivers/input/input_booster.c-
drivers/input/input_booster.c-
drivers/input/input_booster.c-
drivers/input/input_booster.c-
drivers/input/input_booster.c-
drivers/input/input_booster.c-
drivers/input/input_booster.c-
drivers/input/input_booster.c-
drivers/input/input_booster.c-
drivers/input/input_booster.c-		}
drivers/input/input_booster.c-		}
drivers/input/input_booster.c-		}
drivers/input/input_booster.c-		}
drivers/input/input_booster.c-		}
drivers/input/input_booster.c-		}
drivers/input/input_booster.c-				}
drivers/input/input_booster.c-				}
drivers/input/input_booster.c-				}
drivers/input/input_booster.c-				}
drivers/input/input_booster.c-				}
drivers/input/input_booster.c-				}
drivers/input/input_booster.c-					booster->dvfs_freq = MIN_TOUCH_HIGH_LIMIT;
drivers/input/input_booster.c-					booster->dvfs_freq = MIN_TOUCH_LIMIT;
drivers/input/input_booster.c-					booster->dvfs_freq = MIN_TOUCH_LIMIT;
drivers/input/input_booster.c-					booster->dvfs_freq = MIN_TOUCH_LIMIT_SECOND;
drivers/input/input_booster.c-					booster->dvfs_freq = MIN_TOUCH_LIMIT_SECOND;
drivers/input/input_booster.c-					booster->dvfs_freq = MIN_TOUCH_LOW_LIMIT;
drivers/input/input_booster.c-				break;
drivers/input/input_booster.c-				break;
drivers/input/input_booster.c-				break;
drivers/input/input_booster.c-				break;
drivers/input/input_booster.c-				break;
drivers/input/input_booster.c-				break;
drivers/input/input_booster.c-				break;
drivers/input/input_booster.c-				break;
drivers/input/input_booster.c:		cancel_delayed_work(&booster->work_dvfs_chg);
drivers/input/input_booster.c:			cancel_delayed_work(&booster->work_dvfs_chg);
drivers/input/input_booster.c:			cancel_delayed_work(&booster->work_dvfs_chg);
drivers/input/input_booster.c:			cancel_delayed_work(&booster->work_dvfs_chg);
drivers/input/input_booster.c:			cancel_delayed_work(&booster->work_dvfs_chg);
drivers/input/input_booster.c:			cancel_delayed_work(&booster->work_dvfs_chg);
drivers/input/input_booster.c:		cancel_delayed_work(&booster->work_dvfs_off);
drivers/input/input_booster.c:		cancel_delayed_work(&booster->work_dvfs_off);
drivers/input/input_booster.c:		cancel_delayed_work(&booster->work_dvfs_off);
drivers/input/input_booster.c:			cancel_delayed_work(&booster->work_dvfs_off);
drivers/input/input_booster.c:			cancel_delayed_work(&booster->work_dvfs_off);
drivers/input/input_booster.c:			cancel_delayed_work(&booster->work_dvfs_off);
drivers/input/input_booster.c-			case DVFS_STAGE_NINTH:
drivers/input/input_booster.c-			case DVFS_STAGE_PENTA:
drivers/input/input_booster.c-			case DVFS_STAGE_TRIPLE:
drivers/input/input_booster.c-	} else if (on < 0) {
drivers/input/input_booster.c-	} else if (on < 0) {
drivers/input/input_booster.c-	} else if (on > 0) {
drivers/input/input_booster.c-	} else if (on > 0) {
drivers/input/input_booster.c-	} else if (on == 1) {
drivers/input/input_booster.c-	} else if (on == 2) {
drivers/input/input_booster.c-						__func__, retval);
drivers/input/input_booster.c-		if (booster->dvfs_lock_status) {
drivers/input/input_booster.c-		if (booster->dvfs_lock_status) {
drivers/input/input_booster.c-		if (booster->dvfs_lock_status) {
drivers/input/input_booster.c-		if (booster->dvfs_lock_status) {
drivers/input/input_booster.c-		if (booster->dvfs_lock_status) {
drivers/input/input_booster.c-		if (!booster->dvfs_lock_status || booster->dvfs_old_stauts < on) {
drivers/input/input_booster.c-		if ((!booster->dvfs_lock_status) || (booster->dvfs_old_stauts < on)) {
drivers/input/input_booster.c-	if (on == 0) {
drivers/input/input_booster.c-	if (on == 0) {
drivers/input/input_booster.c-			msecs_to_jiffies(INPUT_BOOSTER_CHG_TIME_TKEY));
drivers/input/input_booster.c-					msecs_to_jiffies(INPUT_BOOSTER_CHG_TIME_TSP));
drivers/input/input_booster.c-					msecs_to_jiffies(INPUT_BOOSTER_CHG_TIME_TSP));
drivers/input/input_booster.c-					msecs_to_jiffies(INPUT_BOOSTER_CHG_TIME_TSP));
drivers/input/input_booster.c-				msecs_to_jiffies(INPUT_BOOSTER_CHG_TIME_WACOM));
drivers/input/input_booster.c-					msecs_to_jiffies(INPUT_BOOSTER_CHG_TIME_WACOM));
drivers/input/input_booster.c-					msecs_to_jiffies(INPUT_BOOSTER_CHG_TIME_WACOM));
drivers/input/input_booster.c-					msecs_to_jiffies(INPUT_BOOSTER_HIGH_CHG_TIME_TSP));
drivers/input/input_booster.c-					msecs_to_jiffies(INPUT_BOOSTER_HIGH_OFF_TIME_TSP));
drivers/input/input_booster.c-			msecs_to_jiffies(INPUT_BOOSTER_OFF_TIME_TKEY));
drivers/input/input_booster.c-					msecs_to_jiffies(INPUT_BOOSTER_OFF_TIME_TSP));
drivers/input/input_booster.c-				msecs_to_jiffies(INPUT_BOOSTER_OFF_TIME_WACOM));
drivers/input/input_booster.c-	mutex_lock(&booster->dvfs_lock);
drivers/input/input_booster.c-				pr_info("%s: cpu first lock failed(%d)\n",
drivers/input/input_booster.c:		schedule_delayed_work(&booster->work_dvfs_chg,
drivers/input/input_booster.c:			schedule_delayed_work(&booster->work_dvfs_chg,
drivers/input/input_booster.c:				schedule_delayed_work(&booster->work_dvfs_chg,
drivers/input/input_booster.c:				schedule_delayed_work(&booster->work_dvfs_chg,
drivers/input/input_booster.c:				schedule_delayed_work(&booster->work_dvfs_chg,
drivers/input/input_booster.c:				schedule_delayed_work(&booster->work_dvfs_chg,
drivers/input/input_booster.c:				schedule_delayed_work(&booster->work_dvfs_chg,
drivers/input/input_booster.c:				schedule_delayed_work(&booster->work_dvfs_chg,
drivers/input/input_booster.c:		schedule_delayed_work(&booster->work_dvfs_off,
drivers/input/input_booster.c:			schedule_delayed_work(&booster->work_dvfs_off,
drivers/input/input_booster.c:				schedule_delayed_work(&booster->work_dvfs_off,
drivers/input/input_booster.c:				schedule_delayed_work(&booster->work_dvfs_off,
drivers/input/input_booster.c-			schedule_work(&booster->work_dvfs_off.work);
drivers/input/input_booster.c-			schedule_work(&booster->work_dvfs_off.work);
drivers/input/input_booster.c-			schedule_work(&booster->work_dvfs_off.work);
drivers/input/input_booster.c-			switch (booster->dvfs_boost_mode) {
drivers/input/input_booster.c-			switch (booster->dvfs_boost_mode) {
drivers/input/input-polldev.c-
drivers/input/input-polldev.c-
drivers/input/input-polldev.c-
drivers/input/input-polldev.c-
drivers/input/input-polldev.c-
drivers/input/input-polldev.c-}
drivers/input/input-polldev.c:	cancel_delayed_work_sync(&dev->work);
drivers/input/input-polldev.c:		cancel_delayed_work_sync(&polldev->work);
drivers/input/input-polldev.c-		delay = round_jiffies_relative(delay);
drivers/input/input-polldev.c-	if (dev->close)
drivers/input/input-polldev.c-	if (input->users) {
drivers/input/input-polldev.c-		if (polldev->poll_interval > 0)
drivers/input/input-polldev.c-			input_polldev_queue_work(polldev);
drivers/input/input-polldev.c:	queue_delayed_work(system_freezable_wq, &dev->work, delay);
drivers/input/input-polldev.c-	struct input_polled_dev *dev = input_get_drvdata(input);
drivers/input/joystick/tdisc_vtd518_shinetsu.c-
drivers/input/joystick/tdisc_vtd518_shinetsu.c-
drivers/input/joystick/tdisc_vtd518_shinetsu.c-
drivers/input/joystick/tdisc_vtd518_shinetsu.c-
drivers/input/joystick/tdisc_vtd518_shinetsu.c-
drivers/input/joystick/tdisc_vtd518_shinetsu.c-}
drivers/input/joystick/tdisc_vtd518_shinetsu.c-}
drivers/input/joystick/tdisc_vtd518_shinetsu.c:	cancel_delayed_work_sync(&dd->tdisc_work);
drivers/input/joystick/tdisc_vtd518_shinetsu.c-		dd->pdata->tdisc_disable();
drivers/input/joystick/tdisc_vtd518_shinetsu.c-		disable_irq(dd->clientp->irq);
drivers/input/joystick/tdisc_vtd518_shinetsu.c-	disable_irq_nosync(dd->clientp->irq);
drivers/input/joystick/tdisc_vtd518_shinetsu.c-			enable_irq(dd->clientp->irq);
drivers/input/joystick/tdisc_vtd518_shinetsu.c-fail_i2c_read:
drivers/input/joystick/tdisc_vtd518_shinetsu.c-	free_irq(dd->clientp->irq, dd);
drivers/input/joystick/tdisc_vtd518_shinetsu.c:		if (cancel_delayed_work_sync(&dd->tdisc_work))
drivers/input/joystick/tdisc_vtd518_shinetsu.c-	if (dd->pdata->tdisc_disable != NULL)
drivers/input/joystick/tdisc_vtd518_shinetsu.c-#if defined(CONFIG_POWERSUSPEND)
drivers/input/joystick/tdisc_vtd518_shinetsu.c-	return IRQ_HANDLED;
drivers/input/joystick/tdisc_vtd518_shinetsu.c:	schedule_delayed_work(&dd->tdisc_work, 0);
drivers/input/joystick/tdisc_vtd518_shinetsu.c:	schedule_delayed_work(&dd->tdisc_work, TDISC_READ_DELAY);
drivers/input/joystick/tdisc_vtd518_shinetsu.c-	/* Schedule the work immediately */
drivers/input/joystick/tdisc_vtd518_shinetsu.c:	struct delayed_work tdisc_work;
drivers/input/joystick/tdisc_vtd518_shinetsu.c-	struct i2c_client *clientp;
drivers/input/joystick/tdisc_vtd518_shinetsu.c-	struct power_suspend	tdisc_power_suspend;
drivers/input/joystick/tdisc_vtd518_shinetsu.c-	struct tdisc_platform_data *pdata;
drivers/input/keyboard/adp5588-keys.c-
drivers/input/keyboard/adp5588-keys.c-
drivers/input/keyboard/adp5588-keys.c-
drivers/input/keyboard/adp5588-keys.c-
drivers/input/keyboard/adp5588-keys.c-	 */
drivers/input/keyboard/adp5588-keys.c-	adp5588_gpio_remove(kpad);
drivers/input/keyboard/adp5588-keys.c-	adp5588_write(client, CFG, 0);
drivers/input/keyboard/adp5588-keys.c:	cancel_delayed_work_sync(&kpad->work);
drivers/input/keyboard/adp5588-keys.c:	cancel_delayed_work_sync(&kpad->work);
drivers/input/keyboard/adp5588-keys.c-	disable_irq(client->irq);
drivers/input/keyboard/adp5588-keys.c-	free_irq(client->irq, kpad);
drivers/input/keyboard/adp5588-keys.c-	if (device_may_wakeup(&client->dev))
drivers/input/keyboard/adp5588-keys.c-	input_unregister_device(kpad->input);
drivers/input/keyboard/adp5588-keys.c-	return IRQ_HANDLED;
drivers/input/keyboard/adp5588-keys.c:	schedule_delayed_work(&kpad->work, kpad->delay);
drivers/input/keyboard/adp5588-keys.c:	struct delayed_work work;
drivers/input/keyboard/adp5588-keys.c-	struct i2c_client *client;
drivers/input/keyboard/adp5588-keys.c-	struct input_dev *input;
drivers/input/keyboard/adp5588-keys.c-	unsigned long delay;
drivers/input/keyboard/adp5588-keys.c-	unsigned short keycode[ADP5588_KEYMAPSIZE];
drivers/input/keyboard/atkbd.c-
drivers/input/keyboard/atkbd.c-
drivers/input/keyboard/atkbd.c-
drivers/input/keyboard/atkbd.c-}
drivers/input/keyboard/atkbd.c-	 */
drivers/input/keyboard/atkbd.c-		 */
drivers/input/keyboard/atkbd.c-	 * accessing freed input device or serio port.
drivers/input/keyboard/atkbd.c:	cancel_delayed_work_sync(&atkbd->event_work);
drivers/input/keyboard/atkbd.c-	} else {
drivers/input/keyboard/atkbd.c-	mb();
drivers/input/keyboard/atkbd.c-					msecs_to_jiffies(100));
drivers/input/keyboard/atkbd.c-		 * rescheduling till reconnect completes.
drivers/input/keyboard/atkbd.c:		schedule_delayed_work(&atkbd->event_work,
drivers/input/keyboard/atkbd.c:	schedule_delayed_work(&atkbd->event_work, delay);
drivers/input/keyboard/atkbd.c-	serio_close(serio);
drivers/input/keyboard/atkbd.c-	set_bit(event_bit, &atkbd->event_mask);
drivers/input/keyboard/atkbd.c:	struct delayed_work event_work;
drivers/input/keyboard/atkbd.c-	unsigned long err_count;
drivers/input/keyboard/atkbd.c-	unsigned long event_jiffies;
drivers/input/keyboard/atkbd.c-	unsigned long event_mask;
drivers/input/keyboard/gpio_keys.c-
drivers/input/keyboard/gpio_keys.c-
drivers/input/keyboard/gpio_keys.c-
drivers/input/keyboard/gpio_keys.c-
drivers/input/keyboard/gpio_keys.c-
drivers/input/keyboard/gpio_keys.c-
drivers/input/keyboard/gpio_keys.c-
drivers/input/keyboard/gpio_keys.c-
drivers/input/keyboard/gpio_keys.c-}
drivers/input/keyboard/gpio_keys.c-	}
drivers/input/keyboard/gpio_keys.c-			 &bdata->work,
drivers/input/keyboard/gpio_keys.c-	bool flip_cover;
drivers/input/keyboard/gpio_keys.c:	cancel_delayed_work_sync(&bdata->work);
drivers/input/keyboard/gpio_keys.c:		cancel_delayed_work_sync(&bdata->work);
drivers/input/keyboard/gpio_keys.c:			cancel_delayed_work_sync(&bdata->work);
drivers/input/keyboard/gpio_keys.c-		del_timer_sync(&bdata->release_timer);
drivers/input/keyboard/gpio_keys.c-		del_timer_sync(&bdata->release_timer);
drivers/input/keyboard/gpio_keys.c-			del_timer_sync(&bdata->release_timer);
drivers/input/keyboard/gpio_keys.c-	else
drivers/input/keyboard/gpio_keys.c-		else
drivers/input/keyboard/gpio_keys.c-#endif
drivers/input/keyboard/gpio_keys.c-		gpio_free(bdata->button->gpio);
drivers/input/keyboard/gpio_keys.c-	if (bdata->release_delay)
drivers/input/keyboard/gpio_keys.c-		if (gpio_is_valid(bdata->button->gpio))
drivers/input/keyboard/gpio_keys.c-	if (gpio_is_valid(bdata->button->gpio))
drivers/input/keyboard/gpio_keys.c-	if (gpio_is_valid(bdata->button->gpio))
drivers/input/keyboard/gpio_keys.c-	if (gpio_to_irq(ddata->gpio_flip_cover))
drivers/input/keyboard/gpio_keys.c-	int gpio_flip_cover;
drivers/input/keyboard/gpio_keys.c:		mod_delayed_work(flipqueue, &ddata->flip_cover_dwork, msecs_to_jiffies(4));
drivers/input/keyboard/gpio_keys.c:		mod_delayed_work(flipqueue, &ddata->flip_cover_dwork, msecs_to_jiffies(4));
drivers/input/keyboard/gpio_keys.c:	mod_delayed_work(system_wq,
drivers/input/keyboard/gpio_keys.c-			 msecs_to_jiffies(bdata->software_debounce));
drivers/input/keyboard/gpio_keys.c-	return IRQ_HANDLED;
drivers/input/keyboard/gpio_keys.c-skip_flip:
drivers/input/keyboard/gpio_keys.c:	struct delayed_work flip_cover_dwork;
drivers/input/keyboard/gpio_keys.c:	struct delayed_work work;
drivers/input/keyboard/gpio_keys.c-	//struct wake_lock flip_wake_lock;
drivers/input/keyboard/gpio_keys.c-	unsigned int release_delay;	/* in msecs, for IRQ-only buttons */
drivers/input/keyboard/gpio_keys.c-	unsigned int software_debounce;	/* in msecs, for GPIO-driven buttons */
drivers/input/keyboard/gpio_keys.c-		/* update the current status */
drivers/input/keyboard/matrix_keypad.c-
drivers/input/keyboard/matrix_keypad.c-
drivers/input/keyboard/matrix_keypad.c-
drivers/input/keyboard/matrix_keypad.c-	 */
drivers/input/keyboard/matrix_keypad.c-	bool scan_pending;
drivers/input/keyboard/matrix_keypad.c-	 * columns will be activated and IRQs be enabled after the scan.
drivers/input/keyboard/matrix_keypad.c-	disable_row_irqs(keypad);
drivers/input/keyboard/matrix_keypad.c-	keypad->scan_pending = true;
drivers/input/keyboard/matrix_keypad.c-		msecs_to_jiffies(keypad->pdata->debounce_ms));
drivers/input/keyboard/matrix_keypad.c-	return 0;
drivers/input/keyboard/matrix_keypad.c:	schedule_delayed_work(&keypad->work,
drivers/input/keyboard/matrix_keypad.c:	schedule_delayed_work(&keypad->work, 0);
drivers/input/keyboard/matrix_keypad.c-	spinlock_t lock;
drivers/input/keyboard/matrix_keypad.c:	struct delayed_work work;
drivers/input/keyboard/matrix_keypad.c-	uint32_t last_key_state[MATRIX_MAX_COLS];
drivers/input/keyboard/qt2160.c-
drivers/input/keyboard/qt2160.c-
drivers/input/keyboard/qt2160.c-
drivers/input/keyboard/qt2160.c-
drivers/input/keyboard/qt2160.c-{
drivers/input/keyboard/qt2160.c-}
drivers/input/keyboard/qt2160.c:	cancel_delayed_work_sync(&qt2160->dwork);
drivers/input/keyboard/qt2160.c-		free_irq(client->irq, qt2160);
drivers/input/keyboard/qt2160.c-	input_unregister_device(qt2160->input);
drivers/input/keyboard/qt2160.c:	mod_delayed_work(system_wq, &qt2160->dwork, 0);
drivers/input/keyboard/qt2160.c:	schedule_delayed_work(&qt2160->dwork, QT2160_CYCLE_INTERVAL);
drivers/input/keyboard/qt2160.c-	spin_lock_irq(&qt2160->lock);
drivers/input/keyboard/qt2160.c-	spin_lock_irqsave(&qt2160->lock, flags);
drivers/input/keyboard/qt2160.c-	spinlock_t lock;        /* Protects canceling/rescheduling of dwork */
drivers/input/keyboard/qt2160.c-	spin_unlock_irq(&qt2160->lock);
drivers/input/keyboard/qt2160.c-	spin_unlock_irqrestore(&qt2160->lock, flags);
drivers/input/keyboard/qt2160.c:	struct delayed_work dwork;
drivers/input/keyboard/qt2160.c-	struct i2c_client *client;
drivers/input/keyboard/qt2160.c-	struct input_dev *input;
drivers/input/keyboard/qt2160.c-	unsigned short keycodes[ARRAY_SIZE(qt2160_key2code)];
drivers/input/keyboard/tca6416-keypad.c-
drivers/input/keyboard/tca6416-keypad.c-
drivers/input/keyboard/tca6416-keypad.c-
drivers/input/keyboard/tca6416-keypad.c-
drivers/input/keyboard/tca6416-keypad.c-}
drivers/input/keyboard/tca6416-keypad.c:		cancel_delayed_work_sync(&chip->dwork);
drivers/input/keyboard/tca6416-keypad.c-		disable_irq(chip->irqnum);
drivers/input/keyboard/tca6416-keypad.c-	else
drivers/input/keyboard/tca6416-keypad.c-	else
drivers/input/keyboard/tca6416-keypad.c-		enable_irq(chip->irqnum);
drivers/input/keyboard/tca6416-keypad.c-	if (chip->use_polling)
drivers/input/keyboard/tca6416-keypad.c-	if (chip->use_polling)
drivers/input/keyboard/tca6416-keypad.c-	int io_size;
drivers/input/keyboard/tca6416-keypad.c-	int irqnum;
drivers/input/keyboard/tca6416-keypad.c:		schedule_delayed_work(&chip->dwork, msecs_to_jiffies(100));
drivers/input/keyboard/tca6416-keypad.c:	schedule_delayed_work(&chip->dwork, msecs_to_jiffies(100));
drivers/input/keyboard/tca6416-keypad.c:	struct delayed_work dwork;
drivers/input/keyboard/tca6416-keypad.c-	struct i2c_client *client;
drivers/input/keyboard/tca6416-keypad.c-	struct input_dev *input;
drivers/input/keyboard/tca6416-keypad.c-	tca6416_keys_scan(chip);
drivers/input/keyreset.c-
drivers/input/keyreset.c-{
drivers/input/keyreset.c-};
drivers/input/keyreset.c:			cancel_delayed_work(&state->restart_work);
drivers/input/keyreset.c:	cancel_delayed_work_sync(&state->restart_work);
drivers/input/keyreset.c-		container_of(dwork, struct keyreset_state, restart_work);
drivers/input/keyreset.c-		if (state->down_time_ms) {
drivers/input/keyreset.c-			if (state->restart_requested) {
drivers/input/keyreset.c-	input_unregister_handler(&state->input_handler);
drivers/input/keyreset.c-	int down_time_ms;
drivers/input/keyreset.c-	int (*reset_fn)(void);
drivers/input/keyreset.c-	kfree(state);
drivers/input/keyreset.c-				msecs_to_jiffies(state->down_time_ms));
drivers/input/keyreset.c-				pr_info("keyboard reset canceled\n");
drivers/input/keyreset.c-			pr_info("keyboard reset (delayed %dms)\n",
drivers/input/keyreset.c-	return 0;
drivers/input/keyreset.c:			schedule_delayed_work(&state->restart_work,
drivers/input/keyreset.c-				state->down_time_ms);
drivers/input/keyreset.c-		state->restart_disabled = 0;
drivers/input/keyreset.c-			state->restart_requested = 1;
drivers/input/keyreset.c-static void deferred_restart(struct work_struct *work)
drivers/input/keyreset.c:	struct delayed_work *dwork = to_delayed_work(work);
drivers/input/keyreset.c:	struct delayed_work restart_work;
drivers/input/keyreset.c-	struct keyreset_state *state =
drivers/input/keyreset.c-	struct keyreset_state *state = platform_get_drvdata(pdev);
drivers/input/misc/bma150.c-
drivers/input/misc/bma150.c-
drivers/input/misc/bma150.c-
drivers/input/misc/bma150.c-
drivers/input/misc/bma150.c-
drivers/input/misc/bma150.c-
drivers/input/misc/bma150.c-
drivers/input/misc/bma150.c-{
drivers/input/misc/bma150.c-}
drivers/input/misc/bma150.c-};
drivers/input/misc/bma150.c-	bma150_set_mode(client, BMA150_MODE_NORMAL);
drivers/input/misc/bma150.c-	bma150_set_mode(client, BMA150_MODE_SLEEP);
drivers/input/misc/bma150.c-	bma150->value = acc;
drivers/input/misc/bma150.c:	cancel_delayed_work_sync(&data->work);
drivers/input/misc/bma150.c-		goto error_sysfs;
drivers/input/misc/bma150.c-		msecs_to_jiffies(atomic_read(&data->delay)));
drivers/input/misc/bma150.c-			msecs_to_jiffies(atomic_read(&data->delay)));
drivers/input/misc/bma150.c-	mutex_unlock(&bma150->value_mutex);
drivers/input/misc/bma150.c:	schedule_delayed_work(&bma150->work, delay);
drivers/input/misc/bma150.c:	schedule_delayed_work(&data->work,
drivers/input/misc/bma150.c:	schedule_delayed_work(&data->work,
drivers/input/misc/bma150.c-	static struct bma150acc acc;
drivers/input/misc/bma150.c-static void bma150_work_func(struct work_struct *work)
drivers/input/misc/bma150.c:	struct bma150_data *bma150 = container_of((struct delayed_work *)work,
drivers/input/misc/bma150.c-	struct bma150_data *data = i2c_get_clientdata(client);
drivers/input/misc/bma150.c-			struct bma150_data, work);
drivers/input/misc/bma150.c:	struct delayed_work work;
drivers/input/misc/bma150.c-	struct mutex mode_mutex;
drivers/input/misc/bma150.c-	struct mutex value_mutex;
drivers/input/misc/bma150.c-	struct work_struct irq_work;
drivers/input/misc/bmp18x-core.c-
drivers/input/misc/bmp18x-core.c-
drivers/input/misc/bmp18x-core.c-{
drivers/input/misc/bmp18x-core.c-}
drivers/input/misc/bmp18x-core.c-	}
drivers/input/misc/bmp18x-core.c-	}
drivers/input/misc/bmp18x-core.c-	}
drivers/input/misc/bmp18x-core.c-		}
drivers/input/misc/bmp18x-core.c-		}
drivers/input/misc/bmp18x-core.c-		}
drivers/input/misc/bmp18x-core.c-			bmp18x_disable(dev);
drivers/input/misc/bmp18x-core.c-			bmp18x_enable(dev);
drivers/input/misc/bmp18x-core.c:		cancel_delayed_work_sync(&data->work);
drivers/input/misc/bmp18x-core.c:			cancel_delayed_work_sync(&data->work);
drivers/input/misc/bmp18x-core.c:			cancel_delayed_work_sync(&data->work);
drivers/input/misc/bmp18x-core.c-	case PM_PROACTIVE_SUSPEND:
drivers/input/misc/bmp18x-core.c-		container_of(h, struct bmp18x_data, power_suspend);
drivers/input/misc/bmp18x-core.c:		container_of((struct delayed_work *)work,
drivers/input/misc/bmp18x-core.c-		} else {
drivers/input/misc/bmp18x-core.c-#endif
drivers/input/misc/bmp18x-core.c-		if (data->enable) {
drivers/input/misc/bmp18x-core.c-		if (data->enable) {
drivers/input/misc/bmp18x-core.c-		if (data->enable) {
drivers/input/misc/bmp18x-core.c-	if (data->enable) {
drivers/input/misc/bmp18x-core.c-	if (data->enable) {
drivers/input/misc/bmp18x-core.c-					msecs_to_jiffies(data->delay));
drivers/input/misc/bmp18x-core.c-						msecs_to_jiffies(data->delay));
drivers/input/misc/bmp18x-core.c-						msecs_to_jiffies(data->delay));
drivers/input/misc/bmp18x-core.c:	schedule_delayed_work(&client_data->work, delay-(jiffies-j1));
drivers/input/misc/bmp18x-core.c:		schedule_delayed_work(&data->work,
drivers/input/misc/bmp18x-core.c:			schedule_delayed_work(&data->work,
drivers/input/misc/bmp18x-core.c:			schedule_delayed_work(&data->work,
drivers/input/misc/bmp18x-core.c-	struct bmp18x_data *client_data =
drivers/input/misc/bmp18x-core.c-		struct bmp18x_data, work);
drivers/input/misc/bmp18x-core.c:	struct delayed_work work;
drivers/input/misc/bmp18x-core.c-	struct input_dev	*input;
drivers/input/misc/bmp18x-core.c-	u32					delay;
drivers/input/misc/bmp18x-core.c-	u32					enable;
drivers/input/misc/bmp18x-core.c-	unsigned long delay = msecs_to_jiffies(client_data->delay);
drivers/input/misc/bmp18x-core.c-			(void) bmp18x_disable(data->dev);
drivers/input/misc/bmp18x-core.c-		(void) bmp18x_disable(data->dev);
drivers/input/misc/bmp18x-core.c-			(void) bmp18x_enable(data->dev);
drivers/input/misc/bmp18x-core.c-		(void) bmp18x_enable(data->dev);
drivers/input/misc/da9052_onkey.c-
drivers/input/misc/da9052_onkey.c-
drivers/input/misc/da9052_onkey.c-
drivers/input/misc/da9052_onkey.c-}
drivers/input/misc/da9052_onkey.c-};
drivers/input/misc/da9052_onkey.c-	 */
drivers/input/misc/da9052_onkey.c:	cancel_delayed_work_sync(&onkey->work);
drivers/input/misc/da9052_onkey.c:	cancel_delayed_work_sync(&onkey->work);
drivers/input/misc/da9052_onkey.c-err_free_irq:
drivers/input/misc/da9052_onkey.c-err_free_mem:
drivers/input/misc/da9052_onkey.c-	free_irq(onkey->irq, onkey);
drivers/input/misc/da9052_onkey.c-	free_irq(onkey->irq, onkey);
drivers/input/misc/da9052_onkey.c-	if (key_stat)
drivers/input/misc/da9052_onkey.c-	input_free_device(input_dev);
drivers/input/misc/da9052_onkey.c-	input_unregister_device(onkey->input);
drivers/input/misc/da9052_onkey.c:		schedule_delayed_work(&onkey->work, msecs_to_jiffies(50));
drivers/input/misc/da9052_onkey.c-	struct da9052 *da9052;
drivers/input/misc/da9052_onkey.c:	struct delayed_work work;
drivers/input/misc/da9052_onkey.c-	struct input_dev *input;
drivers/input/misc/da9052_onkey.c-	unsigned int irq;
drivers/input/misc/lis3dh_acc.c-
drivers/input/misc/lis3dh_acc.c-
drivers/input/misc/lis3dh_acc.c-
drivers/input/misc/lis3dh_acc.c-
drivers/input/misc/lis3dh_acc.c-
drivers/input/misc/lis3dh_acc.c-{
drivers/input/misc/lis3dh_acc.c-	}
drivers/input/misc/lis3dh_acc.c-	}
drivers/input/misc/lis3dh_acc.c-		}
drivers/input/misc/lis3dh_acc.c:	acc = container_of((struct delayed_work *)work,
drivers/input/misc/lis3dh_acc.c-			acc->pdata->poll_interval));
drivers/input/misc/lis3dh_acc.c:		cancel_delayed_work_sync(&acc->input_work);
drivers/input/misc/lis3dh_acc.c-	if (atomic_cmpxchg(&acc->enabled, 1, 0)) {
drivers/input/misc/lis3dh_acc.c-	int err;
drivers/input/misc/lis3dh_acc.c-		lis3dh_acc_device_power_off(acc);
drivers/input/misc/lis3dh_acc.c-		lis3dh_acc_report_values(acc, xyz);
drivers/input/misc/lis3dh_acc.c-			msecs_to_jiffies(acc->pdata->poll_interval));
drivers/input/misc/lis3dh_acc.c-	mutex_unlock(&acc->lock);
drivers/input/misc/lis3dh_acc.c-			return err;
drivers/input/misc/lis3dh_acc.c:		schedule_delayed_work(&acc->input_work,
drivers/input/misc/lis3dh_acc.c:	schedule_delayed_work(&acc->input_work, msecs_to_jiffies(
drivers/input/misc/lis3dh_acc.c:	struct delayed_work input_work;
drivers/input/misc/lis3dh_acc.c-	struct input_dev *input_dev;
drivers/input/misc/lis3dh_acc.c-			struct lis3dh_acc_data,	input_work);
drivers/input/misc/lis3dh_acc.c-	struct mutex lock;
drivers/input/misc/mpu3050.c-
drivers/input/misc/mpu3050.c-
drivers/input/misc/mpu3050.c-
drivers/input/misc/mpu3050.c-
drivers/input/misc/mpu3050.c-
drivers/input/misc/mpu3050.c-{
drivers/input/misc/mpu3050.c-}
drivers/input/misc/mpu3050.c-	}
drivers/input/misc/mpu3050.c:		cancel_delayed_work_sync(&sensor->input_work);
drivers/input/misc/mpu3050.c-	if (sensor->use_poll)
drivers/input/misc/mpu3050.c-	if (sensor->use_poll)
drivers/input/misc/mpu3050.c-	if (sensor->use_poll)
drivers/input/misc/mpu3050.c-			msecs_to_jiffies(sensor->poll_interval));
drivers/input/misc/mpu3050.c-			msecs_to_jiffies(sensor->poll_interval));
drivers/input/misc/mpu3050.c-	pm_runtime_put(sensor->dev);
drivers/input/misc/mpu3050.c:		schedule_delayed_work(&sensor->input_work,
drivers/input/misc/mpu3050.c:		schedule_delayed_work(&sensor->input_work,
drivers/input/misc/mpu3050.c:	sensor = container_of((struct delayed_work *)work,
drivers/input/misc/mpu3050.c-	struct axis_data axis;
drivers/input/misc/mpu3050.c:	struct delayed_work input_work;
drivers/input/misc/mpu3050.c-	struct input_dev *idev;
drivers/input/misc/mpu3050.c-	struct mpu3050_gyro_platform_data *platform_data;
drivers/input/misc/mpu3050.c-				struct mpu3050_sensor, input_work);
drivers/input/misc/mpu3050.c-	u32    poll_interval;
drivers/input/misc/mpu3050.c-	u32    use_poll;
drivers/input/misc/mpu6050/mpu6050_input.c-{
drivers/input/misc/mpu6050/mpu6050_input.c-{
drivers/input/misc/mpu6050/mpu6050_input.c-};
drivers/input/misc/mpu6050/mpu6050_input.c-
drivers/input/misc/mpu6050/mpu6050_input.c-
drivers/input/misc/mpu6050/mpu6050_input.c-
drivers/input/misc/mpu6050/mpu6050_input.c-	}
drivers/input/misc/mpu6050/mpu6050_input.c-	}
drivers/input/misc/mpu6050/mpu6050_input.c-	}
drivers/input/misc/mpu6050/mpu6050_input.c-		}
drivers/input/misc/mpu6050/mpu6050_input.c-			atomic_read(&data->accel_delay)));
drivers/input/misc/mpu6050/mpu6050_input.c-			atomic_read(&data->accel_delay) * 1100);
drivers/input/misc/mpu6050/mpu6050_input.c-			atomic_read(&data->gyro_delay)));
drivers/input/misc/mpu6050/mpu6050_input.c-			atomic_read(&data->gyro_delay) * 1100);
drivers/input/misc/mpu6050/mpu6050_input.c-	bool accel_on_by_system;
drivers/input/misc/mpu6050/mpu6050_input.c-	bool factory_mode;
drivers/input/misc/mpu6050/mpu6050_input.c:		cancel_delayed_work_sync(&data->accel_work);
drivers/input/misc/mpu6050/mpu6050_input.c:		cancel_delayed_work_sync(&data->accel_work);
drivers/input/misc/mpu6050/mpu6050_input.c:		cancel_delayed_work_sync(&data->accel_work);
drivers/input/misc/mpu6050/mpu6050_input.c:		cancel_delayed_work_sync(&data->gyro_work);
drivers/input/misc/mpu6050/mpu6050_input.c:		cancel_delayed_work_sync(&data->gyro_work);
drivers/input/misc/mpu6050/mpu6050_input.c:		cancel_delayed_work_sync(&data->gyro_work);
drivers/input/misc/mpu6050/mpu6050_input.c:			cancel_delayed_work_sync(&gb_mpu_data->accel_off_work);
drivers/input/misc/mpu6050/mpu6050_input.c:		container_of((struct delayed_work *)work,
drivers/input/misc/mpu6050/mpu6050_input.c:		container_of((struct delayed_work *)work,
drivers/input/misc/mpu6050/mpu6050_input.c-	} else {
drivers/input/misc/mpu6050/mpu6050_input.c-	} else {
drivers/input/misc/mpu6050/mpu6050_input.c-		} else {
drivers/input/misc/mpu6050/mpu6050_input.c-#endif
drivers/input/misc/mpu6050/mpu6050_input.c-#endif
drivers/input/misc/mpu6050/mpu6050_input.c-#endif
drivers/input/misc/mpu6050/mpu6050_input.c-#endif
drivers/input/misc/mpu6050/mpu6050_input.c-			gb_mpu_data->accel_on_by_system = true;
drivers/input/misc/mpu6050/mpu6050_input.c-		if (atomic_read(&data->accel_enable))
drivers/input/misc/mpu6050/mpu6050_input.c-	if (atomic_read(&data->accel_enable))
drivers/input/misc/mpu6050/mpu6050_input.c-	if (atomic_read(&data->accel_enable))
drivers/input/misc/mpu6050/mpu6050_input.c-		if (atomic_read(&data->gyro_enable))
drivers/input/misc/mpu6050/mpu6050_input.c-	if (atomic_read(&data->gyro_enable))
drivers/input/misc/mpu6050/mpu6050_input.c-	if (atomic_read(&data->gyro_enable))
drivers/input/misc/mpu6050/mpu6050_input.c-	if (data->pdata->power_on)
drivers/input/misc/mpu6050/mpu6050_input.c-#ifdef CONFIG_INPUT_MPU6050_POLLING
drivers/input/misc/mpu6050/mpu6050_input.c-#ifdef CONFIG_INPUT_MPU6050_POLLING
drivers/input/misc/mpu6050/mpu6050_input.c-#ifdef CONFIG_INPUT_MPU6050_POLLING
drivers/input/misc/mpu6050/mpu6050_input.c-#ifdef CONFIG_INPUT_MPU6050_POLLING
drivers/input/misc/mpu6050/mpu6050_input.c-	if (!value && atomic_read(&data->accel_enable)) {
drivers/input/misc/mpu6050/mpu6050_input.c-	if (!value && atomic_read(&data->gyro_enable)) {
drivers/input/misc/mpu6050/mpu6050_input.c-		mpu6050_input_activate_devices(data,
drivers/input/misc/mpu6050/mpu6050_input.c-		mpu6050_input_activate_devices(data,
drivers/input/misc/mpu6050/mpu6050_input.c-		mpu6050_input_activate_devices(data,
drivers/input/misc/mpu6050/mpu6050_input.c-		mpu6050_input_activate_devices(data,
drivers/input/misc/mpu6050/mpu6050_input.c-			MPU6050_SENSOR_ACCEL, false);
drivers/input/misc/mpu6050/mpu6050_input.c-			MPU6050_SENSOR_ACCEL, true);
drivers/input/misc/mpu6050/mpu6050_input.c-			MPU6050_SENSOR_GYRO, false);
drivers/input/misc/mpu6050/mpu6050_input.c-			MPU6050_SENSOR_GYRO, true);
drivers/input/misc/mpu6050/mpu6050_input.c-			msecs_to_jiffies(
drivers/input/misc/mpu6050/mpu6050_input.c-			msecs_to_jiffies(
drivers/input/misc/mpu6050/mpu6050_input.c-			msecs_to_jiffies(5));
drivers/input/misc/mpu6050/mpu6050_input.c-			msecs_to_jiffies(5));
drivers/input/misc/mpu6050/mpu6050_input.c-			msecs_to_jiffies(5000));
drivers/input/misc/mpu6050/mpu6050_input.c-	return 0;
drivers/input/misc/mpu6050/mpu6050_input.c-	s16 acc_cal[3];
drivers/input/misc/mpu6050/mpu6050_input.c:		schedule_delayed_work(&data->accel_work,
drivers/input/misc/mpu6050/mpu6050_input.c:		schedule_delayed_work(&data->accel_work,
drivers/input/misc/mpu6050/mpu6050_input.c:			schedule_delayed_work(&data->accel_work, 0);
drivers/input/misc/mpu6050/mpu6050_input.c:		schedule_delayed_work(&data->accel_work, 0);
drivers/input/misc/mpu6050/mpu6050_input.c:		schedule_delayed_work(&data->gyro_work,
drivers/input/misc/mpu6050/mpu6050_input.c:		schedule_delayed_work(&data->gyro_work,
drivers/input/misc/mpu6050/mpu6050_input.c:			schedule_delayed_work(&data->gyro_work, 0);
drivers/input/misc/mpu6050/mpu6050_input.c:		schedule_delayed_work(&data->gyro_work, 0);
drivers/input/misc/mpu6050/mpu6050_input.c:		schedule_delayed_work(&gb_mpu_data->accel_off_work,
drivers/input/misc/mpu6050/mpu6050_input.c:	struct delayed_work accel_off_work;
drivers/input/misc/mpu6050/mpu6050_input.c:	struct delayed_work accel_work;
drivers/input/misc/mpu6050/mpu6050_input.c:	struct delayed_work gyro_work;
drivers/input/misc/mpu6050/mpu6050_input.c-	struct device *gyro_sensor_device;
drivers/input/misc/mpu6050/mpu6050_input.c-			struct mpu6050_input_data, accel_work);
drivers/input/misc/mpu6050/mpu6050_input.c-	struct mpu6050_input_data *data =
drivers/input/misc/mpu6050/mpu6050_input.c-	struct mpu6050_input_data *data =
drivers/input/misc/mpu6050/mpu6050_input.c-			struct mpu6050_input_data, gyro_work);
drivers/input/misc/mpu6050/mpu6050_input.c-	struct wake_lock reactive_wake_lock;
drivers/input/misc/mpu6050/mpu6050_input.c-		usleep_range(atomic_read(&data->accel_delay) * 1000,
drivers/input/misc/mpu6050/mpu6050_input.c-		usleep_range(atomic_read(&data->gyro_delay) * 1000,
drivers/input/misc/mpu6500/mpu6500_input.c-{
drivers/input/misc/mpu6500/mpu6500_input.c-{
drivers/input/misc/mpu6500/mpu6500_input.c-
drivers/input/misc/mpu6500/mpu6500_input.c-
drivers/input/misc/mpu6500/mpu6500_input.c-
drivers/input/misc/mpu6500/mpu6500_input.c-
drivers/input/misc/mpu6500/mpu6500_input.c-	}
drivers/input/misc/mpu6500/mpu6500_input.c-	}
drivers/input/misc/mpu6500/mpu6500_input.c-			atomic_read(&data->accel_delay)));
drivers/input/misc/mpu6500/mpu6500_input.c-			atomic_read(&data->accel_delay) * 1100);
drivers/input/misc/mpu6500/mpu6500_input.c-			atomic_read(&data->gyro_delay)));
drivers/input/misc/mpu6500/mpu6500_input.c-			atomic_read(&data->gyro_delay) * 1100);
drivers/input/misc/mpu6500/mpu6500_input.c:		cancel_delayed_work_sync(&data->accel_work);
drivers/input/misc/mpu6500/mpu6500_input.c:			cancel_delayed_work_sync(&data->accel_work);
drivers/input/misc/mpu6500/mpu6500_input.c:		cancel_delayed_work_sync(&data->gyro_work);
drivers/input/misc/mpu6500/mpu6500_input.c:			cancel_delayed_work_sync(&data->gyro_work);
drivers/input/misc/mpu6500/mpu6500_input.c:		container_of((struct delayed_work *)work,
drivers/input/misc/mpu6500/mpu6500_input.c:		container_of((struct delayed_work *)work,
drivers/input/misc/mpu6500/mpu6500_input.c-	} else {
drivers/input/misc/mpu6500/mpu6500_input.c-	} else {
drivers/input/misc/mpu6500/mpu6500_input.c-#endif
drivers/input/misc/mpu6500/mpu6500_input.c-#endif
drivers/input/misc/mpu6500/mpu6500_input.c-#endif
drivers/input/misc/mpu6500/mpu6500_input.c-		if (atomic_read(&data->accel_enable))
drivers/input/misc/mpu6500/mpu6500_input.c-		if (atomic_read(&data->accel_enable))
drivers/input/misc/mpu6500/mpu6500_input.c-		if (atomic_read(&data->gyro_enable))
drivers/input/misc/mpu6500/mpu6500_input.c-		if (atomic_read(&data->gyro_enable))
drivers/input/misc/mpu6500/mpu6500_input.c-	if (!atomic_read(&data->reactive_enable)) {
drivers/input/misc/mpu6500/mpu6500_input.c-#ifdef CONFIG_INPUT_MPU6500_POLLING
drivers/input/misc/mpu6500/mpu6500_input.c-#ifdef CONFIG_INPUT_MPU6500_POLLING
drivers/input/misc/mpu6500/mpu6500_input.c-#ifdef CONFIG_INPUT_MPU6500_POLLING
drivers/input/misc/mpu6500/mpu6500_input.c-	if (!value && atomic_read(&data->accel_enable)) {
drivers/input/misc/mpu6500/mpu6500_input.c-	if (!value && atomic_read(&data->gyro_enable)) {
drivers/input/misc/mpu6500/mpu6500_input.c-		mpu6500_input_activate_devices(data,
drivers/input/misc/mpu6500/mpu6500_input.c-		mpu6500_input_activate_devices(data,
drivers/input/misc/mpu6500/mpu6500_input.c-		mpu6500_input_activate_devices(data,
drivers/input/misc/mpu6500/mpu6500_input.c-	mpu6500_input_report_accel_xyz(data);
drivers/input/misc/mpu6500/mpu6500_input.c-			MPU6500_SENSOR_ACCEL, false);
drivers/input/misc/mpu6500/mpu6500_input.c-			MPU6500_SENSOR_ACCEL, true);
drivers/input/misc/mpu6500/mpu6500_input.c-			MPU6500_SENSOR_GYRO, false);
drivers/input/misc/mpu6500/mpu6500_input.c-			MPU6500_SENSOR_GYRO, true);
drivers/input/misc/mpu6500/mpu6500_input.c-			msecs_to_jiffies(
drivers/input/misc/mpu6500/mpu6500_input.c-			msecs_to_jiffies(
drivers/input/misc/mpu6500/mpu6500_input.c-			msecs_to_jiffies(5));
drivers/input/misc/mpu6500/mpu6500_input.c:		schedule_delayed_work(&data->accel_work,
drivers/input/misc/mpu6500/mpu6500_input.c:			schedule_delayed_work(&data->accel_work, 0);
drivers/input/misc/mpu6500/mpu6500_input.c:		schedule_delayed_work(&data->accel_work, 0);
drivers/input/misc/mpu6500/mpu6500_input.c:		schedule_delayed_work(&data->accel_work, msecs_to_jiffies(5));
drivers/input/misc/mpu6500/mpu6500_input.c:		schedule_delayed_work(&data->gyro_work,
drivers/input/misc/mpu6500/mpu6500_input.c:		schedule_delayed_work(&data->gyro_work,
drivers/input/misc/mpu6500/mpu6500_input.c:			schedule_delayed_work(&data->gyro_work, 0);
drivers/input/misc/mpu6500/mpu6500_input.c:		schedule_delayed_work(&data->gyro_work, 0);
drivers/input/misc/mpu6500/mpu6500_input.c:	struct delayed_work accel_work;
drivers/input/misc/mpu6500/mpu6500_input.c:	struct delayed_work gyro_work;
drivers/input/misc/mpu6500/mpu6500_input.c-	struct device *accel_sensor_device;
drivers/input/misc/mpu6500/mpu6500_input.c-			struct mpu6500_input_data, accel_work);
drivers/input/misc/mpu6500/mpu6500_input.c-	struct mpu6500_input_data *data =
drivers/input/misc/mpu6500/mpu6500_input.c-	struct mpu6500_input_data *data =
drivers/input/misc/mpu6500/mpu6500_input.c-			struct mpu6500_input_data, gyro_work);
drivers/input/misc/mpu6500/mpu6500_input.c-		usleep_range(atomic_read(&data->accel_delay) * 1000,
drivers/input/misc/mpu6500/mpu6500_input.c-		usleep_range(atomic_read(&data->gyro_delay) * 1000,
drivers/input/misc/pmic8058-othc.c-
drivers/input/misc/pmic8058-othc.c-
drivers/input/misc/pmic8058-othc.c-
drivers/input/misc/pmic8058-othc.c-}
drivers/input/misc/pmic8058-othc.c-};
drivers/input/misc/pmic8058-othc.c-		}
drivers/input/misc/pmic8058-othc.c-			}
drivers/input/misc/pmic8058-othc.c-		/* Accessory has been inserted, report with detection delay */
drivers/input/misc/pmic8058-othc.c:		cancel_delayed_work_sync(&dd->detect_work);
drivers/input/misc/pmic8058-othc.c:		cancel_delayed_work_sync(&dd->hs_work);
drivers/input/misc/pmic8058-othc.c-	dd->othc_ir_state = !rc;
drivers/input/misc/pmic8058-othc.c-	disable_irq_nosync(dd->othc_irq_ir);
drivers/input/misc/pmic8058-othc.c-		disable_irq_nosync(dd->othc_irq_ir);
drivers/input/misc/pmic8058-othc.c-	/* disable irq, this gets enabled in the workqueue */
drivers/input/misc/pmic8058-othc.c-	} else {
drivers/input/misc/pmic8058-othc.c-		free_irq(dd->othc_irq_ir, dd);
drivers/input/misc/pmic8058-othc.c-		free_irq(dd->othc_irq_sw, dd);
drivers/input/misc/pmic8058-othc.c-				msecs_to_jiffies(dd->detection_delay_ms));
drivers/input/misc/pmic8058-othc.c-				msecs_to_jiffies(dd->detection_delay_ms));
drivers/input/misc/pmic8058-othc.c-	return IRQ_HANDLED;
drivers/input/misc/pmic8058-othc.c:	schedule_delayed_work(&dd->detect_work,
drivers/input/misc/pmic8058-othc.c:		schedule_delayed_work(&dd->detect_work,
drivers/input/misc/pmic8058-othc.c:	schedule_delayed_work(&dd->hs_work, 0);
drivers/input/misc/pmic8058-othc.c:	struct delayed_work detect_work;
drivers/input/misc/pmic8058-othc.c:	struct delayed_work hs_work;
drivers/input/misc/pmic8058-othc.c-	struct othc_n_switch_config *switch_config;
drivers/input/misc/pmic8058-othc.c-	struct work_struct switch_work;
drivers/input/misc/wm831x-on.c-
drivers/input/misc/wm831x-on.c-
drivers/input/misc/wm831x-on.c-
drivers/input/misc/wm831x-on.c-
drivers/input/misc/wm831x-on.c-
drivers/input/misc/wm831x-on.c-}
drivers/input/misc/wm831x-on.c-};
drivers/input/misc/wm831x-on.c:	cancel_delayed_work_sync(&wm831x_on->work);
drivers/input/misc/wm831x-on.c-	free_irq(irq, wm831x_on);
drivers/input/misc/wm831x-on.c-	if (poll)
drivers/input/misc/wm831x-on.c-	input_unregister_device(wm831x_on->dev);
drivers/input/misc/wm831x-on.c-	kfree(wm831x_on);
drivers/input/misc/wm831x-on.c-	return IRQ_HANDLED;
drivers/input/misc/wm831x-on.c:	schedule_delayed_work(&wm831x_on->work, 0);
drivers/input/misc/wm831x-on.c:		schedule_delayed_work(&wm831x_on->work, 100);
drivers/input/misc/wm831x-on.c:	struct delayed_work work;
drivers/input/misc/wm831x-on.c-	struct input_dev *dev;
drivers/input/misc/wm831x-on.c-struct wm831x_on {
drivers/input/misc/wm831x-on.c-	struct wm831x_on *wm831x_on = data;
drivers/input/misc/wm831x-on.c-	struct wm831x *wm831x;
drivers/input/mouse/psmouse-base.c-
drivers/input/mouse/psmouse-base.c-
drivers/input/mouse/psmouse-base.c-{
drivers/input/mouse/psmouse-base.c-}
drivers/input/mouse/psmouse-base.c-}
drivers/input/mouse/psmouse-base.c:	queue_delayed_work(kpsmoused_wq, work, delay);
drivers/input/mouse/psmouse-base.c-		unsigned long delay)
drivers/input/mouse/psmouse-base.c:void psmouse_queue_work(struct psmouse *psmouse, struct delayed_work *work,
drivers/input/mouse/synaptics_i2c.c-
drivers/input/mouse/synaptics_i2c.c-
drivers/input/mouse/synaptics_i2c.c-
drivers/input/mouse/synaptics_i2c.c-
drivers/input/mouse/synaptics_i2c.c-
drivers/input/mouse/synaptics_i2c.c-
drivers/input/mouse/synaptics_i2c.c:	cancel_delayed_work_sync(&touch->dwork);
drivers/input/mouse/synaptics_i2c.c:	cancel_delayed_work_sync(&touch->dwork);
drivers/input/mouse/synaptics_i2c.c-	int			no_data_count;
drivers/input/mouse/synaptics_i2c.c:	mod_delayed_work(system_wq, &touch->dwork, delay);
drivers/input/mouse/synaptics_i2c.c-	/* Save some power */
drivers/input/mouse/synaptics_i2c.c-	/* Save some power */
drivers/input/mouse/synaptics_i2c.c-	spin_lock_irqsave(&touch->lock, flags);
drivers/input/mouse/synaptics_i2c.c-	spinlock_t		lock;
drivers/input/mouse/synaptics_i2c.c-	spin_unlock_irqrestore(&touch->lock, flags);
drivers/input/mouse/synaptics_i2c.c:	struct delayed_work	dwork;
drivers/input/mouse/synaptics_i2c.c-	struct i2c_client	*client;
drivers/input/mouse/synaptics_i2c.c-	struct input_dev	*input;
drivers/input/mouse/synaptics_i2c.c-	struct synaptics_i2c *touch = i2c_get_clientdata(client);
drivers/input/mouse/synaptics_i2c.c-		synaptics_i2c_reg_set(touch->client, INTERRUPT_EN_REG, 0);
drivers/input/serio/hp_sdc.c-
drivers/input/serio/hp_sdc.c-
drivers/input/serio/hp_sdc.c-
drivers/input/serio/hp_sdc.c-
drivers/input/serio/hp_sdc.c-	 * and then load the hp_sdc_mlc upper layer driver */
drivers/input/serio/hp_sdc.c:	cancel_delayed_work_sync(&moduleloader_work);
drivers/input/serio/hp_sdc.c-#if defined(__hppa__)
drivers/input/serio/hp_sdc.c-	if (!ret)
drivers/input/serio/hp_sdc.c-	if (unregister_parisc_driver(&hp_sdc_driver))
drivers/input/serio/hp_sdc.c-			msecs_to_jiffies(2000));
drivers/input/serio/hp_sdc.c-		printk(KERN_WARNING PREFIX "Error unregistering HP SDC");
drivers/input/serio/hp_sdc.c:		schedule_delayed_work(&moduleloader_work,
drivers/input/serio/hp_sdc.c-static int __init hp_sdc_init_hppa(struct parisc_device *d);
drivers/input/serio/hp_sdc.c:static struct delayed_work moduleloader_work;
drivers/input/serio/hp_sdc.c-static struct parisc_driver hp_sdc_driver = {
drivers/input/touchscreen/atmel_maxtouch.c-
drivers/input/touchscreen/atmel_maxtouch.c-
drivers/input/touchscreen/atmel_maxtouch.c-
drivers/input/touchscreen/atmel_maxtouch.c-	 * been sent before interrupts were enabled. */
drivers/input/touchscreen/atmel_maxtouch.c:	cancel_delayed_work(&mxt->dwork);
drivers/input/touchscreen/atmel_maxtouch.c:		cancel_delayed_work_sync(&mxt->dwork);
drivers/input/touchscreen/atmel_maxtouch.c-		cdev_del(&mxt->cdev);
drivers/input/touchscreen/atmel_maxtouch.c-		cdev_del(&mxt->cdev_messages);
drivers/input/touchscreen/atmel_maxtouch.c-		class_destroy(mxt->mxt_class);
drivers/input/touchscreen/atmel_maxtouch.c-	disable_irq(mxt->irq);
drivers/input/touchscreen/atmel_maxtouch.c-	disable_irq(mxt->irq);
drivers/input/touchscreen/atmel_maxtouch.c-		disable_irq_nosync(mxt->irq);
drivers/input/touchscreen/atmel_maxtouch.c-	else
drivers/input/touchscreen/atmel_maxtouch.c-	} else
drivers/input/touchscreen/atmel_maxtouch.c-	} else {
drivers/input/touchscreen/atmel_maxtouch.c-		enable_irq(mxt->irq);
drivers/input/touchscreen/atmel_maxtouch.c-		enable_irq(mxt->irq);
drivers/input/touchscreen/atmel_maxtouch.c:	flush_delayed_work(&mxt->dwork);
drivers/input/touchscreen/atmel_maxtouch.c-	for (i = 0; i < T7_DATA_SIZE; i++)
drivers/input/touchscreen/atmel_maxtouch.c-	if (mxt->read_chg() == 0)
drivers/input/touchscreen/atmel_maxtouch.c-	if (mxt->read_chg() == 0){
drivers/input/touchscreen/atmel_maxtouch.c-		input_unregister_device(mxt->input);
drivers/input/touchscreen/atmel_maxtouch.c-	int                  bytes_to_read;
drivers/input/touchscreen/atmel_maxtouch.c-	kfree(id_data);
drivers/input/touchscreen/atmel_maxtouch.c-	kfree(t38_data);
drivers/input/touchscreen/atmel_maxtouch.c-	/* Make sure we just didn't miss a interrupt. */
drivers/input/touchscreen/atmel_maxtouch.c-	/* Make sure we just didn't miss a interrupt. */
drivers/input/touchscreen/atmel_maxtouch.c-		mxt->valid_irq_counter++;
drivers/input/touchscreen/atmel_maxtouch.c-	/* Schedule a worker routine to read any messages that might have
drivers/input/touchscreen/atmel_maxtouch.c:		schedule_delayed_work(&mxt->dwork, 0);
drivers/input/touchscreen/atmel_maxtouch.c:		schedule_delayed_work(&mxt->dwork, 0);
drivers/input/touchscreen/atmel_maxtouch.c:		schedule_delayed_work(&mxt->dwork, 0);
drivers/input/touchscreen/atmel_maxtouch.c:	schedule_delayed_work(&mxt->dwork, 0);
drivers/input/touchscreen/atmel_maxtouch.c-		/* Send the signal only if falling edge generated the irq. */
drivers/input/touchscreen/atmel_maxtouch.c:	struct delayed_work  dwork;
drivers/input/touchscreen/atmel_maxtouch.c-	u8                   xpos_format;
drivers/input/touchscreen/atmel_maxtouch.c-	u8                   ypos_format;
drivers/input/touchscreen/cy8c_ts.c-
drivers/input/touchscreen/cy8c_ts.c-
drivers/input/touchscreen/cy8c_ts.c-
drivers/input/touchscreen/cy8c_ts.c-
drivers/input/touchscreen/cy8c_ts.c-
drivers/input/touchscreen/cy8c_ts.c-
drivers/input/touchscreen/cy8c_ts.c-
drivers/input/touchscreen/cy8c_ts.c-		}
drivers/input/touchscreen/cy8c_ts.c:	cancel_delayed_work_sync(&ts->work);
drivers/input/touchscreen/cy8c_ts.c-	device_init_wakeup(&client->dev, 0);
drivers/input/touchscreen/cy8c_ts.c-	disable_irq_nosync(irq);
drivers/input/touchscreen/cy8c_ts.c-		disable_irq_nosync(ts->pen_irq);
drivers/input/touchscreen/cy8c_ts.c-	free_irq(ts->pen_irq, ts);
drivers/input/touchscreen/cy8c_ts.c-		if (rc) {
drivers/input/touchscreen/cy8c_ts.c-		mutex_unlock(&ts->sus_lock);
drivers/input/touchscreen/cy8c_ts.c:			queue_delayed_work(ts->wq, &ts->work, 0);
drivers/input/touchscreen/cy8c_ts.c:	queue_delayed_work(ts->wq, &ts->work, 0);
drivers/input/touchscreen/cy8c_ts.c:		rc = cancel_delayed_work_sync(&ts->work);
drivers/input/touchscreen/cy8c_ts.c-	return IRQ_HANDLED;
drivers/input/touchscreen/cy8c_ts.c-			/* start a delayed work */
drivers/input/touchscreen/cy8c_ts.c-	struct cy8c_ts_platform_data *pdata;
drivers/input/touchscreen/cy8c_ts.c:	struct delayed_work work;
drivers/input/touchscreen/cy8c_ts.c-	struct i2c_client *client;
drivers/input/touchscreen/cy8c_ts.c-	struct input_dev *input;
drivers/input/touchscreen/cy8c_ts.c-	struct workqueue_struct *wq;
drivers/input/touchscreen/cyttsp4_mt_common.c-
drivers/input/touchscreen/cyttsp4_mt_common.c-
drivers/input/touchscreen/cyttsp4_mt_common.c-
drivers/input/touchscreen/cyttsp4_mt_common.c-		}
drivers/input/touchscreen/cyttsp4_mt_common.c-		}
drivers/input/touchscreen/cyttsp4_mt_common.c:			cancel_delayed_work(&md->work_dvfs_chg);
drivers/input/touchscreen/cyttsp4_mt_common.c:			cancel_delayed_work(&md->work_dvfs_chg);
drivers/input/touchscreen/cyttsp4_mt_common.c:		cancel_delayed_work(&md->work_dvfs_off);
drivers/input/touchscreen/cyttsp4_mt_common.c:			cancel_delayed_work(&md->work_dvfs_off);
drivers/input/touchscreen/cyttsp4_mt_common.c-	} else if (on < 0) {
drivers/input/touchscreen/cyttsp4_mt_common.c-	} else if (on > 0) {
drivers/input/touchscreen/cyttsp4_mt_common.c-							__func__, ret);
drivers/input/touchscreen/cyttsp4_mt_common.c-				if (md->dvfs_freq != MIN_TOUCH_LIMIT) {
drivers/input/touchscreen/cyttsp4_mt_common.c-		if (md->dvfs_lock_status) {
drivers/input/touchscreen/cyttsp4_mt_common.c-		if (md->dvfs_lock_status) {
drivers/input/touchscreen/cyttsp4_mt_common.c-		if (md->dvfs_old_status != on) {
drivers/input/touchscreen/cyttsp4_mt_common.c-	if (on == 0) {
drivers/input/touchscreen/cyttsp4_mt_common.c-				msecs_to_jiffies(TOUCH_BOOSTER_CHG_TIME));
drivers/input/touchscreen/cyttsp4_mt_common.c-			printk(KERN_INFO "[TSP] DVFS_touch_release\n");
drivers/input/touchscreen/cyttsp4_mt_common.c-					ret = set_freq_limit(DVFS_TOUCH_ID,
drivers/input/touchscreen/cyttsp4_mt_common.c:			schedule_delayed_work(&md->work_dvfs_chg,
drivers/input/touchscreen/cyttsp4_mt_common.c:			schedule_delayed_work(&md->work_dvfs_off,msecs_to_jiffies(TOUCH_BOOSTER_OFF_TIME));
drivers/input/touchscreen/cyttsp4_mt_common.c-			schedule_work(&md->work_dvfs_off.work);
drivers/input/touchscreen/da9034-ts.c-
drivers/input/touchscreen/da9034-ts.c-
drivers/input/touchscreen/da9034-ts.c-
drivers/input/touchscreen/da9034-ts.c-
drivers/input/touchscreen/da9034-ts.c:	cancel_delayed_work_sync(&touch->tsi_work);
drivers/input/touchscreen/da9034-ts.c-			DA9034_EVENT_PEN_DOWN | DA9034_EVENT_TSI_READY);
drivers/input/touchscreen/da9034-ts.c-		if (event == EVENT_PEN_DOWN) {
drivers/input/touchscreen/da9034-ts.c-				msecs_to_jiffies(touch->interval_ms));
drivers/input/touchscreen/da9034-ts.c-			report_pen_down(touch);
drivers/input/touchscreen/da9034-ts.c:			schedule_delayed_work(&touch->tsi_work,
drivers/input/touchscreen/da9034-ts.c:	struct delayed_work	tsi_work;
drivers/input/touchscreen/da9034-ts.c-	struct input_dev	*input_dev;
drivers/input/touchscreen/da9034-ts.c-	struct notifier_block	notifier;
drivers/input/touchscreen/da9034-ts.c-	touch->state = STATE_IDLE;
drivers/input/touchscreen/da9034-ts.c-			touch->state = STATE_WAIT;
drivers/input/touchscreen/hp680_ts_input.c-
drivers/input/touchscreen/hp680_ts_input.c-
drivers/input/touchscreen/hp680_ts_input.c-{
drivers/input/touchscreen/hp680_ts_input.c-{
drivers/input/touchscreen/hp680_ts_input.c-}
drivers/input/touchscreen/hp680_ts_input.c:	cancel_delayed_work_sync(&work);
drivers/input/touchscreen/hp680_ts_input.c:	cancel_delayed_work_sync(&work);
drivers/input/touchscreen/hp680_ts_input.c-	disable_irq_nosync(irq);
drivers/input/touchscreen/hp680_ts_input.c- fail1:	input_free_device(hp680_ts_dev);
drivers/input/touchscreen/hp680_ts_input.c- fail2:	free_irq(HP680_TS_IRQ, NULL);
drivers/input/touchscreen/hp680_ts_input.c-	free_irq(HP680_TS_IRQ, NULL);
drivers/input/touchscreen/hp680_ts_input.c-	input_unregister_device(hp680_ts_dev);
drivers/input/touchscreen/hp680_ts_input.c-	return err;
drivers/input/touchscreen/hp680_ts_input.c-	return IRQ_HANDLED;
drivers/input/touchscreen/hp680_ts_input.c:	schedule_delayed_work(&work, HZ / 20);
drivers/input/touchscreen/ili210x.c-
drivers/input/touchscreen/ili210x.c-
drivers/input/touchscreen/ili210x.c-
drivers/input/touchscreen/ili210x.c-
drivers/input/touchscreen/ili210x.c-}
drivers/input/touchscreen/ili210x.c-};
drivers/input/touchscreen/ili210x.c-	bool (*get_pendown_state)(void);
drivers/input/touchscreen/ili210x.c:	cancel_delayed_work_sync(&priv->dwork);
drivers/input/touchscreen/ili210x.c-	free_irq(priv->client->irq, priv);
drivers/input/touchscreen/ili210x.c-	if ((touchdata.status & 0xf3) || get_pendown_state(priv))
drivers/input/touchscreen/ili210x.c-	input_unregister_device(priv->input);
drivers/input/touchscreen/ili210x.c-	kfree(priv);
drivers/input/touchscreen/ili210x.c-				      msecs_to_jiffies(priv->poll_period));
drivers/input/touchscreen/ili210x.c-	return IRQ_HANDLED;
drivers/input/touchscreen/ili210x.c:		schedule_delayed_work(&priv->dwork,
drivers/input/touchscreen/ili210x.c:	schedule_delayed_work(&priv->dwork, 0);
drivers/input/touchscreen/ili210x.c:	struct delayed_work dwork;
drivers/input/touchscreen/ili210x.c-	struct ili210x *priv = irq_data;
drivers/input/touchscreen/ili210x.c-	sysfs_remove_group(&client->dev.kobj, &ili210x_attr_group);
drivers/input/touchscreen/ili210x.c-	unsigned int poll_period;
drivers/input/touchscreen/lge_touch_core.c-
drivers/input/touchscreen/lge_touch_core.c-
drivers/input/touchscreen/lge_touch_core.c-
drivers/input/touchscreen/lge_touch_core.c-
drivers/input/touchscreen/lge_touch_core.c-
drivers/input/touchscreen/lge_touch_core.c-
drivers/input/touchscreen/lge_touch_core.c-
drivers/input/touchscreen/lge_touch_core.c-{
drivers/input/touchscreen/lge_touch_core.c-}
drivers/input/touchscreen/lge_touch_core.c- *
drivers/input/touchscreen/lge_touch_core.c- */
drivers/input/touchscreen/lge_touch_core.c:	cancel_delayed_work_sync(&ts->work_init);
drivers/input/touchscreen/lge_touch_core.c:	cancel_delayed_work_sync(&ts->work_init);
drivers/input/touchscreen/lge_touch_core.c:		cancel_delayed_work_sync(&ts->work_touch_lock);
drivers/input/touchscreen/lge_touch_core.c:		cancel_delayed_work_sync(&ts->work_touch_lock);
drivers/input/touchscreen/lge_touch_core.c-	cancel_work_sync(&ts->work);
drivers/input/touchscreen/lge_touch_core.c-	cancel_work_sync(&ts->work);
drivers/input/touchscreen/lge_touch_core.c:			container_of(to_delayed_work(work_init),
drivers/input/touchscreen/lge_touch_core.c-	else
drivers/input/touchscreen/lge_touch_core.c-#endif
drivers/input/touchscreen/lge_touch_core.c-	if (ts->pdata->role->key_type == TOUCH_HARD_KEY)
drivers/input/touchscreen/lge_touch_core.c-	if (ts->pdata->role->key_type == TOUCH_HARD_KEY)
drivers/input/touchscreen/lge_touch_core.c-	if (ts->pdata->role->resume_pwr == POWER_ON)
drivers/input/touchscreen/lge_touch_core.c- * In order to reduce the booting-time,
drivers/input/touchscreen/lge_touch_core.c-			msecs_to_jiffies(ts->pdata->role->booting_delay));
drivers/input/touchscreen/lge_touch_core.c:		queue_delayed_work(touch_wq, &ts->work_init,
drivers/input/touchscreen/lge_touch_core.c:		queue_delayed_work(touch_wq, &ts->work_init, 0);
drivers/input/touchscreen/lge_touch_core.c:	queue_delayed_work(touch_wq, &ts->work_init, msecs_to_jiffies(10));
drivers/input/touchscreen/lge_touch_core.c-	release_all_ts_event(ts);
drivers/input/touchscreen/lge_touch_core.c-	release_all_ts_event(ts);
drivers/input/touchscreen/lge_touch_core.c-	return 0;
drivers/input/touchscreen/lge_touch_core.c-	safety_reset(ts);
drivers/input/touchscreen/lge_touch_core.c-static void touch_init_func(struct work_struct *work_init)
drivers/input/touchscreen/lge_touch_core.c-	struct lge_touch_data *ts =
drivers/input/touchscreen/lge_touch_core.c-					struct lge_touch_data, work_init);
drivers/input/touchscreen/lge_touch_core.c-	ts->ic_init_err_cnt++;
drivers/input/touchscreen/lge_touch_core.c: * we used delayed_work_queue instead of msleep or mdelay.
drivers/input/touchscreen/mc13783_ts.c-
drivers/input/touchscreen/mc13783_ts.c-
drivers/input/touchscreen/mc13783_ts.c-
drivers/input/touchscreen/mc13783_ts.c-}
drivers/input/touchscreen/mc13783_ts.c-	 */
drivers/input/touchscreen/mc13783_ts.c:	cancel_delayed_work_sync(&priv->work);
drivers/input/touchscreen/mc13783_ts.c-	 * delay is HZ / 50 which is acceptable.
drivers/input/touchscreen/mc13783_ts.c-			dev_dbg(&idev->dev, "report (%d, %d, %d)\n",
drivers/input/touchscreen/mc13783_ts.c-			dev_dbg(&idev->dev, "report release\n");
drivers/input/touchscreen/mc13783_ts.c-		} else
drivers/input/touchscreen/mc13783_ts.c-	mc13xxx_unlock(priv->mc13xxx);
drivers/input/touchscreen/mc13783_ts.c:	queue_delayed_work(priv->workq, &priv->work, 0);
drivers/input/touchscreen/mc13783_ts.c:			queue_delayed_work(priv->workq, &priv->work, HZ / 50);
drivers/input/touchscreen/mc13783_ts.c-	return IRQ_HANDLED;
drivers/input/touchscreen/mc13783_ts.c:	struct delayed_work work;
drivers/input/touchscreen/mc13783_ts.c-	struct input_dev *idev;
drivers/input/touchscreen/mc13783_ts.c-	struct mc13xxx *mc13xxx;
drivers/input/touchscreen/mc13783_ts.c-	struct workqueue_struct *workq;
drivers/input/touchscreen/mc13783_ts.c-	unsigned int sample[4];
drivers/input/touchscreen/mc13783_ts.c-					x1, y1, 0x1000 - cr0);
drivers/input/touchscreen/mms_ts_144.c-
drivers/input/touchscreen/mms_ts_144.c-	}
drivers/input/touchscreen/mms_ts_144.c-		}
drivers/input/touchscreen/mms_ts_144.c-		}
drivers/input/touchscreen/mms_ts_144.c-	bool	dvfs_lock_status;
drivers/input/touchscreen/mms_ts_144.c:		cancel_delayed_work(&info->work_dvfs_chg);
drivers/input/touchscreen/mms_ts_144.c:			cancel_delayed_work(&info->work_dvfs_chg);
drivers/input/touchscreen/mms_ts_144.c:		cancel_delayed_work(&info->work_dvfs_off);
drivers/input/touchscreen/mms_ts_144.c:		cancel_delayed_work(&info->work_dvfs_off);
drivers/input/touchscreen/mms_ts_144.c-	} else if (on == 1) {
drivers/input/touchscreen/mms_ts_144.c-	} else if (on == 2) {
drivers/input/touchscreen/mms_ts_144.c-#ifdef TOUCH_BOOSTER
drivers/input/touchscreen/mms_ts_144.c-		if (!info->dvfs_lock_status) {
drivers/input/touchscreen/mms_ts_144.c-		if (info->dvfs_lock_status) {
drivers/input/touchscreen/mms_ts_144.c-	if (on == 0) {
drivers/input/touchscreen/mms_ts_144.c-			info->dvfs_lock_status = true;
drivers/input/touchscreen/mms_ts_144.c-				msecs_to_jiffies(TOUCH_BOOSTER_CHG_TIME));
drivers/input/touchscreen/mms_ts_144.c-				msecs_to_jiffies(TOUCH_BOOSTER_OFF_TIME));
drivers/input/touchscreen/mms_ts_144.c-				pr_err("%s: cpu lock failed %d\n", __func__, ret);
drivers/input/touchscreen/mms_ts_144.c-			ret = set_freq_limit(DVFS_TOUCH_ID, MIN_TOUCH_LIMIT);
drivers/input/touchscreen/mms_ts_144.c:			schedule_delayed_work(&info->work_dvfs_chg,
drivers/input/touchscreen/mms_ts_144.c:			schedule_delayed_work(&info->work_dvfs_off,
drivers/input/touchscreen/mms_ts_144.c-		schedule_work(&info->work_dvfs_off.work);
drivers/input/touchscreen/mms_ts_144.c:	struct delayed_work	work_dvfs_chg;
drivers/input/touchscreen/mms_ts_144.c:	struct delayed_work work_dvfs_off;
drivers/input/touchscreen/mms_ts_144.c-	struct mutex dvfs_lock;
drivers/input/touchscreen/mms_ts_144.c-	struct power_suspend		power_suspend;
drivers/input/touchscreen/mxt224e.c-
drivers/input/touchscreen/mxt224e.c-	}
drivers/input/touchscreen/mxt224e.c-		}
drivers/input/touchscreen/mxt224e.c-		}
drivers/input/touchscreen/mxt224e.c-	bool	dvfs_lock_status;
drivers/input/touchscreen/mxt224e.c:		cancel_delayed_work(&data->work_dvfs_chg);
drivers/input/touchscreen/mxt224e.c:			cancel_delayed_work(&data->work_dvfs_chg);
drivers/input/touchscreen/mxt224e.c:		cancel_delayed_work(&data->work_dvfs_off);
drivers/input/touchscreen/mxt224e.c:		cancel_delayed_work(&data->work_dvfs_off);
drivers/input/touchscreen/mxt224e.c-			data->dvfs_lock_status = true;
drivers/input/touchscreen/mxt224e.c-	} else if (on == 1) {
drivers/input/touchscreen/mxt224e.c-	} else if (on == 2) {
drivers/input/touchscreen/mxt224e.c-							__func__, ret, ret2);
drivers/input/touchscreen/mxt224e.c-		if (!data->dvfs_lock_status) {
drivers/input/touchscreen/mxt224e.c-		if (data->dvfs_lock_status) {
drivers/input/touchscreen/mxt224e.c-	if (on == 0) {
drivers/input/touchscreen/mxt224e.c-#if TOUCH_BOOSTER
drivers/input/touchscreen/mxt224e.c-				msecs_to_jiffies(TOUCH_BOOSTER_CHG_TIME));
drivers/input/touchscreen/mxt224e.c-				msecs_to_jiffies(TOUCH_BOOSTER_OFF_TIME));
drivers/input/touchscreen/mxt224e.c-			ret = cpufreq_set_limit(TOUCH_BOOSTER_SECOND_START, 0);
drivers/input/touchscreen/mxt224e.c:			schedule_delayed_work(&data->work_dvfs_chg,
drivers/input/touchscreen/mxt224e.c:			schedule_delayed_work(&data->work_dvfs_off,
drivers/input/touchscreen/mxt224e.c-		schedule_work(&data->work_dvfs_off.work);
drivers/input/touchscreen/mxt224e.c:	struct delayed_work	work_dvfs_chg;
drivers/input/touchscreen/mxt224e.c:	struct delayed_work work_dvfs_off;
drivers/input/touchscreen/mxt224e.c-	struct mutex dvfs_lock;
drivers/input/touchscreen/mxt224e.c-	struct power_suspend power_suspend;
drivers/input/touchscreen/mxts.c-
drivers/input/touchscreen/mxts.c-
drivers/input/touchscreen/mxts.c-
drivers/input/touchscreen/mxts.c-
drivers/input/touchscreen/mxts.c-}
drivers/input/touchscreen/mxts.c-	}
drivers/input/touchscreen/mxts.c-	}
drivers/input/touchscreen/mxts.c-		}
drivers/input/touchscreen/mxts.c-		}
drivers/input/touchscreen/mxts.c:		cancel_delayed_work(&data->work_dvfs_off);
drivers/input/touchscreen/mxts.c:		cancel_delayed_work(&data->work_dvfs_off);
drivers/input/touchscreen/mxts.c:	cancel_delayed_work_sync(&data->noti_dwork);
drivers/input/touchscreen/mxts.c:	cancel_delayed_work_sync(&data->noti_dwork);
drivers/input/touchscreen/mxts.c-	data->charging_mode = en;
drivers/input/touchscreen/mxts.c-	} else if (on == 1) {
drivers/input/touchscreen/mxts.c-	} else if (on == 2) {
drivers/input/touchscreen/mxts.c-#endif
drivers/input/touchscreen/mxts.c-		if (!data->dvfs_lock_status) {
drivers/input/touchscreen/mxts.c-		if (data->dvfs_lock_status) {
drivers/input/touchscreen/mxts.c-	if (!data->mxt_enabled) {
drivers/input/touchscreen/mxts.c-	if (on == 0) {
drivers/input/touchscreen/mxts.c-#if TSP_INFORM_CHARGER
drivers/input/touchscreen/mxts.c-				msecs_to_jiffies(TOUCH_BOOSTER_OFF_TIME));
drivers/input/touchscreen/mxts.c-								power_suspend);
drivers/input/touchscreen/mxts.c-			ret = set_freq_limit(DVFS_TOUCH_ID, MIN_TOUCH_LIMIT);
drivers/input/touchscreen/mxts.c-		return ;
drivers/input/touchscreen/mxts.c:		schedule_delayed_work(&data->noti_dwork, HZ / 5);
drivers/input/touchscreen/mxts.c:	schedule_delayed_work(&data->noti_dwork, HZ / 5);
drivers/input/touchscreen/mxts.c:			schedule_delayed_work(&data->work_dvfs_off,
drivers/input/touchscreen/mxts.c-		schedule_work(&data->work_dvfs_off.work);
drivers/input/touchscreen/mxts.c-			struct mxt_data, callbacks);
drivers/input/touchscreen/mxts_msm8930.c-
drivers/input/touchscreen/mxts_msm8930.c-
drivers/input/touchscreen/mxts_msm8930.c-
drivers/input/touchscreen/mxts_msm8930.c-
drivers/input/touchscreen/mxts_msm8930.c-}
drivers/input/touchscreen/mxts_msm8930.c-	}
drivers/input/touchscreen/mxts_msm8930.c:	cancel_delayed_work_sync(&data->noti_dwork);
drivers/input/touchscreen/mxts_msm8930.c:	cancel_delayed_work_sync(&data->noti_dwork);
drivers/input/touchscreen/mxts_msm8930.c-	data->charging_mode = en;
drivers/input/touchscreen/mxts_msm8930.c-#endif
drivers/input/touchscreen/mxts_msm8930.c-	if (!data->mxt_enabled) {
drivers/input/touchscreen/mxts_msm8930.c-#if TSP_INFORM_CHARGER
drivers/input/touchscreen/mxts_msm8930.c-								power_suspend);
drivers/input/touchscreen/mxts_msm8930.c-		return;
drivers/input/touchscreen/mxts_msm8930.c-		return ;
drivers/input/touchscreen/mxts_msm8930.c:		schedule_delayed_work(&data->noti_dwork, HZ / 5);
drivers/input/touchscreen/mxts_msm8930.c:	schedule_delayed_work(&data->noti_dwork, HZ / 5);
drivers/input/touchscreen/mxts_sec_msm8930.c-		}
drivers/input/touchscreen/mxts_sec_msm8930.c-		}
drivers/input/touchscreen/mxts_sec_msm8930.c-			}
drivers/input/touchscreen/mxts_sec_msm8930.c:			cancel_delayed_work(&data->booster.work_dvfs_chg);
drivers/input/touchscreen/mxts_sec_msm8930.c:			cancel_delayed_work(&data->booster.work_dvfs_chg);
drivers/input/touchscreen/mxts_sec_msm8930.c:			cancel_delayed_work(&data->booster.work_dvfs_chg);
drivers/input/touchscreen/mxts_sec_msm8930.c:		cancel_delayed_work(&data->booster.work_dvfs_off);
drivers/input/touchscreen/mxts_sec_msm8930.c:			cancel_delayed_work(&data->booster.work_dvfs_off);
drivers/input/touchscreen/mxts_sec_msm8930.c-			data->booster.dvfs_lock_status = true;
drivers/input/touchscreen/mxts_sec_msm8930.c-	} else if (on < 0) {
drivers/input/touchscreen/mxts_sec_msm8930.c-	} else if (on > 0) {
drivers/input/touchscreen/mxts_sec_msm8930.c-				__func__, ret);
drivers/input/touchscreen/mxts_sec_msm8930.c-			if (data->booster.dvfs_freq != MIN_TOUCH_LIMIT) {
drivers/input/touchscreen/mxts_sec_msm8930.c-		if (data->booster.dvfs_lock_status) {
drivers/input/touchscreen/mxts_sec_msm8930.c-		if (data->booster.dvfs_lock_status) {
drivers/input/touchscreen/mxts_sec_msm8930.c-		if (data->booster.dvfs_old_stauts != on) {
drivers/input/touchscreen/mxts_sec_msm8930.c-	if (on == 0) {
drivers/input/touchscreen/mxts_sec_msm8930.c-				msecs_to_jiffies(TOUCH_BOOSTER_CHG_TIME));
drivers/input/touchscreen/mxts_sec_msm8930.c-				msecs_to_jiffies(TOUCH_BOOSTER_OFF_TIME));
drivers/input/touchscreen/mxts_sec_msm8930.c-				ret = set_freq_limit(DVFS_TOUCH_ID,
drivers/input/touchscreen/mxts_sec_msm8930.c:			schedule_delayed_work(&data->booster.work_dvfs_chg,
drivers/input/touchscreen/mxts_sec_msm8930.c:			schedule_delayed_work(&data->booster.work_dvfs_off,
drivers/input/touchscreen/mxts_sec_msm8930.c-			schedule_work(&data->booster.work_dvfs_off.work);
drivers/input/touchscreen/pcap_ts.c-
drivers/input/touchscreen/pcap_ts.c-
drivers/input/touchscreen/pcap_ts.c-
drivers/input/touchscreen/pcap_ts.c-
drivers/input/touchscreen/pcap_ts.c-
drivers/input/touchscreen/pcap_ts.c-
drivers/input/touchscreen/pcap_ts.c-
drivers/input/touchscreen/pcap_ts.c-{
drivers/input/touchscreen/pcap_ts.c-	}
drivers/input/touchscreen/pcap_ts.c-		}
drivers/input/touchscreen/pcap_ts.c-		break;
drivers/input/touchscreen/pcap_ts.c:	cancel_delayed_work_sync(&pcap_ts->work);
drivers/input/touchscreen/pcap_ts.c:	cancel_delayed_work_sync(&pcap_ts->work);
drivers/input/touchscreen/pcap_ts.c-	case PCAP_ADC_TS_M_XY:
drivers/input/touchscreen/pcap_ts.c-		} else {
drivers/input/touchscreen/pcap_ts.c-	free_irq(pcap_to_irq(pcap_ts->pcap, PCAP_IRQ_TS), pcap_ts);
drivers/input/touchscreen/pcap_ts.c-	if (pcap_ts->read_state == PCAP_ADC_TS_M_STANDBY) {
drivers/input/touchscreen/pcap_ts.c-	input_unregister_device(pcap_ts->input);
drivers/input/touchscreen/pcap_ts.c-					msecs_to_jiffies(SAMPLE_DELAY));
drivers/input/touchscreen/pcap_ts.c-			pcap_ts->pressure = res[0];
drivers/input/touchscreen/pcap_ts.c-	pcap_ts->read_state = PCAP_ADC_TS_M_NONTS;
drivers/input/touchscreen/pcap_ts.c-			pcap_ts->read_state = PCAP_ADC_TS_M_PRESSURE;
drivers/input/touchscreen/pcap_ts.c-		pcap_ts->read_state = PCAP_ADC_TS_M_PRESSURE;
drivers/input/touchscreen/pcap_ts.c-			pcap_ts->read_state = PCAP_ADC_TS_M_STANDBY;
drivers/input/touchscreen/pcap_ts.c-	pcap_ts->read_state = PCAP_ADC_TS_M_STANDBY;
drivers/input/touchscreen/pcap_ts.c-		pcap_ts->read_state = PCAP_ADC_TS_M_XY;
drivers/input/touchscreen/pcap_ts.c-			/* pen is touching the screen */
drivers/input/touchscreen/pcap_ts.c-	return 0;
drivers/input/touchscreen/pcap_ts.c-	return IRQ_HANDLED;
drivers/input/touchscreen/pcap_ts.c:			schedule_delayed_work(&pcap_ts->work,
drivers/input/touchscreen/pcap_ts.c:			schedule_delayed_work(&pcap_ts->work, 0);
drivers/input/touchscreen/pcap_ts.c:		schedule_delayed_work(&pcap_ts->work, 0);
drivers/input/touchscreen/pcap_ts.c:		schedule_delayed_work(&pcap_ts->work, 0);
drivers/input/touchscreen/pcap_ts.c:	schedule_delayed_work(&pcap_ts->work, 0);
drivers/input/touchscreen/pcap_ts.c-static void pcap_ts_work(struct work_struct *work)
drivers/input/touchscreen/pcap_ts.c:	struct delayed_work *dw = container_of(work, struct delayed_work, work);
drivers/input/touchscreen/pcap_ts.c:	struct delayed_work work;
drivers/input/touchscreen/pcap_ts.c-	struct input_dev *input;
drivers/input/touchscreen/pcap_ts.c-	struct pcap_chip *pcap;
drivers/input/touchscreen/pcap_ts.c-	struct pcap_ts *pcap_ts = container_of(dw, struct pcap_ts, work);
drivers/input/touchscreen/pcap_ts.c-	struct pcap_ts *pcap_ts = input_get_drvdata(dev);
drivers/input/touchscreen/pcap_ts.c-			/* switch back to pressure read mode */
drivers/input/touchscreen/pcap_ts.c-	u16 pressure;
drivers/input/touchscreen/pcap_ts.c-	u16 x, y;
drivers/input/touchscreen/pcap_ts.c-	u8 ch[2];
drivers/input/touchscreen/rmi_f54.c-
drivers/input/touchscreen/rmi_f54.c-{
drivers/input/touchscreen/rmi_f54.c-					0);
drivers/input/touchscreen/rmi_f54.c:	cancel_delayed_work_sync(&f54->status_work);
drivers/input/touchscreen/rmi_f54.c-	destroy_workqueue(f54->status_workqueue);
drivers/input/touchscreen/rmi_f54.c-		} else {
drivers/input/touchscreen/rmi_f54.c-#endif
drivers/input/touchscreen/rmi_f54.c-			f54->status = STATUS_ERROR;
drivers/input/touchscreen/rmi_f54.c-				&f54->status_work,
drivers/input/touchscreen/rmi_f54.c-					&f54->status_work,
drivers/input/touchscreen/rmi_f54.c-	flush_workqueue(f54->status_workqueue);
drivers/input/touchscreen/rmi_f54.c-	if (f54->intr_mask & intr_mask) {
drivers/input/touchscreen/rmi_f54.c-				msecs_to_jiffies(STATUS_WORK_INTERVAL));
drivers/input/touchscreen/rmi_f54.c:		queue_delayed_work(f54->status_workqueue,
drivers/input/touchscreen/rmi_f54.c:			queue_delayed_work(f54->status_workqueue,
drivers/input/touchscreen/rmi_f54.c:	struct delayed_work status_work;
drivers/input/touchscreen/rmi_f54.c-	struct hrtimer watchdog;
drivers/input/touchscreen/rmi_f54.c-	struct synaptics_rmi4_exp_fn_ptr *fn_ptr;
drivers/input/touchscreen/rmi_f54.c-	struct workqueue_struct *status_workqueue;
drivers/input/touchscreen/rmi_f54.c-	struct work_struct timeout_work;
drivers/input/touchscreen/rmi_f54_msm8930.c-
drivers/input/touchscreen/rmi_f54_msm8930.c-{
drivers/input/touchscreen/rmi_f54_msm8930.c-					0);
drivers/input/touchscreen/rmi_f54_msm8930.c:	cancel_delayed_work_sync(&f54->status_work);
drivers/input/touchscreen/rmi_f54_msm8930.c-	destroy_workqueue(f54->status_workqueue);
drivers/input/touchscreen/rmi_f54_msm8930.c-		} else {
drivers/input/touchscreen/rmi_f54_msm8930.c-#endif
drivers/input/touchscreen/rmi_f54_msm8930.c-			f54->status = -ETIMEDOUT;
drivers/input/touchscreen/rmi_f54_msm8930.c-				&f54->status_work,
drivers/input/touchscreen/rmi_f54_msm8930.c-					&f54->status_work,
drivers/input/touchscreen/rmi_f54_msm8930.c-	flush_workqueue(f54->status_workqueue);
drivers/input/touchscreen/rmi_f54_msm8930.c-	if ((f54->intr_mask & intr_mask) && (!f54->bypass_interrupt)) {
drivers/input/touchscreen/rmi_f54_msm8930.c-				msecs_to_jiffies(STATUS_WORK_INTERVAL));
drivers/input/touchscreen/rmi_f54_msm8930.c:		queue_delayed_work(f54->status_workqueue,
drivers/input/touchscreen/rmi_f54_msm8930.c:			queue_delayed_work(f54->status_workqueue,
drivers/input/touchscreen/rmi_f54_msm8930.c:	struct delayed_work status_work;
drivers/input/touchscreen/rmi_f54_msm8930.c-	struct hrtimer watchdog;
drivers/input/touchscreen/rmi_f54_msm8930.c-	struct synaptics_rmi4_exp_fn_ptr *fn_ptr;
drivers/input/touchscreen/rmi_f54_msm8930.c-	struct workqueue_struct *status_workqueue;
drivers/input/touchscreen/rmi_f54_msm8930.c-	struct work_struct timeout_work;
drivers/input/touchscreen/stmpe-ts.c-
drivers/input/touchscreen/stmpe-ts.c-
drivers/input/touchscreen/stmpe-ts.c-
drivers/input/touchscreen/stmpe-ts.c-
drivers/input/touchscreen/stmpe-ts.c-
drivers/input/touchscreen/stmpe-ts.c-	/*
drivers/input/touchscreen/stmpe-ts.c-	 */
drivers/input/touchscreen/stmpe-ts.c-	 * available. Wait if the polling is already running.
drivers/input/touchscreen/stmpe-ts.c:	cancel_delayed_work_sync(&ts->work);
drivers/input/touchscreen/stmpe-ts.c:	cancel_delayed_work_sync(&ts->work);
drivers/input/touchscreen/stmpe-ts.c-	return IRQ_HANDLED;
drivers/input/touchscreen/stmpe-ts.c:	schedule_delayed_work(&ts->work, HZ / 50);
drivers/input/touchscreen/stmpe-ts.c-	/* start polling for touch_det to detect release */
drivers/input/touchscreen/stmpe-ts.c-	stmpe_set_bits(ts->stmpe, STMPE_REG_TSC_CTRL,
drivers/input/touchscreen/stmpe-ts.c:	struct delayed_work work;
drivers/input/touchscreen/stmpe-ts.c-	struct device *dev;
drivers/input/touchscreen/stmpe-ts.c-	struct input_dev *idev;
drivers/input/touchscreen/stmpe-ts.c-	struct stmpe *stmpe;
drivers/input/touchscreen/stmpe-ts.c-	struct stmpe_touch *ts = input_get_drvdata(dev);
drivers/input/touchscreen/stmpe-ts.c-	u8 sample_time;
drivers/input/touchscreen/sweep2sleep.c-
drivers/input/touchscreen/sweep2sleep.c-}
drivers/input/touchscreen/sweep2sleep.c-	input_report_key(sweep2sleep_pwrdev, KEY_SLEEP, 1);
drivers/input/touchscreen/sweep2sleep.c-	input_sync(sweep2sleep_pwrdev);
drivers/input/touchscreen/sweep2sleep.c:	schedule_delayed_work(&sweep2sleep_releasepwr_work, msecs_to_jiffies(S2S_PWRKEY_DUR));
drivers/input/touchscreen/sweep2sleep.c-static DEFINE_MUTEX(pwrkeyworklock);
drivers/input/touchscreen/sweep2sleep.c:static struct delayed_work sweep2sleep_releasepwr_work;
drivers/input/touchscreen/sweep2sleep.c-static struct workqueue_struct *s2s_input_wq;
drivers/input/touchscreen/sweep2sleep.c-static struct work_struct sweep2sleep_presspwr_work;
drivers/input/touchscreen/sweep2sleep.c-static void sweep2sleep_releasepwr(struct work_struct *work);
drivers/input/touchscreen/synaptics_fw_update.c-};
drivers/input/touchscreen/synaptics_fw_update.c-	char *firmware_name;
drivers/input/touchscreen/synaptics_fw_update.c-			&fwu->fwu_work,
drivers/input/touchscreen/synaptics_fw_update.c-	fwu->fwu_workqueue = create_singlethread_workqueue("fwu_workqueue");
drivers/input/touchscreen/synaptics_fw_update.c-	INIT_DELAYED_WORK(&fwu->fwu_work, synaptics_rmi4_fwu_work);
drivers/input/touchscreen/synaptics_fw_update.c-			msecs_to_jiffies(1000));
drivers/input/touchscreen/synaptics_fw_update.c:	queue_delayed_work(fwu->fwu_workqueue,
drivers/input/touchscreen/synaptics_fw_update.c:	struct delayed_work fwu_work;
drivers/input/touchscreen/synaptics_fw_update.c-	struct f34_flash_properties flash_properties;
drivers/input/touchscreen/synaptics_fw_update.c-	struct workqueue_struct *fwu_workqueue;
drivers/input/touchscreen/synaptics_i2c_rmi4.c-
drivers/input/touchscreen/synaptics_i2c_rmi4.c-
drivers/input/touchscreen/synaptics_i2c_rmi4.c:	cancel_delayed_work_sync(&rmi4_data->det_work);
drivers/input/touchscreen/synaptics_i2c_rmi4.c:	cancel_delayed_work_sync(&rmi4_data->det_work);
drivers/input/touchscreen/synaptics_i2c_rmi4.c-	destroy_workqueue(rmi4_data->det_workqueue);
drivers/input/touchscreen/synaptics_i2c_rmi4.c-	destroy_workqueue(rmi4_data->det_workqueue);
drivers/input/touchscreen/synaptics_i2c_rmi4.c-err_enable_irq:
drivers/input/touchscreen/synaptics_i2c_rmi4.c-	flush_workqueue(rmi4_data->det_workqueue);
drivers/input/touchscreen/synaptics_i2c_rmi4.c-	flush_workqueue(rmi4_data->det_workqueue);
drivers/input/touchscreen/synaptics_i2c_rmi4.c-	INIT_DELAYED_WORK(&rmi4_data->det_work,
drivers/input/touchscreen/synaptics_i2c_rmi4.c-			msecs_to_jiffies(EXP_FN_DET_INTERVAL));
drivers/input/touchscreen/synaptics_i2c_rmi4.c:	queue_delayed_work(rmi4_data->det_workqueue,
drivers/input/touchscreen/synaptics_i2c_rmi4.c-			&rmi4_data->det_work,
drivers/input/touchscreen/synaptics_i2c_rmi4.c-	rmi = &(rmi4_data->rmi4_mod_info);
drivers/input/touchscreen/synaptics_i2c_rmi4.c-			synaptics_rmi4_detection_work);
drivers/input/touchscreen/synaptics_i2c_rmi.c-{
drivers/input/touchscreen/synaptics_i2c_rmi.c-}
drivers/input/touchscreen/synaptics_i2c_rmi.c-	} else {
drivers/input/touchscreen/synaptics_i2c_rmi.c-#endif
drivers/input/touchscreen/synaptics_i2c_rmi.c-	if (!touch_display_status) {
drivers/input/touchscreen/synaptics_i2c_rmi.c-	INIT_DELAYED_WORK(&rmi4_data->work_init_power_on,
drivers/input/touchscreen/synaptics_i2c_rmi.c-					msecs_to_jiffies(1000));
drivers/input/touchscreen/synaptics_i2c_rmi.c-				msecs_to_jiffies(300));
drivers/input/touchscreen/synaptics_i2c_rmi.c-					msecs_to_jiffies(6000));
drivers/input/touchscreen/synaptics_i2c_rmi.c-			pr_debug("rmi-couldn't do the thing");
drivers/input/touchscreen/synaptics_i2c_rmi.c:	schedule_delayed_work(&rmi4_data->work_init_power_on,
drivers/input/touchscreen/synaptics_i2c_rmi.c:			schedule_delayed_work(&rmi4_data->work_init_power_on,
drivers/input/touchscreen/synaptics_i2c_rmi.c:	schedule_delayed_work(&rmi4_data->work_rezero,
drivers/input/touchscreen/synaptics_i2c_rmi.c-					synaptics_init_power_on);
drivers/input/touchscreen/synaptics_i2c_rmi.c-void synaptics_rmi4_f51_set_custom_rezero(struct synaptics_rmi4_data *rmi4_data)
drivers/input/touchscreen/synaptics_i2c_rmi_msm8930.c-
drivers/input/touchscreen/synaptics_i2c_rmi_msm8930.c-
drivers/input/touchscreen/synaptics_i2c_rmi_msm8930.c-
drivers/input/touchscreen/synaptics_i2c_rmi_msm8930.c-{
drivers/input/touchscreen/synaptics_i2c_rmi_msm8930.c-}
drivers/input/touchscreen/synaptics_i2c_rmi_msm8930.c-		}
drivers/input/touchscreen/synaptics_i2c_rmi_msm8930.c-		}
drivers/input/touchscreen/synaptics_i2c_rmi_msm8930.c-				}
drivers/input/touchscreen/synaptics_i2c_rmi_msm8930.c:			cancel_delayed_work(&rmi4_data->work_dvfs_chg);
drivers/input/touchscreen/synaptics_i2c_rmi_msm8930.c:			cancel_delayed_work(&rmi4_data->work_dvfs_chg);
drivers/input/touchscreen/synaptics_i2c_rmi_msm8930.c:		cancel_delayed_work(&rmi4_data->work_dvfs_off);
drivers/input/touchscreen/synaptics_i2c_rmi_msm8930.c:			cancel_delayed_work(&rmi4_data->work_dvfs_off);
drivers/input/touchscreen/synaptics_i2c_rmi_msm8930.c-	} else if (on < 0) {
drivers/input/touchscreen/synaptics_i2c_rmi_msm8930.c-	} else if (on > 0) {
drivers/input/touchscreen/synaptics_i2c_rmi_msm8930.c-#endif
drivers/input/touchscreen/synaptics_i2c_rmi_msm8930.c-			if (1/*!rmi4_data->dvfs_lock_status*/) {
drivers/input/touchscreen/synaptics_i2c_rmi_msm8930.c-	if (on == 0) {
drivers/input/touchscreen/synaptics_i2c_rmi_msm8930.c-				if (rmi4_data->dvfs_freq != MIN_TOUCH_LIMIT) {
drivers/input/touchscreen/synaptics_i2c_rmi_msm8930.c-		if (rmi4_data->dvfs_lock_status) {
drivers/input/touchscreen/synaptics_i2c_rmi_msm8930.c-		if (rmi4_data->dvfs_lock_status) {
drivers/input/touchscreen/synaptics_i2c_rmi_msm8930.c-		if (rmi4_data->dvfs_old_stauts != on) {
drivers/input/touchscreen/synaptics_i2c_rmi_msm8930.c-	INIT_DELAYED_WORK(&rmi4_data->work_init_power_on,
drivers/input/touchscreen/synaptics_i2c_rmi_msm8930.c-				msecs_to_jiffies(300));
drivers/input/touchscreen/synaptics_i2c_rmi_msm8930.c-					msecs_to_jiffies(6000));
drivers/input/touchscreen/synaptics_i2c_rmi_msm8930.c-				msecs_to_jiffies(TOUCH_BOOSTER_CHG_TIME));
drivers/input/touchscreen/synaptics_i2c_rmi_msm8930.c-				msecs_to_jiffies(TOUCH_BOOSTER_OFF_TIME));
drivers/input/touchscreen/synaptics_i2c_rmi_msm8930.c:			schedule_delayed_work(&rmi4_data->work_dvfs_chg,
drivers/input/touchscreen/synaptics_i2c_rmi_msm8930.c:			schedule_delayed_work(&rmi4_data->work_dvfs_off,
drivers/input/touchscreen/synaptics_i2c_rmi_msm8930.c:	schedule_delayed_work(&rmi4_data->work_init_power_on,
drivers/input/touchscreen/synaptics_i2c_rmi_msm8930.c:	schedule_delayed_work(&rmi4_data->work_rezero,
drivers/input/touchscreen/synaptics_i2c_rmi_msm8930.c-			schedule_work(&rmi4_data->work_dvfs_off.work);
drivers/input/touchscreen/synaptics_i2c_rmi_msm8930.c-					synaptics_init_power_on);
drivers/input/touchscreen/synaptics_i2c_rmi_msm8930.c-void synaptics_rmi4_f51_set_custom_rezero(struct synaptics_rmi4_data *rmi4_data)
drivers/input/touchscreen/tps6507x-ts.c-
drivers/input/touchscreen/tps6507x-ts.c-
drivers/input/touchscreen/tps6507x-ts.c-
drivers/input/touchscreen/tps6507x-ts.c-
drivers/input/touchscreen/tps6507x-ts.c-
drivers/input/touchscreen/tps6507x-ts.c-
drivers/input/touchscreen/tps6507x-ts.c:	cancel_delayed_work_sync(&tsc->work);
drivers/input/touchscreen/tps6507x-ts.c:	cancel_delayed_work_sync(&tsc->work);
drivers/input/touchscreen/tps6507x-ts.c-	char			phys[32];
drivers/input/touchscreen/tps6507x-ts.c-err1:
drivers/input/touchscreen/tps6507x-ts.c-err2:
drivers/input/touchscreen/tps6507x-ts.c-		goto err2;
drivers/input/touchscreen/tps6507x-ts.c-	if (poll) {
drivers/input/touchscreen/tps6507x-ts.c-		if (schd)
drivers/input/touchscreen/tps6507x-ts.c-	input_free_device(input_dev);
drivers/input/touchscreen/tps6507x-ts.c-	input_unregister_device(input_dev);
drivers/input/touchscreen/tps6507x-ts.c-				     msecs_to_jiffies(tsc->poll_period));
drivers/input/touchscreen/tps6507x-ts.c-					msecs_to_jiffies(tsc->poll_period));
drivers/input/touchscreen/tps6507x-ts.c:		schd = schedule_delayed_work(&tsc->work,
drivers/input/touchscreen/tps6507x-ts.c:	schd = schedule_delayed_work(&tsc->work,
drivers/input/touchscreen/tps6507x-ts.c:	struct delayed_work	work;
drivers/input/touchscreen/tps6507x-ts.c-	struct device		*dev;
drivers/input/touchscreen/tps6507x-ts.c-	struct input_dev *input_dev = tsc->input_dev;
drivers/input/touchscreen/tps6507x-ts.c-	struct ts_event		tc;
drivers/input/touchscreen/tps6507x-ts.c-	unsigned		polling;	/* polling is active */
drivers/input/touchscreen/tsc2005.c-
drivers/input/touchscreen/tsc2005.c-
drivers/input/touchscreen/tsc2005.c-
drivers/input/touchscreen/tsc2005.c-
drivers/input/touchscreen/tsc2005.c:	cancel_delayed_work_sync(&ts->esd_work);
drivers/input/touchscreen/tsc2005.c-	del_timer_sync(&ts->penup_timer);
drivers/input/touchscreen/tsc2005.c-	enable_irq(ts->spi->irq);
drivers/input/touchscreen/tsc2005.c-	if (ts->esd_timeout && ts->set_reset) {
drivers/input/touchscreen/tsc2005.c-					msecs_to_jiffies(ts->esd_timeout)));
drivers/input/touchscreen/tsc2005.c-					msecs_to_jiffies(ts->esd_timeout)));
drivers/input/touchscreen/tsc2005.c-	/* re-arm the watchdog */
drivers/input/touchscreen/tsc2005.c-reschedule:
drivers/input/touchscreen/tsc2005.c-			      round_jiffies_relative(
drivers/input/touchscreen/tsc2005.c-				round_jiffies_relative(
drivers/input/touchscreen/tsc2005.c:	schedule_delayed_work(&ts->esd_work,
drivers/input/touchscreen/tsc2005.c:		schedule_delayed_work(&ts->esd_work,
drivers/input/touchscreen/tsc2005.c:	struct delayed_work	esd_work;
drivers/input/touchscreen/tsc2005.c-		ts->last_valid_interrupt = jiffies;
drivers/input/touchscreen/tsc2005.c-	unsigned int		esd_timeout;
drivers/input/touchscreen/tsc2005.c-	unsigned long		last_valid_interrupt;
drivers/input/touchscreen/tsc2007.c-
drivers/input/touchscreen/tsc2007.c-
drivers/input/touchscreen/tsc2007.c-
drivers/input/touchscreen/tsc2007.c-{
drivers/input/touchscreen/tsc2007.c-{
drivers/input/touchscreen/tsc2007.c-	}
drivers/input/touchscreen/tsc2007.c-		/*
drivers/input/touchscreen/tsc2007.c-	bool debounced = false;
drivers/input/touchscreen/tsc2007.c-	char			phys[32];
drivers/input/touchscreen/tsc2007.c:		container_of(to_delayed_work(work), struct tsc2007, work);
drivers/input/touchscreen/tsc2007.c-		disable_irq_nosync(ts->irq);
drivers/input/touchscreen/tsc2007.c-	disable_irq(ts->irq);
drivers/input/touchscreen/tsc2007.c-	else
drivers/input/touchscreen/tsc2007.c-		enable_irq(ts->irq);
drivers/input/touchscreen/tsc2007.c-	free_irq(ts->irq, ts);
drivers/input/touchscreen/tsc2007.c:	if (cancel_delayed_work_sync(&ts->work))
drivers/input/touchscreen/tsc2007.c:	if (cancel_delayed_work_sync(&ts->work)) {
drivers/input/touchscreen/tsc2007.c-	if (!ts->get_pendown_state || likely(ts->get_pendown_state())) {
drivers/input/touchscreen/tsc2007.c-	if (ts->pendown || debounced)
drivers/input/touchscreen/tsc2007.c-				      msecs_to_jiffies(ts->poll_delay));
drivers/input/touchscreen/tsc2007.c-				      msecs_to_jiffies(ts->poll_period));
drivers/input/touchscreen/tsc2007.c- out:
drivers/input/touchscreen/tsc2007.c:		schedule_delayed_work(&ts->work,
drivers/input/touchscreen/tsc2007.c:		schedule_delayed_work(&ts->work,
drivers/input/touchscreen/tsc2007.c:	struct delayed_work	work;
drivers/input/touchscreen/tsc2007.c-	struct i2c_client	*client;
drivers/input/touchscreen/tsc2007.c-	struct input_dev	*input;
drivers/input/touchscreen/tsc2007.c-	struct tsc2007 *ts =
drivers/input/touchscreen/tsc2007.c-	struct ts_event tc;
drivers/input/touchscreen/tsc2007.c-		 * Work was pending, therefore we need to enable
drivers/input/touchscreen/wm97xx-core.c-
drivers/input/touchscreen/wm97xx-core.c-
drivers/input/touchscreen/wm97xx-core.c-
drivers/input/touchscreen/wm97xx-core.c-
drivers/input/touchscreen/wm97xx-core.c-
drivers/input/touchscreen/wm97xx-core.c-
drivers/input/touchscreen/wm97xx-core.c-}
drivers/input/touchscreen/wm97xx-core.c-	}
drivers/input/touchscreen/wm97xx-core.c-	 */
drivers/input/touchscreen/wm97xx-core.c-	 */
drivers/input/touchscreen/wm97xx-core.c-		}
drivers/input/touchscreen/wm97xx-core.c-	 * before we destroy the workqueue.
drivers/input/touchscreen/wm97xx-core.c:	cancel_delayed_work_sync(&wm->ts_reader);
drivers/input/touchscreen/wm97xx-core.c:		cancel_delayed_work_sync(&wm->ts_reader);
drivers/input/touchscreen/wm97xx-core.c-			/* Data is not available immediately on pen down */
drivers/input/touchscreen/wm97xx-core.c-	destroy_workqueue(wm->ts_workq);
drivers/input/touchscreen/wm97xx-core.c-	if (wm->input_dev->users)
drivers/input/touchscreen/wm97xx-core.c-	if (wm->input_dev->users && !wm->pen_irq) {
drivers/input/touchscreen/wm97xx-core.c-	if (wm->pen_irq == 0)
drivers/input/touchscreen/wm97xx-core.c-		if (wm->pen_is_down && !pen_was_down) {
drivers/input/touchscreen/wm97xx-core.c-	if (wm->pen_is_down || !wm->pen_irq)
drivers/input/touchscreen/wm97xx-core.c-	/* Power down the digitiser (bypassing the cache for resume) */
drivers/input/touchscreen/wm97xx-core.c:		queue_delayed_work(wm->ts_workq, &wm->ts_reader,
drivers/input/touchscreen/wm97xx-core.c:		queue_delayed_work(wm->ts_workq, &wm->ts_reader,
drivers/input/touchscreen/wm97xx-core.c:		queue_delayed_work(wm->ts_workq, &wm->ts_reader,
drivers/input/touchscreen/wm97xx-core.c:			queue_delayed_work(wm->ts_workq, &wm->ts_reader, 1);
drivers/input/touchscreen/wm97xx-core.c-				   wm->ts_reader_interval);
drivers/input/touchscreen/wm97xx-core.c-				   wm->ts_reader_interval);
drivers/input/touchscreen/wm97xx-core.c-				   wm->ts_reader_interval);
drivers/input/touchscreen/wm97xx-core.c-		wm->ts_reader_interval = wm->ts_reader_min_interval;
drivers/macintosh/rack-meter.c-
drivers/macintosh/rack-meter.c-
drivers/macintosh/rack-meter.c-{
drivers/macintosh/rack-meter.c-}
drivers/macintosh/rack-meter.c-}
drivers/macintosh/rack-meter.c-	}
drivers/macintosh/rack-meter.c-	}
drivers/macintosh/rack-meter.c:	cancel_delayed_work_sync(&rm->cpu[0].sniffer);
drivers/macintosh/rack-meter.c:	cancel_delayed_work_sync(&rm->cpu[1].sniffer);
drivers/macintosh/rack-meter.c-	cputime64_t		prev_wall;
drivers/macintosh/rack-meter.c-				 msecs_to_jiffies(CPU_SAMPLING_RATE));
drivers/macintosh/rack-meter.c-					 msecs_to_jiffies(CPU_SAMPLING_RATE));
drivers/macintosh/rack-meter.c-		mutex_unlock(&rm->sem);
drivers/macintosh/rack-meter.c-		rcpu->prev_idle = get_cpu_idle_time(cpu);
drivers/macintosh/rack-meter.c-		rcpu->prev_wall = jiffies64_to_cputime64(get_jiffies_64());
drivers/macintosh/rack-meter.c:	schedule_delayed_work_on(cpu, &rcpu->sniffer,
drivers/macintosh/rack-meter.c:		schedule_delayed_work_on(cpu, &rm->cpu[cpu].sniffer,
drivers/macintosh/rack-meter.c-static void rackmeter_stop_cpu_sniffer(struct rackmeter *rm)
drivers/macintosh/rack-meter.c:	struct delayed_work	sniffer;
drivers/macintosh/rack-meter.c-struct rackmeter_cpu {
drivers/macintosh/rack-meter.c-	struct rackmeter	*rm;
drivers/md/bcache/btree.c-
drivers/md/bcache/btree.c-
drivers/md/bcache/btree.c-
drivers/md/bcache/btree.c-
drivers/md/bcache/btree.c-
drivers/md/bcache/btree.c-
drivers/md/bcache/btree.c-
drivers/md/bcache/btree.c-
drivers/md/bcache/btree.c-
drivers/md/bcache/btree.c-{
drivers/md/bcache/btree.c-	}
drivers/md/bcache/btree.c-	bch_check_keys(&b->keys, "writing");
drivers/md/bcache/btree.c:	cancel_delayed_work(&b->work);
drivers/md/bcache/btree.c:	cancel_delayed_work(&b->work);
drivers/md/bcache/btree.c:		cancel_delayed_work_sync(&b->work);
drivers/md/bcache/btree.c-	closure_return_with_destructor(cl, btree_node_write_unlock);
drivers/md/bcache/btree.c-	if (!btree_node_dirty(b))
drivers/md/bcache/btree.c-	if (btree_node_dirty(b))
drivers/md/bcache/btree.c-	/* If caller isn't waiting for write, parent refcount is cache set */
drivers/md/bcache/btree.c-		kfree(b);
drivers/md/bcache/btree.c-		list_del(&b->list);
drivers/md/bcache/btree.c-	mutex_lock(&b->c->bucket_lock);
drivers/md/bcache/btree.c-	mutex_lock(&b->write_lock);
drivers/md/bcache/btree.c-	mutex_unlock(&b->write_lock);
drivers/md/bcache/btree.c:		schedule_delayed_work(&b->work, 30 * HZ);
drivers/md/bcache/btree.c:		schedule_delayed_work(&b->work, 30 * HZ);
drivers/md/bcache/btree.c-	set_btree_node_dirty(b);
drivers/md/bcache/btree.c-static void btree_node_write_work(struct work_struct *w)
drivers/md/bcache/btree.c:	struct btree *b = container_of(to_delayed_work(w), struct btree, work);
drivers/md/bcache/btree.c-				     struct btree, list);
drivers/md/bcache/journal.c-{
drivers/md/bcache/journal.c-	} else if (!w->dirty) {
drivers/md/bcache/journal.c-					   journal.work);
drivers/md/bcache/journal.c-				      msecs_to_jiffies(c->journal_delay_ms));
drivers/md/bcache/journal.c:		schedule_delayed_work(&c->journal.work,
drivers/md/bcache/journal.c-		spin_unlock(&c->journal.lock);
drivers/md/bcache/journal.c-static void journal_write_work(struct work_struct *work)
drivers/md/bcache/journal.c-					   struct cache_set,
drivers/md/bcache/journal.c:	struct cache_set *c = container_of(to_delayed_work(work),
drivers/md/bcache/journal.c-		w->dirty = true;
drivers/md/bcache/sysfs.c-
drivers/md/bcache/sysfs.c-
drivers/md/bcache/sysfs.c-				      dc->writeback_rate_update_seconds * HZ);
drivers/md/bcache/sysfs.c-	if (attr == &sysfs_writeback_percent)
drivers/md/bcache/sysfs.c:		schedule_delayed_work(&dc->writeback_rate_update,
drivers/md/bcache/writeback.c-
drivers/md/bcache/writeback.c-
drivers/md/bcache/writeback.c-
drivers/md/bcache/writeback.c-{
drivers/md/bcache/writeback.c-}
drivers/md/bcache/writeback.c-			      dc->writeback_rate_update_seconds * HZ);
drivers/md/bcache/writeback.c-			      dc->writeback_rate_update_seconds * HZ);
drivers/md/bcache/writeback.c-	INIT_DELAYED_WORK(&dc->writeback_rate_update, update_writeback_rate);
drivers/md/bcache/writeback.c:	schedule_delayed_work(&dc->writeback_rate_update,
drivers/md/bcache/writeback.c:	schedule_delayed_work(&dc->writeback_rate_update,
drivers/md/bcache/writeback.c-static void update_writeback_rate(struct work_struct *work)
drivers/md/bcache/writeback.c-					     struct cached_dev,
drivers/md/bcache/writeback.c:	struct cached_dev *dc = container_of(to_delayed_work(work),
drivers/md/bcache/writeback.c-	up_read(&dc->writeback_lock);
drivers/md/bcache/writeback.c-					     writeback_rate_update);
drivers/md/dm-bufio.c-
drivers/md/dm-bufio.c-
drivers/md/dm-bufio.c-
drivers/md/dm-bufio.c-
drivers/md/dm-bufio.c-
drivers/md/dm-bufio.c-
drivers/md/dm-bufio.c-
drivers/md/dm-bufio.c-}
drivers/md/dm-bufio.c:	cancel_delayed_work_sync(&dm_bufio_work);
drivers/md/dm-bufio.c-	cleanup_old_buffers();
drivers/md/dm-bufio.c-	destroy_workqueue(dm_bufio_wq);
drivers/md/dm-bufio.c-			   DM_BUFIO_WORK_TIMER_SECS * HZ);
drivers/md/dm-bufio.c-			   DM_BUFIO_WORK_TIMER_SECS * HZ);
drivers/md/dm-bufio.c-	INIT_DELAYED_WORK(&dm_bufio_work, work_fn);
drivers/md/dm-bufio.c-	int i;
drivers/md/dm-bufio.c:	queue_delayed_work(dm_bufio_wq, &dm_bufio_work,
drivers/md/dm-bufio.c:	queue_delayed_work(dm_bufio_wq, &dm_bufio_work,
drivers/md/dm-bufio.c:static struct delayed_work dm_bufio_work;
drivers/md/dm-bufio.c-static struct workqueue_struct *dm_bufio_wq;
drivers/md/dm-bufio.c-static void work_fn(struct work_struct *w)
drivers/md/dm-cache-target.c-
drivers/md/dm-cache-target.c-
drivers/md/dm-cache-target.c-
drivers/md/dm-cache-target.c-{
drivers/md/dm-cache-target.c-{
drivers/md/dm-cache-target.c-}
drivers/md/dm-cache-target.c-}
drivers/md/dm-cache-target.c:	cancel_delayed_work(&cache->waker);
drivers/md/dm-cache-target.c-	flush_workqueue(cache->wq);
drivers/md/dm-cache-target.c-	policy_tick(cache->policy);
drivers/md/dm-cache-target.c:	queue_delayed_work(cache->wq, &cache->waker, COMMIT_PERIOD);
drivers/md/dm-cache-target.c-static void do_waker(struct work_struct *ws)
drivers/md/dm-cache-target.c-static void stop_worker(struct cache *cache)
drivers/md/dm-cache-target.c:	struct cache *cache = container_of(to_delayed_work(ws), struct cache, waker);
drivers/md/dm-cache-target.c:	struct delayed_work waker;
drivers/md/dm-cache-target.c-	struct work_struct worker;
drivers/md/dm-cache-target.c-	unsigned long last_commit_jiffies;
drivers/md/dm-cache-target.c-	wake_worker(cache);
drivers/md/dm-log-userspace-base.c-
drivers/md/dm-log-userspace-base.c-
drivers/md/dm-log-userspace-base.c-
drivers/md/dm-log-userspace-base.c-	}
drivers/md/dm-log-userspace-base.c-	 */
drivers/md/dm-log-userspace-base.c-	 */
drivers/md/dm-log-userspace-base.c-		 */
drivers/md/dm-log-userspace-base.c-		 */
drivers/md/dm-log-userspace-base.c-		atomic_set(&lc->sched_flush, 0);
drivers/md/dm-log-userspace-base.c-		atomic_set(&lc->sched_flush, 1);
drivers/md/dm-log-userspace-base.c-	atomic_t sched_flush;
drivers/md/dm-log-userspace-base.c:		cancel_delayed_work(&lc->flush_log_work);
drivers/md/dm-log-userspace-base.c-		destroy_workqueue(lc->dmlog_wq);
drivers/md/dm-log-userspace-base.c-	} else {
drivers/md/dm-log-userspace-base.c:		flush_delayed_work(&lc->flush_log_work);
drivers/md/dm-log-userspace-base.c:			flush_delayed_work(&lc->flush_log_work);
drivers/md/dm-log-userspace-base.c-		/* flush workqueue */
drivers/md/dm-log-userspace-base.c-		 * have already flushed in mark_region.
drivers/md/dm-log-userspace-base.c-		if (atomic_read(&lc->sched_flush))
drivers/md/dm-log-userspace-base.c-	if (lc->integrated_flush && atomic_read(&lc->sched_flush))
drivers/md/dm-log-userspace-base.c:		queue_delayed_work(lc->dmlog_wq, &lc->flush_log_work, 3 * HZ);
drivers/md/dm-log-userspace-base.c-	r = dm_consult_userspace(lc->uuid, lc->luid, DM_ULOG_POSTSUSPEND,
drivers/md/dm-log-userspace-base.c:	struct delayed_work flush_log_work;
drivers/md/dm-log-userspace-base.c-	struct workqueue_struct *dmlog_wq;
drivers/md/dm-log-userspace-base.c-		 * we schedule a flush in the future.
drivers/md/dm-mpath.c-
drivers/md/dm-mpath.c-
drivers/md/dm-mpath.c-};
drivers/md/dm-mpath.c-			continue;
drivers/md/dm-mpath.c-		if (!pgpath->is_active)
drivers/md/dm-mpath.c:		if (queue_delayed_work(kmpath_handlerd, &pgpath->activate_path,
drivers/md/dm-mpath.c-			m->pg_init_in_progress++;
drivers/md/dm-mpath.c-				       pg_init_delay))
drivers/md/dm-mpath.c:	struct delayed_work activate_path;
drivers/md/dm-mpath.c-	struct dm_path path;
drivers/md/dm-thin.c-
drivers/md/dm-thin.c-
drivers/md/dm-thin.c-
drivers/md/dm-thin.c-
drivers/md/dm-thin.c-
drivers/md/dm-thin.c-{
drivers/md/dm-thin.c-{
drivers/md/dm-thin.c-}
drivers/md/dm-thin.c:	cancel_delayed_work(&pool->no_space_timeout);
drivers/md/dm-thin.c:	cancel_delayed_work(&pool->waker);
drivers/md/dm-thin.c-	flush_workqueue(pool->wq);
drivers/md/dm-thin.c-					 no_space_timeout);
drivers/md/dm-thin.c:	queue_delayed_work(pool->wq, &pool->waker, COMMIT_PERIOD);
drivers/md/dm-thin.c-static void do_no_space_timeout(struct work_struct *ws)
drivers/md/dm-thin.c-static void do_waker(struct work_struct *ws)
drivers/md/dm-thin.c:	struct delayed_work no_space_timeout;
drivers/md/dm-thin.c:	struct delayed_work waker;
drivers/md/dm-thin.c:	struct pool *pool = container_of(to_delayed_work(ws), struct pool,
drivers/md/dm-thin.c:	struct pool *pool = container_of(to_delayed_work(ws), struct pool, waker);
drivers/md/dm-thin.c-	struct pool *pool = pt->pool;
drivers/md/dm-thin.c-	struct workqueue_struct *wq;
drivers/md/dm-thin.c-	struct work_struct worker;
drivers/md/dm-thin.c-	unsigned ref_count;
drivers/md/dm-thin.c-	wake_worker(pool);
drivers/media/dvb/b2c2/flexcop-pci.c-
drivers/media/dvb/b2c2/flexcop-pci.c-
drivers/media/dvb/b2c2/flexcop-pci.c-
drivers/media/dvb/b2c2/flexcop-pci.c-
drivers/media/dvb/b2c2/flexcop-pci.c-
drivers/media/dvb/b2c2/flexcop-pci.c-}
drivers/media/dvb/b2c2/flexcop-pci.c-};
drivers/media/dvb/b2c2/flexcop-pci.c-	}
drivers/media/dvb/b2c2/flexcop-pci.c-					100 :
drivers/media/dvb/b2c2/flexcop-pci.c:		cancel_delayed_work(&fc_pci->irq_check_work);
drivers/media/dvb/b2c2/flexcop-pci.c-	flexcop_pci_dma_exit(fc_pci);
drivers/media/dvb/b2c2/flexcop-pci.c-	if (irq_chk_intv > 0)
drivers/media/dvb/b2c2/flexcop-pci.c-	if (irq_chk_intv > 0)
drivers/media/dvb/b2c2/flexcop-pci.c-				msecs_to_jiffies(irq_chk_intv < 100 ?
drivers/media/dvb/b2c2/flexcop-pci.c-			msecs_to_jiffies(irq_chk_intv < 100 ? 100 : irq_chk_intv));
drivers/media/dvb/b2c2/flexcop-pci.c:	schedule_delayed_work(&fc_pci->irq_check_work,
drivers/media/dvb/b2c2/flexcop-pci.c:		schedule_delayed_work(&fc_pci->irq_check_work,
drivers/media/dvb/b2c2/flexcop-pci.c:	struct delayed_work irq_check_work;
drivers/media/dvb/b2c2/flexcop-pci.c-	struct flexcop_device *fc_dev;
drivers/media/dvb/b2c2/flexcop-pci.c-	unsigned long last_irq;
drivers/media/dvb/dvb-usb/dvb-usb-remote.c-
drivers/media/dvb/dvb-usb/dvb-usb-remote.c-
drivers/media/dvb/dvb-usb/dvb-usb-remote.c-
drivers/media/dvb/dvb-usb/dvb-usb-remote.c-
drivers/media/dvb/dvb-usb/dvb-usb-remote.c-
drivers/media/dvb/dvb-usb/dvb-usb-remote.c-
drivers/media/dvb/dvb-usb/dvb-usb-remote.c-
drivers/media/dvb/dvb-usb/dvb-usb-remote.c-{
drivers/media/dvb/dvb-usb/dvb-usb-remote.c-}
drivers/media/dvb/dvb-usb/dvb-usb-remote.c-}
drivers/media/dvb/dvb-usb/dvb-usb-remote.c:		cancel_delayed_work_sync(&d->rc_query_work);
drivers/media/dvb/dvb-usb/dvb-usb-remote.c-		err("error %d while querying for an remote control event.", err);
drivers/media/dvb/dvb-usb/dvb-usb-remote.c-		if (d->props.rc.mode == DVB_RC_LEGACY)
drivers/media/dvb/dvb-usb/dvb-usb-remote.c-	if (d->state & DVB_USB_STATE_REMOTE) {
drivers/media/dvb/dvb-usb/dvb-usb-remote.c-	info("schedule remote query interval to %d msecs.", rc_interval);
drivers/media/dvb/dvb-usb/dvb-usb-remote.c-	info("schedule remote query interval to %d msecs.", rc_interval);
drivers/media/dvb/dvb-usb/dvb-usb-remote.c-			input_unregister_device(d->input_dev);
drivers/media/dvb/dvb-usb/dvb-usb-remote.c-			      msecs_to_jiffies(d->props.rc.core.rc_interval));
drivers/media/dvb/dvb-usb/dvb-usb-remote.c-			      msecs_to_jiffies(rc_interval));
drivers/media/dvb/dvb-usb/dvb-usb-remote.c-			      msecs_to_jiffies(rc_interval));
drivers/media/dvb/dvb-usb/dvb-usb-remote.c-schedule:
drivers/media/dvb/dvb-usb/dvb-usb-remote.c:	schedule_delayed_work(&d->rc_query_work,
drivers/media/dvb/dvb-usb/dvb-usb-remote.c:	schedule_delayed_work(&d->rc_query_work,
drivers/media/dvb/dvb-usb/dvb-usb-remote.c:	schedule_delayed_work(&d->rc_query_work,
drivers/media/dvb/dvb-usb/dvb-usb-remote.c:	schedule_delayed_work(&d->rc_query_work,msecs_to_jiffies(d->props.rc.legacy.rc_interval));
drivers/media/dvb/dvb-usb/technisat-usb2.c-
drivers/media/dvb/dvb-usb/technisat-usb2.c-
drivers/media/dvb/dvb-usb/technisat-usb2.c-
drivers/media/dvb/dvb-usb/technisat-usb2.c-}
drivers/media/dvb/dvb-usb/technisat-usb2.c-	}
drivers/media/dvb/dvb-usb/technisat-usb2.c-		}
drivers/media/dvb/dvb-usb/technisat-usb2.c:			cancel_delayed_work_sync(&state->green_led_work);
drivers/media/dvb/dvb-usb/technisat-usb2.c-		if (state != NULL)
drivers/media/dvb/dvb-usb/technisat-usb2.c-			INIT_DELAYED_WORK(&state->green_led_work,
drivers/media/dvb/dvb-usb/technisat-usb2.c-			msecs_to_jiffies(500));
drivers/media/dvb/dvb-usb/technisat-usb2.c-					msecs_to_jiffies(500));
drivers/media/dvb/dvb-usb/technisat-usb2.c-schedule:
drivers/media/dvb/dvb-usb/technisat-usb2.c:	schedule_delayed_work(&state->green_led_work,
drivers/media/dvb/dvb-usb/technisat-usb2.c:			schedule_delayed_work(&state->green_led_work,
drivers/media/dvb/dvb-usb/technisat-usb2.c:	struct delayed_work green_led_work;
drivers/media/dvb/dvb-usb/technisat-usb2.c-	struct dvb_usb_device *dev;
drivers/media/dvb/dvb-usb/technisat-usb2.c-struct technisat_usb2_state {
drivers/media/dvb/dvb-usb/technisat-usb2.c-		struct technisat_usb2_state *state = dev->priv;
drivers/media/dvb/dvb-usb/technisat-usb2.c-					technisat_usb2_green_led_control);
drivers/media/dvb/dvb-usb/technisat-usb2.c-	u8 power_state;
drivers/media/dvb/frontends/af9013.c-
drivers/media/dvb/frontends/af9013.c-
drivers/media/dvb/frontends/af9013.c-
drivers/media/dvb/frontends/af9013.c-
drivers/media/dvb/frontends/af9013.c-
drivers/media/dvb/frontends/af9013.c-
drivers/media/dvb/frontends/af9013.c-
drivers/media/dvb/frontends/af9013.c-};
drivers/media/dvb/frontends/af9013.c-	}
drivers/media/dvb/frontends/af9013.c-	bool i2c_gate_state;
drivers/media/dvb/frontends/af9013.c:	cancel_delayed_work_sync(&state->statistics_work);
drivers/media/dvb/frontends/af9013.c-	/* disable lock led */
drivers/media/dvb/frontends/af9013.c-		msecs_to_jiffies(next_msec));
drivers/media/dvb/frontends/af9013.c-	return ret;
drivers/media/dvb/frontends/af9013.c:	schedule_delayed_work(&state->statistics_work,
drivers/media/dvb/frontends/af9013.c:	schedule_delayed_work(&state->statistics_work, msecs_to_jiffies(400));
drivers/media/dvb/frontends/af9013.c-	state->first_tune = true;
drivers/media/dvb/frontends/af9013.c-	/* stop statistics polling */
drivers/media/dvb/frontends/af9013.c:	struct delayed_work statistics_work;
drivers/media/dvb/frontends/af9013.c-	unsigned int statistics_step:3;
drivers/media/isdbtmm/tuner_drv.c-
drivers/media/isdbtmm/tuner_drv.c-
drivers/media/isdbtmm/tuner_drv.c-
drivers/media/isdbtmm/tuner_drv.c-
drivers/media/isdbtmm/tuner_drv.c-
drivers/media/isdbtmm/tuner_drv.c-
drivers/media/isdbtmm/tuner_drv.c-{
drivers/media/isdbtmm/tuner_drv.c-	
drivers/media/isdbtmm/tuner_drv.c-	
drivers/media/isdbtmm/tuner_drv.c:	cancel_delayed_work(&tmm_chg_ctrl_polling_work);
drivers/media/isdbtmm/tuner_drv.c-	/* recover input charging current */
drivers/media/isdbtmm/tuner_drv.c-	return;
drivers/media/isdbtmm/tuner_drv.c:	schedule_delayed_work(&tmm_chg_ctrl_polling_work, TMM_CHG_CTRL_POLLING_TIME * HZ);
drivers/media/isdbtmm/tuner_drv.c:	schedule_delayed_work(&tmm_chg_ctrl_polling_work, TMM_CHG_CTRL_START_DELAY * HZ);
drivers/media/isdbtmm/tuner_drv.c:static struct delayed_work tmm_chg_ctrl_polling_work;
drivers/media/isdbtmm/tuner_drv.c-static struct isdbtmm_platform_data tmm_chg_ctrl_func;
drivers/media/isdbtmm/tuner_drv.c-static struct wake_lock tmm_chg_ctrl_wlock;
drivers/media/isdbtmm/tuner_drv.c-static struct workqueue_struct *tmm_chg_wqueue;
drivers/media/isdbtmm/tuner_drv.c-static struct work_struct tmm_chg_ctrl_work;
drivers/media/isdbtmm/tuner_drv.c:	tmm_chg_log(KERN_ALERT"%s: cancel_delayed_work(tmm_chg_ctrl_polling_work)!\n", __func__);
drivers/media/isdbtmm/tuner_drv.c-	tmm_chg_log(KERN_ALERT"%s: cancel_work_sync(&tmm_chg_ctrl_work)!\n", __func__);
drivers/media/isdbtmm/tuner_drv.c:	tmm_chg_log(KERN_ALERT"%s: schedule_delayed_work(tmm_chg_ctrl_polling_work, TMM_CHG_CTRL_POLLING_TIME(%d) * HZ(0x%x))!\n", __func__, TMM_CHG_CTRL_POLLING_TIME, HZ);
drivers/media/isdbtmm/tuner_drv.c:	tmm_chg_log(KERN_ALERT"%s: schedule_delayed_work(tmm_chg_ctrl_polling_work, TMM_CHG_CTRL_START_DELAY(%d) * HZ(0x%x))!\n", __func__, TMM_CHG_CTRL_START_DELAY, HZ);
drivers/media/isdbtmm/tuner_drv.c-	tmm_chg_log(KERN_ALERT"%s: tmm_reduce_chg_curr()!\n", __func__);
drivers/media/isdbtmm/tuner_drv.c-void tmm_chg_ctrl_start(void)
drivers/media/isdbtmm/tuner_drv.c-	wake_unlock(&tmm_chg_ctrl_wlock);
drivers/media/radio/radio-tavarua.c-	}
drivers/media/radio/radio-tavarua.c:	cancel_delayed_work_sync(&radio->work);
drivers/media/radio/radio-tavarua.c-	disable_irq_wake(irq);
drivers/media/radio/radio-tavarua.c-exit:
drivers/media/radio/radio-tavarua.c-	flush_workqueue(radio->wqueue);
drivers/media/radio/radio-tavarua.c-	FMDBG("%s, Calling fm_shutdown\n", __func__);
drivers/media/radio/radio-tavarua.c-	free_irq(irq, radio);
drivers/media/radio/radio-tavarua.c-   * function is nonzero if the work_struct was actually added to queue
drivers/media/radio/radio-tavarua.c-				msecs_to_jiffies(TAVARUA_DELAY));
drivers/media/radio/radio-tavarua.c-				msecs_to_jiffies(TAVARUA_DELAY/2));
drivers/media/radio/radio-tavarua.c-   * passes before the work is actually executed. The return value from the
drivers/media/radio/radio-tavarua.c:	queue_delayed_work(radio->wqueue, &radio->work,
drivers/media/radio/radio-tavarua.c:	queue_delayed_work(radio->wqueue, &radio->work,
drivers/media/radio/radio-tavarua.c-	return 0;
drivers/media/radio/radio-tavarua.c-		return -EINVAL;
drivers/media/radio/radio-tavarua.c-	return IRQ_HANDLED;
drivers/media/radio/radio-tavarua.c-	/* schedule a tasklet to handle host intr */
drivers/media/radio/radio-tavarua.c:	struct delayed_work work;
drivers/media/radio/radio-tavarua.c-	struct tavarua_device *radio = dev_id;
drivers/media/radio/radio-tavarua.c-	struct workqueue_struct *wqueue;
drivers/media/radio/radio-tavarua.c-	/* teardown gpio and pmic */
drivers/media/radio/radio-tavarua.c:  /* The call to queue_delayed_work ensures that a minimum delay (in jiffies)
drivers/media/radio/radio-tavarua.c-	/* wait queue for blocking event read */
drivers/media/radio/radio-tavarua.c-	wait_queue_head_t event_queue;
drivers/media/radio/radio-tavarua.c-	/* work queue */
drivers/media/video/em28xx/em28xx-input.c-
drivers/media/video/em28xx/em28xx-input.c-
drivers/media/video/em28xx/em28xx-input.c-
drivers/media/video/em28xx/em28xx-input.c-
drivers/media/video/em28xx/em28xx-input.c-
drivers/media/video/em28xx/em28xx-input.c-
drivers/media/video/em28xx/em28xx-input.c-
drivers/media/video/em28xx/em28xx-input.c-
drivers/media/video/em28xx/em28xx-input.c-}
drivers/media/video/em28xx/em28xx-input.c-}
drivers/media/video/em28xx/em28xx-input.c-}
drivers/media/video/em28xx/em28xx-input.c:		cancel_delayed_work_sync(&dev->sbutton_query_work);
drivers/media/video/em28xx/em28xx-input.c:	cancel_delayed_work_sync(&ir->work);
drivers/media/video/em28xx/em28xx-input.c-	dev->sbutton_input_dev = input_dev;
drivers/media/video/em28xx/em28xx-input.c-		dev->sbutton_input_dev = NULL;
drivers/media/video/em28xx/em28xx-input.c-		em28xx_info("Deregistering snapshot button\n");
drivers/media/video/em28xx/em28xx-input.c-	em28xx_ir_handle_key(ir);
drivers/media/video/em28xx/em28xx-input.c-	if (dev->sbutton_input_dev != NULL) {
drivers/media/video/em28xx/em28xx-input.c-	INIT_DELAYED_WORK(&ir->work, em28xx_ir_work);
drivers/media/video/em28xx/em28xx-input.c-		input_unregister_device(dev->sbutton_input_dev);
drivers/media/video/em28xx/em28xx-input.c-	int polling;
drivers/media/video/em28xx/em28xx-input.c-			      msecs_to_jiffies(EM28XX_SBUTTON_QUERY_INTERVAL));
drivers/media/video/em28xx/em28xx-input.c-			      msecs_to_jiffies(EM28XX_SBUTTON_QUERY_INTERVAL));
drivers/media/video/em28xx/em28xx-input.c-	/* poll external decoder */
drivers/media/video/em28xx/em28xx-input.c-	return;
drivers/media/video/em28xx/em28xx-input.c-	return 0;
drivers/media/video/em28xx/em28xx-input.c:	schedule_delayed_work(&dev->sbutton_query_work,
drivers/media/video/em28xx/em28xx-input.c:	schedule_delayed_work(&dev->sbutton_query_work,
drivers/media/video/em28xx/em28xx-input.c:	schedule_delayed_work(&ir->work, 0);
drivers/media/video/em28xx/em28xx-input.c:	schedule_delayed_work(&ir->work, msecs_to_jiffies(ir->polling));
drivers/media/video/em28xx/em28xx-input.c-	/* Schedule next poll */
drivers/media/video/em28xx/em28xx-input.c:	struct delayed_work work;
drivers/media/video/em28xx/em28xx-input.c-	struct em28xx_IR *ir = rc->priv;
drivers/media/video/em28xx/em28xx-input.c-	unsigned int full_code:1;
drivers/media/video/em28xx/em28xx-input.c-	unsigned int last_readcount;
drivers/media/video/ir-kbd-i2c.c-
drivers/media/video/ir-kbd-i2c.c-
drivers/media/video/ir-kbd-i2c.c-
drivers/media/video/ir-kbd-i2c.c-
drivers/media/video/ir-kbd-i2c.c-
drivers/media/video/ir-kbd-i2c.c-}
drivers/media/video/ir-kbd-i2c.c-	}
drivers/media/video/ir-kbd-i2c.c:	cancel_delayed_work_sync(&ir->work);
drivers/media/video/ir-kbd-i2c.c-	INIT_DELAYED_WORK(&ir->work, ir_work);
drivers/media/video/ir-kbd-i2c.c-	/* kill outstanding polls */
drivers/media/video/ir-kbd-i2c.c-	return 0;
drivers/media/video/ir-kbd-i2c.c:	schedule_delayed_work(&ir->work, 0);
drivers/media/video/ir-kbd-i2c.c:	schedule_delayed_work(&ir->work, msecs_to_jiffies(ir->polling_interval));
drivers/media/video/ir-kbd-i2c.c-	/* start polling via eventd */
drivers/media/video/ir-kbd-i2c.c-	/* unregister device */
drivers/media/video/saa6588.c-
drivers/media/video/saa6588.c-
drivers/media/video/saa6588.c-
drivers/media/video/saa6588.c-
drivers/media/video/saa6588.c-}
drivers/media/video/saa6588.c-}
drivers/media/video/saa6588.c:	cancel_delayed_work_sync(&s->work);
drivers/media/video/saa6588.c-	INIT_DELAYED_WORK(&s->work, saa6588_work);
drivers/media/video/saa6588.c-	kfree(s->buffer);
drivers/media/video/saa6588.c-	return 0;
drivers/media/video/saa6588.c-	saa6588_i2c_poll(s);
drivers/media/video/saa6588.c:	schedule_delayed_work(&s->work, 0);
drivers/media/video/saa6588.c:	schedule_delayed_work(&s->work, msecs_to_jiffies(20));
drivers/media/video/saa6588.c-	spinlock_t lock;
drivers/media/video/saa6588.c-	/* start polling via eventd */
drivers/media/video/saa6588.c:	struct delayed_work work;
drivers/media/video/saa6588.c-struct saa6588 {
drivers/media/video/saa6588.c-	struct v4l2_subdev sd;
drivers/media/video/saa6588.c-	unsigned char *buffer;
drivers/media/video/saa6588.c-	v4l2_device_unregister_subdev(sd);
drivers/media/video/tm6000/tm6000-input.c-
drivers/media/video/tm6000/tm6000-input.c-
drivers/media/video/tm6000/tm6000-input.c-
drivers/media/video/tm6000/tm6000-input.c-
drivers/media/video/tm6000/tm6000-input.c-
drivers/media/video/tm6000/tm6000-input.c-
drivers/media/video/tm6000/tm6000-input.c-
drivers/media/video/tm6000/tm6000-input.c-
drivers/media/video/tm6000/tm6000-input.c-
drivers/media/video/tm6000/tm6000-input.c-}
drivers/media/video/tm6000/tm6000-input.c-}
drivers/media/video/tm6000/tm6000-input.c-}
drivers/media/video/tm6000/tm6000-input.c-	}
drivers/media/video/tm6000/tm6000-input.c-	 */
drivers/media/video/tm6000/tm6000-input.c-		}
drivers/media/video/tm6000/tm6000-input.c:	cancel_delayed_work_sync(&ir->work);
drivers/media/video/tm6000/tm6000-input.c-	dprintk(2, "%s\n",__func__);
drivers/media/video/tm6000/tm6000-input.c-	dprintk(2, "%s\n",__func__);
drivers/media/video/tm6000/tm6000-input.c-	} else if (!ir->pwled) {
drivers/media/video/tm6000/tm6000-input.c-	int			polling;
drivers/media/video/tm6000/tm6000-input.c-		ir->pwled = 0;
drivers/media/video/tm6000/tm6000-input.c-	ir->pwled = 2;
drivers/media/video/tm6000/tm6000-input.c-		ir->submit_urb = 1;
drivers/media/video/tm6000/tm6000-input.c-	ir->submit_urb = 1;
drivers/media/video/tm6000/tm6000-input.c-	/* poll expernal decoder */
drivers/media/video/tm6000/tm6000-input.c-			       rc);
drivers/media/video/tm6000/tm6000-input.c-	/* Re-schedule polling */
drivers/media/video/tm6000/tm6000-input.c-			/* Retry in 100 ms */
drivers/media/video/tm6000/tm6000-input.c-		return;
drivers/media/video/tm6000/tm6000-input.c-			return;
drivers/media/video/tm6000/tm6000-input.c-	return 0;
drivers/media/video/tm6000/tm6000-input.c-	return 0;
drivers/media/video/tm6000/tm6000-input.c:	schedule_delayed_work(&ir->work, 0);
drivers/media/video/tm6000/tm6000-input.c:	schedule_delayed_work(&ir->work, msecs_to_jiffies(10));
drivers/media/video/tm6000/tm6000-input.c:	schedule_delayed_work(&ir->work, msecs_to_jiffies(ir->polling));
drivers/media/video/tm6000/tm6000-input.c:		schedule_delayed_work(&ir->work, msecs_to_jiffies(URB_INT_LED_DELAY));
drivers/media/video/tm6000/tm6000-input.c:			schedule_delayed_work(&ir->work, msecs_to_jiffies(URB_SUBMIT_DELAY));
drivers/media/video/tm6000/tm6000-input.c:		schedule_delayed_work(&ir->work, msecs_to_jiffies(URB_SUBMIT_DELAY));
drivers/media/video/tm6000/tm6000-input.c:	schedule_delayed_work(&ir->work, msecs_to_jiffies(URB_SUBMIT_DELAY));
drivers/media/video/tm6000/tm6000-input.c:	struct delayed_work	work;
drivers/media/video/tm6000/tm6000-input.c-		tm6000_flash_led(dev, 0);
drivers/media/video/tm6000/tm6000-input.c-		tm6000_flash_led(dev, 1);
drivers/media/video/tm6000/tm6000-input.c-	u8			pwled:2;
drivers/media/video/tm6000/tm6000-input.c-	u8			wait:1;
drivers/media/video/tm6000/tm6000-input.c-		       urb->status, urb->actual_length);
drivers/message/fusion/mptbase.c-
drivers/message/fusion/mptbase.c-
drivers/message/fusion/mptbase.c-
drivers/message/fusion/mptbase.c:	cancel_delayed_work(&ioc->fault_reset_work);
drivers/message/fusion/mptbase.c-	destroy_workqueue(wq);
drivers/message/fusion/mptbase.c-	if (!ioc->alt_ioc)
drivers/message/fusion/mptbase.c-	if (ioc->reset_work_q)
drivers/message/fusion/mptbase.c-	ioc->reset_work_q = NULL;
drivers/message/fusion/mptbase.c-			msecs_to_jiffies(MPT_POLLING_INTERVAL));
drivers/message/fusion/mptbase.c-			msecs_to_jiffies(MPT_POLLING_INTERVAL));
drivers/message/fusion/mptbase.c:		queue_delayed_work(ioc->reset_work_q, &ioc->fault_reset_work,
drivers/message/fusion/mptbase.c:		queue_delayed_work(ioc->reset_work_q, &ioc->fault_reset_work,
drivers/message/fusion/mptbase.c-	spin_lock_irqsave(&ioc->taskmgmt_lock, flags);
drivers/message/fusion/mptbase.c-	spin_unlock_irqrestore(&ioc->taskmgmt_lock, flags);
drivers/message/fusion/mptbase.c-	spin_unlock_irqrestore(&ioc->taskmgmt_lock, flags);
drivers/message/fusion/mptlan.c-
drivers/message/fusion/mptlan.c-			dioprintk((KERN_INFO MYNAM ": post_buckets queued on "
drivers/message/fusion/mptlan.c-		} else {
drivers/message/fusion/mptlan.c-		if (priority) {
drivers/message/fusion/mptlan.c-	if (test_and_set_bit(0, &priv->post_buckets_active) == 0) {
drivers/message/fusion/mptlan.c:			schedule_delayed_work(&priv->post_buckets_task, 0);
drivers/message/fusion/mptlan.c:			schedule_delayed_work(&priv->post_buckets_task, 1);
drivers/message/fusion/mptlan.c:	struct delayed_work post_buckets_task;
drivers/message/fusion/mptlan.c-	struct net_device *dev;
drivers/message/fusion/mptlan.c-				   "timer.\n"));
drivers/message/fusion/mptlan.c-	u32 total_received;
drivers/message/fusion/mptlan.c-	unsigned long post_buckets_active;
drivers/message/i2o/i2o_block.c-
drivers/message/i2o/i2o_block.c-						&dreq->work,
drivers/message/i2o/i2o_block.c-					  i2o_block_delayed_request_fn);
drivers/message/i2o/i2o_block.c-						I2O_BLOCK_RETRY_TIME))
drivers/message/i2o/i2o_block.c:			if (!queue_delayed_work(i2o_block_driver.event_queue,
drivers/mfd/tps65010.c-
drivers/mfd/tps65010.c-
drivers/mfd/tps65010.c-
drivers/mfd/tps65010.c-
drivers/mfd/tps65010.c-
drivers/mfd/tps65010.c-
drivers/mfd/tps65010.c-}
drivers/mfd/tps65010.c-	}
drivers/mfd/tps65010.c-	/* also potentially gpio-in rise or fall */
drivers/mfd/tps65010.c:	cancel_delayed_work_sync(&tps->work);
drivers/mfd/tps65010.c-	debugfs_remove(tps->file);
drivers/mfd/tps65010.c-	disable_irq_nosync(irq);
drivers/mfd/tps65010.c-				FLAG_VBUS_CHANGED, &the_tps->flags)) {
drivers/mfd/tps65010.c-		free_irq(client->irq, tps);
drivers/mfd/tps65010.c-		/* gadget drivers call this in_irq() */
drivers/mfd/tps65010.c-	if (client->irq > 0)
drivers/mfd/tps65010.c-	if (poll)
drivers/mfd/tps65010.c-	/* ignore ackint2 */
drivers/mfd/tps65010.c-	kfree(tps);
drivers/mfd/tps65010.c-	local_irq_restore(flags);
drivers/mfd/tps65010.c-	mutex_lock(&tps->lock);
drivers/mfd/tps65010.c-		poll = 1;
drivers/mfd/tps65010.c-	return IRQ_HANDLED;
drivers/mfd/tps65010.c:		schedule_delayed_work(&the_tps->work, 0);
drivers/mfd/tps65010.c:	schedule_delayed_work(&tps->work, 0);
drivers/mfd/tps65010.c:		schedule_delayed_work(&tps->work, POWER_POLL_DELAY);
drivers/mfd/tps65010.c:	schedule_delayed_work(&tps->work, POWER_POLL_DELAY);
drivers/mfd/tps65010.c-	set_bit(FLAG_IRQ_ENABLE, &tps->flags);
drivers/mfd/tps65010.c:	struct delayed_work	work;
drivers/mfd/tps65010.c-	struct dentry		*file;
drivers/mfd/tps65010.c-	struct i2c_client	*client;
drivers/mfd/tps65010.c-	struct mutex		lock;
drivers/mfd/tps65010.c-	struct tps65010		*tps;
drivers/mfd/tps65010.c:	tps = container_of(to_delayed_work(work), struct tps65010, work);
drivers/mfd/tps65010.c-	unsigned		charging:1;
drivers/misc/arm-charlcd.c-
drivers/misc/arm-charlcd.c-
drivers/misc/arm-charlcd.c-};
drivers/misc/arm-charlcd.c-	 */
drivers/misc/arm-charlcd.c-	dev_info(&pdev->dev, "initialized ARM character LCD at %08x\n",
drivers/misc/arm-charlcd.c-	INIT_DELAYED_WORK(&lcd->init_work, charlcd_init_work);
drivers/misc/arm-charlcd.c-	int irq;
drivers/misc/arm-charlcd.c:	schedule_delayed_work(&lcd->init_work, 0);
drivers/misc/arm-charlcd.c-	struct completion complete;
drivers/misc/arm-charlcd.c:	struct delayed_work init_work;
drivers/misc/bh1770glc.c-
drivers/misc/bh1770glc.c-
drivers/misc/bh1770glc.c-	}
drivers/misc/bh1770glc.c-		 */
drivers/misc/bh1770glc.c-	bool			int_mode_lux;
drivers/misc/bh1770glc.c-	bool			int_mode_prox;
drivers/misc/bh1770glc.c:	cancel_delayed_work_sync(&chip->prox_work);
drivers/misc/bh1770glc.c:		cancel_delayed_work_sync(&chip->prox_work);
drivers/misc/bh1770glc.c-		chip->pdata->release_resources();
drivers/misc/bh1770glc.c-	if (!pm_runtime_suspended(&client->dev))
drivers/misc/bh1770glc.c-				msecs_to_jiffies(rate + 50));
drivers/misc/bh1770glc.c-		 * next expected interrupt time.
drivers/misc/bh1770glc.c:		schedule_delayed_work(&chip->prox_work,
drivers/misc/bh1770glc.c:	struct delayed_work	prox_work;
drivers/misc/bh1770glc.c-	u32	lux_cf; /* Chip specific factor */
drivers/misc/bh1770glc.c-	u32	lux_ga;
drivers/misc/fsa9485.c-
drivers/misc/fsa9485.c-
drivers/misc/fsa9485.c-
drivers/misc/fsa9485.c:	cancel_delayed_work(&usbsw->audio_work);
drivers/misc/fsa9485.c:	cancel_delayed_work(&usbsw->init_work);
drivers/misc/fsa9485.c-		disable_irq_wake(client->irq);
drivers/misc/fsa9485.c-	if (client->irq) {
drivers/misc/fsa9485.c-	INIT_DELAYED_WORK(&usbsw->audio_work, fsa9485_delayed_audio);
drivers/misc/fsa9485.c-	INIT_DELAYED_WORK(&usbsw->init_work, fsa9485_init_detect);
drivers/misc/fsa9485.c-	/* initial cable detection */
drivers/misc/fsa9485.c-	int				adc;
drivers/misc/fsa9485.c-	int			dock_ready;
drivers/misc/fsa9485.c-	return 0;
drivers/misc/fsa9485.c:	schedule_delayed_work(&usbsw->audio_work, msecs_to_jiffies(20000));
drivers/misc/fsa9485.c:	schedule_delayed_work(&usbsw->init_work, msecs_to_jiffies(2700));
drivers/misc/fsa9485.c:	struct delayed_work	audio_work;
drivers/misc/fsa9485.c:	struct delayed_work	init_work;
drivers/misc/fsa9485.c-	struct fsa9485_usbsw *usbsw = i2c_get_clientdata(client);
drivers/misc/fsa9485.c-	struct mutex		mutex;
drivers/misc/fsa9485_lt02.c-{
drivers/misc/fsa9485_lt02.c-
drivers/misc/fsa9485_lt02.c-
drivers/misc/fsa9485_lt02.c:	cancel_delayed_work(&usbsw->init_work);
drivers/misc/fsa9485_lt02.c-		disable_irq_wake(client->irq);
drivers/misc/fsa9485_lt02.c-	if (client->irq) {
drivers/misc/fsa9485_lt02.c-	INIT_DELAYED_WORK(&usbsw->init_work, fsa9485_init_detect);
drivers/misc/fsa9485_lt02.c-	/* initial cable detection */
drivers/misc/fsa9485_lt02.c-	int				adc;
drivers/misc/fsa9485_lt02.c-	int			previous_key;
drivers/misc/fsa9485_lt02.c-	return 0;
drivers/misc/fsa9485_lt02.c:	schedule_delayed_work(&usbsw->init_work, msecs_to_jiffies(2700));
drivers/misc/fsa9485_lt02.c:	struct delayed_work	init_work;
drivers/misc/fsa9485_lt02.c-	struct fsa9485_usbsw *usbsw = i2c_get_clientdata(client);
drivers/misc/fsa9485_lt02.c-	struct mutex		mutex;
drivers/misc/inv_mpu/mpuirq.c-
drivers/misc/inv_mpu/mpuirq.c-	if (mldl_cfg->inv_mpu_state->accel_reactive)
drivers/misc/inv_mpu/mpuirq.c-	int data_ready;
drivers/misc/inv_mpu/mpuirq.c-	int timeout;
drivers/misc/inv_mpu/mpuirq.c-		msecs_to_jiffies(20));
drivers/misc/inv_mpu/mpuirq.c:		schedule_delayed_work(&mpuirq_dev_data.reactive_work,
drivers/misc/inv_mpu/mpuirq.c:	struct delayed_work reactive_work;
drivers/misc/inv_mpu/mpuirq.c-	struct mldl_cfg *mldl_dev_cfg;
drivers/misc/inv_mpu/mpuirq.c-	struct wake_lock reactive_wake_lock;
drivers/misc/inv_mpu/mpuirq.c-		wake_up_interruptible(&mpuirq_wait);
drivers/misc/max77693-muic.c-
drivers/misc/max77693-muic.c-
drivers/misc/max77693-muic.c-
drivers/misc/max77693-muic.c-
drivers/misc/max77693-muic.c-
drivers/misc/max77693-muic.c-
drivers/misc/max77693-muic.c:		cancel_delayed_work(&info->dock_usb_work);
drivers/misc/max77693-muic.c:		cancel_delayed_work(&info->dock_work);
drivers/misc/max77693-muic.c:		cancel_delayed_work(&info->init_work);
drivers/misc/max77693-muic.c:		cancel_delayed_work(&info->mhl_work);
drivers/misc/max77693-muic.c:		cancel_delayed_work(&info->usb_work);
drivers/misc/max77693-muic.c-	enum cable_type_muic	cable_type;
drivers/misc/max77693-muic.c-		free_irq(info->irq_adc, info);
drivers/misc/max77693-muic.c-		free_irq(info->irq_chgtype, info);
drivers/misc/max77693-muic.c-#if !defined(CONFIG_MUIC_MAX77693_SUPPORT_CAR_DOCK)
drivers/misc/max77693-muic.c-	if (info) {
drivers/misc/max77693-muic.c-	INIT_DELAYED_WORK(&info->dock_usb_work, max77693_muic_dock_usb_detect);
drivers/misc/max77693-muic.c-	INIT_DELAYED_WORK(&info->dock_work, max77693_muic_dock_detect);
drivers/misc/max77693-muic.c-	INIT_DELAYED_WORK(&info->init_work, max77693_muic_init_detect);
drivers/misc/max77693-muic.c-	INIT_DELAYED_WORK(&info->mhl_work, max77693_muic_mhl_detect);
drivers/misc/max77693-muic.c-	INIT_DELAYED_WORK(&info->usb_work, max77693_muic_usb_detect);
drivers/misc/max77693-muic.c-	/* initial cable detection */
drivers/misc/max77693-muic.c-		input_unregister_device(info->input);
drivers/misc/max77693-muic.c-	return 0;
drivers/misc/max77693-muic.c:	schedule_delayed_work(&info->dock_usb_work, msecs_to_jiffies(22000));
drivers/misc/max77693-muic.c:	schedule_delayed_work(&info->dock_work, msecs_to_jiffies(50));
drivers/misc/max77693-muic.c:	schedule_delayed_work(&info->init_work, msecs_to_jiffies(3000));
drivers/misc/max77693-muic.c:	schedule_delayed_work(&info->mhl_work, msecs_to_jiffies(25000));
drivers/misc/max77693-muic.c:	schedule_delayed_work(&info->usb_work, msecs_to_jiffies(10000));
drivers/misc/max77693-muic.c:	struct delayed_work	dock_usb_work;
drivers/misc/max77693-muic.c:	struct delayed_work	dock_work;
drivers/misc/max77693-muic.c:	struct delayed_work	init_work;
drivers/misc/max77693-muic.c:	struct delayed_work	mhl_work;
drivers/misc/max77693-muic.c:	struct delayed_work	usb_work;
drivers/misc/max77693-muic.c-	struct mutex		mutex;
drivers/misc/max77693-muic_melius.c-
drivers/misc/max77693-muic_melius.c-
drivers/misc/max77693-muic_melius.c-
drivers/misc/max77693-muic_melius.c-
drivers/misc/max77693-muic_melius.c-
drivers/misc/max77693-muic_melius.c-
drivers/misc/max77693-muic_melius.c-
drivers/misc/max77693-muic_melius.c-
drivers/misc/max77693-muic_melius.c:		cancel_delayed_work(&info->dock_usb_work);
drivers/misc/max77693-muic_melius.c:		cancel_delayed_work(&info->dock_work);
drivers/misc/max77693-muic_melius.c:		cancel_delayed_work(&info->init_work);
drivers/misc/max77693-muic_melius.c:		cancel_delayed_work(&info->mhl_work);
drivers/misc/max77693-muic_melius.c:		cancel_delayed_work(&info->usb_work);
drivers/misc/max77693-muic_melius.c-		defined(CONFIG_MACH_MELIUS_LGT)
drivers/misc/max77693-muic_melius.c-		dev_info(info->dev, "func:%s\n", __func__);
drivers/misc/max77693-muic_melius.c-#else
drivers/misc/max77693-muic_melius.c-#endif
drivers/misc/max77693-muic_melius.c-	enum cable_type_muic	cable_type;
drivers/misc/max77693-muic_melius.c-		free_irq(info->irq_adc, info);
drivers/misc/max77693-muic_melius.c-		free_irq(info->irq_chgtype, info);
drivers/misc/max77693-muic_melius.c-#if defined(CONFIG_MACH_MELIUS_SKT) || defined(CONFIG_MACH_MELIUS_KTT) || \
drivers/misc/max77693-muic_melius.c-	INIT_DELAYED_WORK(&info->dock_usb_work, max77693_muic_dock_usb_detect);
drivers/misc/max77693-muic_melius.c-	INIT_DELAYED_WORK(&info->dock_work, max77693_muic_dock_detect);
drivers/misc/max77693-muic_melius.c-	INIT_DELAYED_WORK(&info->init_work, max77693_muic_init_detect);
drivers/misc/max77693-muic_melius.c-	INIT_DELAYED_WORK(&info->mhl_work, max77693_muic_mhl_detect);
drivers/misc/max77693-muic_melius.c-	INIT_DELAYED_WORK(&info->usb_work, max77693_muic_usb_detect);
drivers/misc/max77693-muic_melius.c-	/* initial cable detection */
drivers/misc/max77693-muic_melius.c-		input_unregister_device(info->input);
drivers/misc/max77693-muic_melius.c:	schedule_delayed_work(&info->dock_usb_work, msecs_to_jiffies(22000));
drivers/misc/max77693-muic_melius.c:	schedule_delayed_work(&info->dock_usb_work, msecs_to_jiffies(27000));
drivers/misc/max77693-muic_melius.c:	schedule_delayed_work(&info->dock_work, msecs_to_jiffies(50));
drivers/misc/max77693-muic_melius.c:	schedule_delayed_work(&info->init_work, msecs_to_jiffies(3000));
drivers/misc/max77693-muic_melius.c:	schedule_delayed_work(&info->mhl_work, msecs_to_jiffies(25000));
drivers/misc/max77693-muic_melius.c:	schedule_delayed_work(&info->usb_work, msecs_to_jiffies(10000));
drivers/misc/max77693-muic_melius.c:	struct delayed_work	dock_usb_work;
drivers/misc/max77693-muic_melius.c:	struct delayed_work	dock_work;
drivers/misc/max77693-muic_melius.c:	struct delayed_work	init_work;
drivers/misc/max77693-muic_melius.c:	struct delayed_work	mhl_work;
drivers/misc/max77693-muic_melius.c:	struct delayed_work	usb_work;
drivers/misc/max77693-muic_melius.c-	struct mutex		mutex;
drivers/misc/max77693-muic_serrano.c-
drivers/misc/max77693-muic_serrano.c-
drivers/misc/max77693-muic_serrano.c-
drivers/misc/max77693-muic_serrano.c-
drivers/misc/max77693-muic_serrano.c-
drivers/misc/max77693-muic_serrano.c-
drivers/misc/max77693-muic_serrano.c-
drivers/misc/max77693-muic_serrano.c-
drivers/misc/max77693-muic_serrano.c:		cancel_delayed_work(&info->dock_usb_work);
drivers/misc/max77693-muic_serrano.c:		cancel_delayed_work(&info->dock_work);
drivers/misc/max77693-muic_serrano.c:		cancel_delayed_work(&info->init_work);
drivers/misc/max77693-muic_serrano.c:		cancel_delayed_work(&info->mhl_work);
drivers/misc/max77693-muic_serrano.c:		cancel_delayed_work(&info->usb_work);
drivers/misc/max77693-muic_serrano.c-		dev_info(info->dev, "func:%s\n", __func__);
drivers/misc/max77693-muic_serrano.c-	enum cable_type_muic	cable_type;
drivers/misc/max77693-muic_serrano.c-		free_irq(info->irq_adc, info);
drivers/misc/max77693-muic_serrano.c-		free_irq(info->irq_chgtype, info);
drivers/misc/max77693-muic_serrano.c-	INIT_DELAYED_WORK(&info->dock_usb_work, max77693_muic_dock_usb_detect);
drivers/misc/max77693-muic_serrano.c-	INIT_DELAYED_WORK(&info->dock_work, max77693_muic_dock_detect);
drivers/misc/max77693-muic_serrano.c-	INIT_DELAYED_WORK(&info->init_work, max77693_muic_init_detect);
drivers/misc/max77693-muic_serrano.c-	INIT_DELAYED_WORK(&info->mhl_work, max77693_muic_mhl_detect);
drivers/misc/max77693-muic_serrano.c-	INIT_DELAYED_WORK(&info->usb_work, max77693_muic_usb_detect);
drivers/misc/max77693-muic_serrano.c-	/* initial cable detection */
drivers/misc/max77693-muic_serrano.c-		input_unregister_device(info->input);
drivers/misc/max77693-muic_serrano.c:	schedule_delayed_work(&info->dock_usb_work, msecs_to_jiffies(22000));
drivers/misc/max77693-muic_serrano.c:	schedule_delayed_work(&info->dock_work, msecs_to_jiffies(50));
drivers/misc/max77693-muic_serrano.c:	schedule_delayed_work(&info->init_work, msecs_to_jiffies(3000));
drivers/misc/max77693-muic_serrano.c:	schedule_delayed_work(&info->mhl_work, msecs_to_jiffies(25000));
drivers/misc/max77693-muic_serrano.c:	schedule_delayed_work(&info->usb_work, msecs_to_jiffies(10000));
drivers/misc/max77693-muic_serrano.c:	struct delayed_work	dock_usb_work;
drivers/misc/max77693-muic_serrano.c:	struct delayed_work	dock_work;
drivers/misc/max77693-muic_serrano.c:	struct delayed_work	init_work;
drivers/misc/max77693-muic_serrano.c:	struct delayed_work	mhl_work;
drivers/misc/max77693-muic_serrano.c:	struct delayed_work	usb_work;
drivers/misc/max77693-muic_serrano.c-	struct mutex		mutex;
drivers/misc/slimport_anx7808/slimport.c-
drivers/misc/slimport_anx7808/slimport.c:		cancel_delayed_work_sync(&anx7808->work);
drivers/misc/slimport_anx7808/slimport.c-	} else {
drivers/misc/slimport_anx7808/slimport.c-#endif
drivers/misc/slimport_anx7808/slimport.c-			msecs_to_jiffies(300));
drivers/misc/slimport_anx7808/slimport.c-		pr_info("%s : detect cable insertion\n", __func__);
drivers/misc/slimport_anx7808/slimport.c-		pr_info("%s : detect cable removal\n", __func__);
drivers/misc/slimport_anx7808/slimport.c:		queue_delayed_work(anx7808->workqueue, &anx7808->work, 0);
drivers/misc/slimport_anx7808/slimport.c:	queue_delayed_work(td->workqueue, &td->work,
drivers/misc/slimport_anx7808/slimport.c-	slimport_main_proc(td);
drivers/misc/slimport_anx7808/slimport.c-struct anx7808_data {
drivers/misc/slimport_anx7808/slimport.c-	struct anx7808_platform_data    *pdata;
drivers/misc/slimport_anx7808/slimport.c:	struct delayed_work    work;
drivers/misc/slimport_anx7808/slimport.c-	struct mutex    lock;
drivers/misc/slimport_anx7808/slimport.c-	struct workqueue_struct    *workqueue;
drivers/misc/slimport_anx7808/slimport.c-		wake_lock(&anx7808->slimport_lock);
drivers/misc/slimport_anx7808/slimport.c-		wake_lock_timeout(&anx7808->slimport_lock, 2*HZ);
drivers/misc/slimport_anx7808/slimport.c-		wake_unlock(&anx7808->slimport_lock);
drivers/misc/tsu6721.c-
drivers/misc/tsu6721.c-
drivers/misc/tsu6721.c-{
drivers/misc/tsu6721.c:	cancel_delayed_work(&usbsw->init_work);
drivers/misc/tsu6721.c-		disable_irq_wake(client->irq);
drivers/misc/tsu6721.c-	if (client->irq) {
drivers/misc/tsu6721.c-	INIT_DELAYED_WORK(&usbsw->init_work, tsu6721_init_detect);
drivers/misc/tsu6721.c-	/* initial cable detection */
drivers/misc/tsu6721.c-	int				adc;
drivers/misc/tsu6721.c-	int				dev_id;
drivers/misc/tsu6721.c-	return 0;
drivers/misc/tsu6721.c:	schedule_delayed_work(&usbsw->init_work, msecs_to_jiffies(2700));
drivers/misc/tsu6721.c:	struct delayed_work	init_work;
drivers/misc/tsu6721.c-	struct mutex		mutex;
drivers/misc/tsu6721.c-	struct tsu6721_usbsw *usbsw = i2c_get_clientdata(client);
drivers/misc/vmw_balloon.c-
drivers/misc/vmw_balloon.c-
drivers/misc/vmw_balloon.c-
drivers/misc/vmw_balloon.c-
drivers/misc/vmw_balloon.c-
drivers/misc/vmw_balloon.c-{
drivers/misc/vmw_balloon.c-{
drivers/misc/vmw_balloon.c-}
drivers/misc/vmw_balloon.c-};
drivers/misc/vmw_balloon.c-	 */
drivers/misc/vmw_balloon.c:	cancel_delayed_work_sync(&balloon.dwork);
drivers/misc/vmw_balloon.c-			   dwork, round_jiffies_relative(HZ));
drivers/misc/vmw_balloon.c:	queue_delayed_work(system_freezable_wq,
drivers/misc/vmw_balloon.c:	queue_delayed_work(system_freezable_wq, &balloon.dwork, 0);
drivers/misc/vmw_balloon.c-	return 0;
drivers/misc/vmw_balloon.c-		return error;
drivers/misc/vmw_balloon.c-static void __exit vmballoon_exit(void)
drivers/misc/vmw_balloon.c-static void vmballoon_work(struct work_struct *work)
drivers/misc/vmw_balloon.c-	 * stopped while the system transitions to/from sleep/hibernation.
drivers/misc/vmw_balloon.c:	struct delayed_work dwork;
drivers/misc/vmw_balloon.c:	struct delayed_work *dwork = to_delayed_work(work);
drivers/misc/vmw_balloon.c-	struct sysinfo sysinfo;
drivers/misc/vmw_balloon.c-	struct vmballoon *b = container_of(dwork, struct vmballoon, dwork);
drivers/misc/vmw_balloon.c-	unsigned int target;
drivers/misc/vmw_balloon.c-	vmballoon_debugfs_exit(&balloon);
drivers/mmc/core/core.c-
drivers/mmc/core/core.c-
drivers/mmc/core/core.c-
drivers/mmc/core/core.c-
drivers/mmc/core/core.c-
drivers/mmc/core/core.c-
drivers/mmc/core/core.c-
drivers/mmc/core/core.c-
drivers/mmc/core/core.c-
drivers/mmc/core/core.c-
drivers/mmc/core/core.c-
drivers/mmc/core/core.c-
drivers/mmc/core/core.c-
drivers/mmc/core/core.c-
drivers/mmc/core/core.c-
drivers/mmc/core/core.c-{
drivers/mmc/core/core.c-{
drivers/mmc/core/core.c-{
drivers/mmc/core/core.c-}
drivers/mmc/core/core.c-}
drivers/mmc/core/core.c-}
drivers/mmc/core/core.c-}
drivers/mmc/core/core.c-}
drivers/mmc/core/core.c- */
drivers/mmc/core/core.c-	/*
drivers/mmc/core/core.c-	}
drivers/mmc/core/core.c-	}
drivers/mmc/core/core.c-	}
drivers/mmc/core/core.c-	 */
drivers/mmc/core/core.c-	 */
drivers/mmc/core/core.c-	 */
drivers/mmc/core/core.c-	 */
drivers/mmc/core/core.c-		/*
drivers/mmc/core/core.c-		}
drivers/mmc/core/core.c-		}
drivers/mmc/core/core.c-		 */
drivers/mmc/core/core.c-			 */
drivers/mmc/core/core.c-			 */
drivers/mmc/core/core.c-	 * BKOPS work in case the delayed work is executed on another CPU
drivers/mmc/core/core.c:	cancel_delayed_work(&host->detect);
drivers/mmc/core/core.c:			cancel_delayed_work(&host->detect);
drivers/mmc/core/core.c:				cancel_delayed_work_sync(
drivers/mmc/core/core.c:		cancel_delayed_work_sync(&card->bkops_info.dw);
drivers/mmc/core/core.c:	cancel_delayed_work_sync(&host->clk_scaling.work);
drivers/mmc/core/core.c:	cancel_delayed_work_sync(&host->clk_scaling.work);
drivers/mmc/core/core.c:	cancel_delayed_work_sync(&host->detect);
drivers/mmc/core/core.c:		cancel_delayed_work_sync(&host->detect);
drivers/mmc/core/core.c-		 * Cancel such the scheduled works.
drivers/mmc/core/core.c:		card->bkops_info.cancel_delayed_work = false;
drivers/mmc/core/core.c:		card->bkops_info.cancel_delayed_work = false;
drivers/mmc/core/core.c:	card->bkops_info.cancel_delayed_work = false;
drivers/mmc/core/core.c:	card->bkops_info.cancel_delayed_work = true;
drivers/mmc/core/core.c-				   card->bkops_info.delay_ms));
drivers/mmc/core/core.c:	    card->bkops_info.min_sectors_to_queue_delayed_work)
drivers/mmc/core/core.c-#endif
drivers/mmc/core/core.c-			err = mmc_clk_update_freq(host, freq, state);
drivers/mmc/core/core.c-	 * for the lock we will to re-check it
drivers/mmc/core/core.c-			goto no_reset_stats;
drivers/mmc/core/core.c-		goto out;
drivers/mmc/core/core.c-		goto out;
drivers/mmc/core/core.c-		goto out;
drivers/mmc/core/core.c-			 * host and re-claim while scaling down the clocks.
drivers/mmc/core/core.c-	host->clk_scaling.enable = false;
drivers/mmc/core/core.c-						&host->clk_scaling.work);
drivers/mmc/core/core.c-	host->detect_change = 1;
drivers/mmc/core/core.c:	if (card->bkops_info.cancel_delayed_work)
drivers/mmc/core/core.c:	if ((card->bkops_info.cancel_delayed_work) && !from_exception) {
drivers/mmc/core/core.c:	if ((card->bkops_info.cancel_delayed_work) && !from_exception) {
drivers/mmc/core/core.c-	if (card->bkops_info.sectors_changed <
drivers/mmc/core/core.c:	if (delayed_work_pending(&card->bkops_info.dw))
drivers/mmc/core/core.c-			if (!from_wq)
drivers/mmc/core/core.c-	if (host->caps & MMC_CAP_NEEDS_POLL)
drivers/mmc/core/core.c-	if (!mmc_card_doing_bkops(card))
drivers/mmc/core/core.c-	if (!mmc_try_claim_host(host)) {
drivers/mmc/core/core.c-		if (!queue_scale_down_work) {
drivers/mmc/core/core.c-	/* If there is pending detect work abort runtime suspend */
drivers/mmc/core/core.c- * Internal function. Schedule delayed work in the MMC work queue.
drivers/mmc/core/core.c-	 * it was removed from the queue work but not started yet
drivers/mmc/core/core.c-	memset(&host->clk_scaling, 0, sizeof(host->clk_scaling));
drivers/mmc/core/core.c-			mmc_detect_change(host, 0);
drivers/mmc/core/core.c-	mmc_flush_scheduled_work();
drivers/mmc/core/core.c-			 mmc_hostname(card->host), __func__);
drivers/mmc/core/core.c-			 mmc_hostname(card->host), __func__);
drivers/mmc/core/core.c:	mmc_schedule_delayed_work(&card->bkops_info.dw,
drivers/mmc/core/core.c:			mmc_schedule_delayed_work(&host->clk_scaling.work, 1);
drivers/mmc/core/core.c:		mmc_schedule_delayed_work(&host->clk_scaling.work, 1);
drivers/mmc/core/core.c:	mmc_schedule_delayed_work(&host->detect, delay);
drivers/mmc/core/core.c:		mmc_schedule_delayed_work(&host->detect, msecs_to_jiffies(100));
drivers/mmc/core/core.c-			   msecs_to_jiffies(
drivers/mmc/core/core.c:		pr_debug("%s: %s: cancel_delayed_work was set, exit\n",
drivers/mmc/core/core.c:		pr_debug("%s: %s: cancel_delayed_work was set, exit\n",
drivers/mmc/core/core.c-	 * removed from the queue, but was not started yet
drivers/mmc/core/core.c-			 * rescan handle the card removal.
drivers/mmc/core/core.c-		/* retry after a timer tick */
drivers/mmc/core/core.c-		return;
drivers/mmc/core/core.c-		return;
drivers/mmc/core/core.c-		return;
drivers/mmc/core/core.c-		return;
drivers/mmc/core/core.c-		return 0;
drivers/mmc/core/core.c:	return queue_delayed_work(mx_mmc, work, delay);
drivers/mmc/core/core.c:	 * Since the cancel_delayed_work can be changed while we are waiting
drivers/mmc/core/core.c:static int mmc_schedule_delayed_work(struct delayed_work *work,
drivers/mmc/core/core.c-				     unsigned long delay)
drivers/mmc/core/core.c-void mmc_disable_clk_scaling(struct mmc_host *host)
drivers/mmc/core/core.c-void mmc_exit_clk_scaling(struct mmc_host *host)
drivers/mmc/core/host.c-
drivers/mmc/core/host.c-	 */
drivers/mmc/core/host.c-	/* cancel any clock gating work scheduled by mmc_host_clk_release() */
drivers/mmc/core/host.c:	cancel_delayed_work_sync(&host->clk_gate_work);
drivers/mmc/core/host.c-	    !host->clk_requests)
drivers/mmc/core/host.c:	if (cancel_delayed_work_sync(&host->clk_gate_work))
drivers/mmc/core/host.c-	if (host->clk_gated)
drivers/mmc/core/host.c-	if (mmc_host_may_gate_card(host->card) &&
drivers/mmc/core/host.c-		mmc_host_clk_gate_delayed(host);
drivers/mmc/core/host.c-				      msecs_to_jiffies(100));
drivers/mmc/core/host.c-	mutex_lock(&host->clk_gate_mutex);
drivers/mmc/core/host.c:		queue_delayed_work(mx_clk_gate_wq, &host->clk_gate_work,
drivers/mmc/core/host.c-	spin_lock_irqsave(&host->clk_lock, flags);
drivers/mmc/core/host.c-	spin_unlock_irqrestore(&host->clk_lock, flags);
drivers/mmc/core/host.c-	 * ungated before exiting.
drivers/mmc/host/sh_mmcif.c-
drivers/mmc/host/sh_mmcif.c-
drivers/mmc/host/sh_mmcif.c-
drivers/mmc/host/sh_mmcif.c-
drivers/mmc/host/sh_mmcif.c-
drivers/mmc/host/sh_mmcif.c-
drivers/mmc/host/sh_mmcif.c-
drivers/mmc/host/sh_mmcif.c-
drivers/mmc/host/sh_mmcif.c-
drivers/mmc/host/sh_mmcif.c-
drivers/mmc/host/sh_mmcif.c-
drivers/mmc/host/sh_mmcif.c-
drivers/mmc/host/sh_mmcif.c-
drivers/mmc/host/sh_mmcif.c-
drivers/mmc/host/sh_mmcif.c-
drivers/mmc/host/sh_mmcif.c-
drivers/mmc/host/sh_mmcif.c-
drivers/mmc/host/sh_mmcif.c-{
drivers/mmc/host/sh_mmcif.c-}
drivers/mmc/host/sh_mmcif.c-}
drivers/mmc/host/sh_mmcif.c-}
drivers/mmc/host/sh_mmcif.c-}
drivers/mmc/host/sh_mmcif.c-	/*
drivers/mmc/host/sh_mmcif.c-	/*
drivers/mmc/host/sh_mmcif.c-	/*
drivers/mmc/host/sh_mmcif.c-	 */
drivers/mmc/host/sh_mmcif.c-	 */
drivers/mmc/host/sh_mmcif.c-	 * (a query on the linux-mmc mailing list didn't bring any replies).
drivers/mmc/host/sh_mmcif.c-	/* buf read enable */
drivers/mmc/host/sh_mmcif.c-	/* buf write enable */
drivers/mmc/host/sh_mmcif.c:	cancel_delayed_work_sync(&host->timeout_work);
drivers/mmc/host/sh_mmcif.c:	cancel_delayed_work_sync(&host->timeout_work);
drivers/mmc/host/sh_mmcif.c:	 * cancel_delayed_work_sync() is used
drivers/mmc/host/sh_mmcif.c-	enum mmcif_state state;
drivers/mmc/host/sh_mmcif.c-	enum mmcif_wait_for wait_for;
drivers/mmc/host/sh_mmcif.c:	 * FIXME: cancel_delayed_work(_sync)() and free_irq() race with the
drivers/mmc/host/sh_mmcif.c:	 * Handle races with cancel_delayed_work(), unless
drivers/mmc/host/sh_mmcif.c-	host->pio_ptr = sg_virt(data->sg);
drivers/mmc/host/sh_mmcif.c-	host->pio_ptr = sg_virt(data->sg);
drivers/mmc/host/sh_mmcif.c-	host->sg_blkidx = 0;
drivers/mmc/host/sh_mmcif.c-	host->sg_blkidx = 0;
drivers/mmc/host/sh_mmcif.c-	host->wait_for = MMCIF_WAIT_FOR_CMD;
drivers/mmc/host/sh_mmcif.c-	host->wait_for = MMCIF_WAIT_FOR_READ;
drivers/mmc/host/sh_mmcif.c-	host->wait_for = MMCIF_WAIT_FOR_STOP;
drivers/mmc/host/sh_mmcif.c-	host->wait_for = MMCIF_WAIT_FOR_WRITE;
drivers/mmc/host/sh_mmcif.c-	if (host->addr)
drivers/mmc/host/sh_mmcif.c-	int sg_idx;
drivers/mmc/host/sh_mmcif.c-	 * mmc_remove_host() call above. But swapping order doesn't help either
drivers/mmc/host/sh_mmcif.c-		return false;
drivers/mmc/host/sh_mmcif.c-		return false;
drivers/mmc/host/sh_mmcif.c:	schedule_delayed_work(&host->timeout_work, host->timeout);
drivers/mmc/host/sh_mmcif.c:	schedule_delayed_work(&host->timeout_work, host->timeout);
drivers/mmc/host/sh_mmcif.c:	schedule_delayed_work(&host->timeout_work, host->timeout);
drivers/mmc/host/sh_mmcif.c:	schedule_delayed_work(&host->timeout_work, host->timeout);
drivers/mmc/host/sh_mmcif.c:	schedule_delayed_work(&host->timeout_work, host->timeout);
drivers/mmc/host/sh_mmcif.c:	schedule_delayed_work(&host->timeout_work, host->timeout);
drivers/mmc/host/sh_mmcif.c:	schedule_delayed_work(&host->timeout_work, host->timeout);
drivers/mmc/host/sh_mmcif.c:	schedule_delayed_work(&host->timeout_work, host->timeout);
drivers/mmc/host/sh_mmcif.c-	sh_mmcif_bitset(host, MMCIF_CE_INT_MASK, MASK_MBUFREN);
drivers/mmc/host/sh_mmcif.c-	sh_mmcif_bitset(host, MMCIF_CE_INT_MASK, MASK_MBUFREN);
drivers/mmc/host/sh_mmcif.c-	sh_mmcif_bitset(host, MMCIF_CE_INT_MASK, MASK_MBUFWEN);
drivers/mmc/host/sh_mmcif.c-	sh_mmcif_bitset(host, MMCIF_CE_INT_MASK, MASK_MBUFWEN);
drivers/mmc/host/sh_mmcif.c-	size_t blocksize;
drivers/mmc/host/sh_mmcif.c-static void mmcif_timeout_work(struct work_struct *work)
drivers/mmc/host/sh_mmcif.c:	struct delayed_work *d = container_of(work, struct delayed_work, work);
drivers/mmc/host/sh_mmcif.c:	struct delayed_work timeout_work;
drivers/mmc/host/sh_mmcif.c-	struct mmc_request *mrq = host->mrq;
drivers/mmc/host/sh_mmcif.c-	struct mmc_request *mrq = host->mrq;
drivers/mmc/host/sh_mmcif.c-	struct sh_mmcif_host *host = container_of(d, struct sh_mmcif_host, timeout_work);
drivers/mmc/host/sh_mmcif.c-	switch (host->wait_for) {
drivers/mmc/host/tmio_mmc_pio.c-
drivers/mmc/host/tmio_mmc_pio.c-
drivers/mmc/host/tmio_mmc_pio.c-
drivers/mmc/host/tmio_mmc_pio.c-	/*
drivers/mmc/host/tmio_mmc_pio.c-	 */
drivers/mmc/host/tmio_mmc_pio.c:	cancel_delayed_work(&host->delayed_reset_work);
drivers/mmc/host/tmio_mmc_pio.c:	 * cancel_delayed_work(), it can happen, that a .set_ios() call preempts
drivers/mmc/host/tmio_mmc_pio.c:	cancel_delayed_work_sync(&host->delayed_reset_work);
drivers/mmc/host/tmio_mmc_pio.c-	cancel_work_sync(&host->done);
drivers/mmc/host/tmio_mmc_pio.c-	host->force_pio = false;
drivers/mmc/host/tmio_mmc_pio.c-	host->mrq = NULL;
drivers/mmc/host/tmio_mmc_pio.c-	if (!ret) {
drivers/mmc/host/tmio_mmc_pio.c-	 * is request already finished? Since we use a non-blocking
drivers/mmc/host/tmio_mmc_pio.c-	mmc_remove_host(mmc);
drivers/mmc/host/tmio_mmc_pio.c-				      msecs_to_jiffies(2000));
drivers/mmc/host/tmio_mmc_pio.c-	ret = tmio_mmc_start_command(host, mrq->cmd);
drivers/mmc/host/tmio_mmc_pio.c-		return;
drivers/mmc/host/tmio_mmc_pio.c:		schedule_delayed_work(&host->delayed_reset_work,
drivers/mmc/host/tmio_mmc_pio.c-	tmio_mmc_release_dma(host);
drivers/mmc/host/tmio_mmc_pio.c-	 * us, so, have to check for IS_ERR(host->mrq)
drivers/mmc/host/vub300.c-{
drivers/mmc/host/vub300.c-		/*
drivers/mmc/host/vub300.c:	if (queue_delayed_work(pollworkqueue, &vub300->pollwork, delay)) {
drivers/mmc/host/vub300.c-	kref_get(&vub300->kref);
drivers/mmc/host/vub300.c:	struct delayed_work pollwork;
drivers/mmc/host/vub300.c-	struct host_controller_info hc_info;
drivers/mmc/host/vub300.c-	struct sd_status_header system_port_status;
drivers/mmc/host/vub300.c-	struct work_struct cmndwork;
drivers/mmc/host/vub300.c-	struct work_struct deadwork;
drivers/mmc/host/vub300.c-		 * then the pollworkqueue was not previously
drivers/mtd/nand/r852.c-
drivers/mtd/nand/r852.c-
drivers/mtd/nand/r852.c-
drivers/mtd/nand/r852.c-
drivers/mtd/nand/r852.c-
drivers/mtd/nand/r852.c-
drivers/mtd/nand/r852.c-
drivers/mtd/nand/r852.c:	cancel_delayed_work_sync(&dev->card_detect_work);
drivers/mtd/nand/r852.c:	cancel_delayed_work_sync(&dev->card_detect_work);
drivers/mtd/nand/r852.c:	cancel_delayed_work_sync(&dev->card_detect_work);
drivers/mtd/nand/r852.c-	destroy_workqueue(dev->card_workqueue);
drivers/mtd/nand/r852.c-			dev->card_detected ? "added" : "removed");
drivers/mtd/nand/r852.c-		&dev->card_detect_work, 0);
drivers/mtd/nand/r852.c-			&dev->card_detect_work, msecs_to_jiffies(100));
drivers/mtd/nand/r852.c-		&dev->card_detect_work, msecs_to_jiffies(1000));
drivers/mtd/nand/r852.c-		dev->card_unstable = 1;
drivers/mtd/nand/r852.c-	/* First make sure the detect work is gone */
drivers/mtd/nand/r852.c-		goto out;
drivers/mtd/nand/r852.c-	/* kick initial present test */
drivers/mtd/nand/r852.c-		/* let, card state to settle a bit, and then do the work */
drivers/mtd/nand/r852.c:	queue_delayed_work(dev->card_workqueue,
drivers/mtd/nand/r852.c:		queue_delayed_work(dev->card_workqueue,
drivers/mtd/nand/r852.c:		queue_delayed_work(dev->card_workqueue,
drivers/mtd/nand/r852.c-	r852_disable_irqs(dev);
drivers/mtd/nand/r852.c-		return 0;
drivers/mtd/nand/r852.c-	/* Stop detect workqueue -
drivers/mtd/nand/r852.c-	struct r852_device *dev = pci_get_drvdata(pci_dev);
drivers/mtd/nand/r852.c-	synchronize_irq(dev->irq);
drivers/mtd/nand/r852.c-	/* Turn off the interrupts and stop the device */
drivers/mtd/nand/r852.c-		we are going to unregister the device anyway*/
drivers/net/bonding/bond_3ad.c-
drivers/net/bonding/bond_3ad.c-
drivers/net/bonding/bond_3ad.c:	queue_delayed_work(bond->wq, &bond->ad_work, ad_delta_in_ticks);
drivers/net/bonding/bond_3ad.c-	read_unlock(&bond->lock);
drivers/net/bonding/bond_3ad.c-re_arm:
drivers/net/bonding/bond_alb.c-
drivers/net/bonding/bond_alb.c-
drivers/net/bonding/bond_alb.c:	queue_delayed_work(bond->wq, &bond->alb_work, alb_delta_in_ticks);
drivers/net/bonding/bond_alb.c-	read_unlock(&bond->lock);
drivers/net/bonding/bond_alb.c-re_arm:
drivers/net/bonding/bond_main.c-
drivers/net/bonding/bond_main.c-
drivers/net/bonding/bond_main.c-
drivers/net/bonding/bond_main.c-
drivers/net/bonding/bond_main.c-
drivers/net/bonding/bond_main.c-
drivers/net/bonding/bond_main.c-
drivers/net/bonding/bond_main.c-
drivers/net/bonding/bond_main.c-
drivers/net/bonding/bond_main.c-{
drivers/net/bonding/bond_main.c-}
drivers/net/bonding/bond_main.c-}
drivers/net/bonding/bond_main.c-	}
drivers/net/bonding/bond_main.c-	}
drivers/net/bonding/bond_main.c-		bond->igmp_retrans = bond->params.resend_igmp;
drivers/net/bonding/bond_main.c-	     bond->params.mode == BOND_MODE_ROUNDROBIN)) {
drivers/net/bonding/bond_main.c-		bond->recv_probe = bond_3ad_lacpdu_recv;
drivers/net/bonding/bond_main.c-			bond->recv_probe = bond_arp_rcv;
drivers/net/bonding/bond_main.c:	cancel_delayed_work_sync(&bond->ad_work);
drivers/net/bonding/bond_main.c:	cancel_delayed_work_sync(&bond->alb_work);
drivers/net/bonding/bond_main.c:	cancel_delayed_work_sync(&bond->arp_work);
drivers/net/bonding/bond_main.c:	cancel_delayed_work_sync(&bond->mcast_work);
drivers/net/bonding/bond_main.c:	cancel_delayed_work_sync(&bond->mii_work);
drivers/net/bonding/bond_main.c-		if (bond_alb_initialize(bond, (bond->params.mode == BOND_MODE_ALB)))
drivers/net/bonding/bond_main.c-	if (--bond->igmp_retrans > 0)
drivers/net/bonding/bond_main.c-	if (bond->params.arp_interval)
drivers/net/bonding/bond_main.c-	if (bond->params.arp_interval)
drivers/net/bonding/bond_main.c-	if (bond->params.arp_interval) {  /* arp interval, in milliseconds. */
drivers/net/bonding/bond_main.c-		if (bond->params.arp_validate)
drivers/net/bonding/bond_main.c-	if (bond->params.miimon)
drivers/net/bonding/bond_main.c-	if (bond->params.miimon)  /* link check interval, in milliseconds. */
drivers/net/bonding/bond_main.c-	if (bond->params.mode == BOND_MODE_8023AD) {
drivers/net/bonding/bond_main.c:		queue_delayed_work(bond->wq, &bond->ad_work, 0);
drivers/net/bonding/bond_main.c:		queue_delayed_work(bond->wq, &bond->alb_work, 0);
drivers/net/bonding/bond_main.c:		queue_delayed_work(bond->wq, &bond->arp_work, 0);
drivers/net/bonding/bond_main.c:		queue_delayed_work(bond->wq, &bond->arp_work, delta_in_ticks);
drivers/net/bonding/bond_main.c:		queue_delayed_work(bond->wq, &bond->arp_work, delta_in_ticks);
drivers/net/bonding/bond_main.c:		queue_delayed_work(bond->wq, &bond->mcast_work, 0);
drivers/net/bonding/bond_main.c:		queue_delayed_work(bond->wq, &bond->mcast_work, HZ/5);
drivers/net/bonding/bond_main.c:		queue_delayed_work(bond->wq, &bond->mii_work, 0);
drivers/net/bonding/bond_main.c:		queue_delayed_work(bond->wq, &bond->mii_work, delay);
drivers/net/bonding/bond_main.c-	read_unlock(&bond->lock);
drivers/net/bonding/bond_main.c-	read_unlock(&bond->lock);
drivers/net/bonding/bond_main.c-	read_unlock(&bond->lock);
drivers/net/bonding/bond_main.c-	read_unlock(&bond->lock);
drivers/net/bonding/bond_main.c-re_arm:
drivers/net/bonding/bond_main.c-re_arm:
drivers/net/bonding/bond_main.c-re_arm:
drivers/net/bonding/bond_main.c-		/* register to receive LACPDUs */
drivers/net/bonding/bond_main.c-			return -ENOMEM;
drivers/net/bonding/bond_main.c-static void bond_work_cancel_all(struct bonding *bond)
drivers/net/bonding/bond_sysfs.c-	}
drivers/net/bonding/bond_sysfs.c-	}
drivers/net/bonding/bond_sysfs.c-		}
drivers/net/bonding/bond_sysfs.c-		}
drivers/net/bonding/bond_sysfs.c-		 */
drivers/net/bonding/bond_sysfs.c-		 */
drivers/net/bonding/bond_sysfs.c:			cancel_delayed_work_sync(&bond->arp_work);
drivers/net/bonding/bond_sysfs.c:			cancel_delayed_work_sync(&bond->arp_work);
drivers/net/bonding/bond_sysfs.c:			cancel_delayed_work_sync(&bond->mii_work);
drivers/net/bonding/bond_sysfs.c:			cancel_delayed_work_sync(&bond->mii_work);
drivers/net/bonding/bond_sysfs.c-		} else {
drivers/net/bonding/bond_sysfs.c-		} else {
drivers/net/bonding/bond_sysfs.c-		if (!new_value) {
drivers/net/bonding/bond_sysfs.c-		if (!new_value) {
drivers/net/bonding/bond_sysfs.c:			queue_delayed_work(bond->wq, &bond->arp_work, 0);
drivers/net/bonding/bond_sysfs.c:			queue_delayed_work(bond->wq, &bond->mii_work, 0);
drivers/net/can/sja1000/peak_pci.c-
drivers/net/can/sja1000/peak_pci.c-
drivers/net/can/sja1000/peak_pci.c-
drivers/net/can/sja1000/peak_pci.c-{
drivers/net/can/sja1000/peak_pci.c-{
drivers/net/can/sja1000/peak_pci.c-}
drivers/net/can/sja1000/peak_pci.c-}
drivers/net/can/sja1000/peak_pci.c-}
drivers/net/can/sja1000/peak_pci.c:	cancel_delayed_work_sync(&card->led_work);
drivers/net/can/sja1000/peak_pci.c:	if (!delayed_work_pending(&card->led_work))
drivers/net/can/sja1000/peak_pci.c-	if (up_count)
drivers/net/can/sja1000/peak_pci.c-	int chan_count;
drivers/net/can/sja1000/peak_pci.c-	/* restart timer (except if no more configured channels) */
drivers/net/can/sja1000/peak_pci.c:		schedule_delayed_work(&card->led_work, HZ);
drivers/net/can/sja1000/peak_pci.c:		schedule_delayed_work(&card->led_work, HZ);
drivers/net/can/sja1000/peak_pci.c-static void peak_pciec_start_led_work(struct peak_pciec_card *card)
drivers/net/can/sja1000/peak_pci.c-static void peak_pciec_stop_led_work(struct peak_pciec_card *card)
drivers/net/can/sja1000/peak_pci.c:	struct delayed_work led_work;	/* led delayed work */
drivers/net/can/sja1000/peak_pci.c-	struct i2c_adapter led_chip;
drivers/net/can/sja1000/peak_pci.c-	struct i2c_algo_bit_data i2c_bit;
drivers/net/can/sja1000/peak_pci.c-	struct peak_pciec_chan channel[PEAK_PCI_CHAN_MAX];
drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.c-
drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.c-
drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.c-}
drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.c:	schedule_delayed_work(&bp->sp_rtnl_task, 0);
drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.c-	/* This allows the netif to be shutdown gracefully before resetting */
drivers/net/ethernet/broadcom/bnx2x/bnx2x_dcb.c-
drivers/net/ethernet/broadcom/bnx2x/bnx2x_dcb.c-}
drivers/net/ethernet/broadcom/bnx2x/bnx2x_dcb.c-	 */
drivers/net/ethernet/broadcom/bnx2x/bnx2x_dcb.c-	if (!test_and_set_bit(BNX2X_SP_RTNL_SETUP_TC, &bp->sp_rtnl_state))
drivers/net/ethernet/broadcom/bnx2x/bnx2x_dcb.c:		schedule_delayed_work(&bp->sp_rtnl_task, 0);
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c-
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c-
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c-
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c-
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c-
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c-
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c-
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c-
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c-
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c-
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c-
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c-
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c-}
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c-}
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c-	}
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c-	}
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c-					}
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c-					 */
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c-					 */
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c-	bnx2x_dcbx_pmf_update(bp);
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c-		bnx2x_int_disable(bp);
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c-			bnx2x_link_report(bp);
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c-		bp->link_params.req_line_speed[cfx_idx] = req_line_speed;
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c-		bp->recovery_state = BNX2X_RECOVERY_INIT;
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c-							&bp->sp_rtnl_task,
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:	cancel_delayed_work(&bp->period_task);
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:	cancel_delayed_work(&bp->sp_task);
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:	cancel_delayed_work_sync(&bp->sp_rtnl_task);
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c-		/* Disable HW interrupts */
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c-					 * down.
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c-		} else
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c-#endif
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c-	flush_workqueue(bnx2x_wq);
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c-							HZ/10);
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c-								HZ/10);
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c-								HZ/10);
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c-					if (bnx2x_reset_is_global(bp)) {
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c-	if (bp->regview)
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c-#ifndef BNX2X_STOP_ON_ERROR
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c-	if (unlikely(status & 0x1)) {
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c-	/* Make sure RESET task is not scheduled before continuing */
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c-	/* make sure sp_task is not running */
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c-	/* queue a periodic task */
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:			queue_delayed_work(bnx2x_wq, &bp->period_task, 0);
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:	queue_delayed_work(bnx2x_wq, &bp->period_task, 0);
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:		queue_delayed_work(bnx2x_wq, &bp->period_task, 1*HZ);
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:		queue_delayed_work(bnx2x_wq, &bp->sp_task, 0);
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:	queue_delayed_work(bnx2x_wq, &bp->sp_task, 0);
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c-		/* Re-queue task in 1 sec */
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c-					return;
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c-					return;
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c-	return IRQ_HANDLED;
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c-		return rc;
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:						schedule_delayed_work(
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:					schedule_delayed_work(&bp->sp_rtnl_task,
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:					schedule_delayed_work(&bp->sp_rtnl_task,
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:		schedule_delayed_work(&bp->sp_rtnl_task, 0);
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:	schedule_delayed_work(&bp->sp_rtnl_task, 0);
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c-	set_bit(BNX2X_SP_RTNL_FAN_FAILURE, &bp->sp_rtnl_state);
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c-	smp_mb__after_clear_bit();
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c-		status &= ~0x1;
drivers/net/ethernet/broadcom/cnic.c-
drivers/net/ethernet/broadcom/cnic.c-
drivers/net/ethernet/broadcom/cnic.c-
drivers/net/ethernet/broadcom/cnic.c-
drivers/net/ethernet/broadcom/cnic.c-
drivers/net/ethernet/broadcom/cnic.c-
drivers/net/ethernet/broadcom/cnic.c-
drivers/net/ethernet/broadcom/cnic.c-	}
drivers/net/ethernet/broadcom/cnic.c-	}
drivers/net/ethernet/broadcom/cnic.c-		break;
drivers/net/ethernet/broadcom/cnic.c:	cancel_delayed_work(&cp->delete_task);
drivers/net/ethernet/broadcom/cnic.c-	cnic_bnx2x_delete_wait(dev, 0);
drivers/net/ethernet/broadcom/cnic.c-	flush_workqueue(cnic_wq);
drivers/net/ethernet/broadcom/cnic.c-		goto destroy_reply;
drivers/net/ethernet/broadcom/cnic.c-	if (need_resched)
drivers/net/ethernet/broadcom/cnic.c-	kcqe.op_code = FCOE_KCQE_OPCODE_DESTROY_CONN;
drivers/net/ethernet/broadcom/cnic.c-				   msecs_to_jiffies(10));
drivers/net/ethernet/broadcom/cnic.c:		queue_delayed_work(cnic_wq, &cp->delete_task,
drivers/net/ethernet/broadcom/cnic.c:		queue_delayed_work(cnic_wq, &cp->delete_task, 0);
drivers/net/ethernet/broadcom/cnic.c:		queue_delayed_work(cnic_wq, &cp->delete_task, delta);
drivers/net/ethernet/broadcom/cnic.c:	queue_delayed_work(cnic_wq, &cp->delete_task, msecs_to_jiffies(2000));
drivers/net/ethernet/broadcom/cnic.c-		set_bit(CNIC_LCL_FL_STOP_ISCSI, &cp->cnic_local_flags);
drivers/net/ethernet/broadcom/cnic.c-		set_bit(CTX_FL_DELETE_WAIT, &ctx->ctx_flags);
drivers/net/ethernet/broadcom/cnic.c-	set_bit(CTX_FL_DELETE_WAIT, &ctx->ctx_flags);
drivers/net/ethernet/broadcom/cnic.c-		struct cnic_local *cp = dev->cnic_priv;
drivers/net/ethernet/chelsio/cxgb3/cxgb3_main.c-
drivers/net/ethernet/chelsio/cxgb3/cxgb3_main.c-
drivers/net/ethernet/chelsio/cxgb3/cxgb3_main.c-
drivers/net/ethernet/chelsio/cxgb3/cxgb3_main.c-}
drivers/net/ethernet/chelsio/cxgb3/cxgb3_main.c-	    adap->params.stats_update_period * HZ;
drivers/net/ethernet/chelsio/cxgb3/cxgb3_main.c:		cancel_delayed_work_sync(&adapter->adap_check_task);
drivers/net/ethernet/chelsio/cxgb3/cxgb3_main.c-	if (!adapter->open_device_map)
drivers/net/ethernet/chelsio/cxgb3/cxgb3_main.c-	if (!(adapter->open_device_map & PORT_MASK))
drivers/net/ethernet/chelsio/cxgb3/cxgb3_main.c-	if (timeo)
drivers/net/ethernet/chelsio/cxgb3/cxgb3_main.c:		queue_delayed_work(cxgb3_wq, &adap->adap_check_task, timeo);
drivers/net/ethernet/chelsio/cxgb/cxgb2.c-
drivers/net/ethernet/chelsio/cxgb/cxgb2.c-
drivers/net/ethernet/chelsio/cxgb/cxgb2.c-{
drivers/net/ethernet/chelsio/cxgb/cxgb2.c-{
drivers/net/ethernet/chelsio/cxgb/cxgb2.c-}
drivers/net/ethernet/chelsio/cxgb/cxgb2.c-}
drivers/net/ethernet/chelsio/cxgb/cxgb2.c:	cancel_delayed_work(&ap->stats_update_task);
drivers/net/ethernet/chelsio/cxgb/cxgb2.c:	schedule_delayed_work(&ap->stats_update_task, secs * HZ);
drivers/net/ethernet/chelsio/cxgb/cxgb2.c-static inline void cancel_mac_stats_update(struct adapter *ap)
drivers/net/ethernet/chelsio/cxgb/cxgb2.c-static inline void schedule_mac_stats_update(struct adapter *ap, int secs)
drivers/net/ethernet/chelsio/cxgb/my3126.c-{
drivers/net/ethernet/chelsio/cxgb/my3126.c-{
drivers/net/ethernet/chelsio/cxgb/my3126.c-}
drivers/net/ethernet/chelsio/cxgb/my3126.c:	cancel_delayed_work_sync(&cphy->phy_update);
drivers/net/ethernet/chelsio/cxgb/my3126.c-	return 0;
drivers/net/ethernet/chelsio/cxgb/my3126.c-	return 0;
drivers/net/ethernet/chelsio/cxgb/my3126.c:	schedule_delayed_work(&cphy->phy_update, HZ/30);
drivers/net/ethernet/chelsio/cxgb/my3126.c-static int my3126_interrupt_disable(struct cphy *cphy)
drivers/net/ethernet/chelsio/cxgb/my3126.c-static int my3126_interrupt_enable(struct cphy *cphy)
drivers/net/ethernet/chelsio/cxgb/my3126.c-	t1_tpi_read(cphy->adapter, A_ELMER0_GPO, &cphy->elmer_gpo);
drivers/net/ethernet/davicom/dm9000.c-
drivers/net/ethernet/davicom/dm9000.c-
drivers/net/ethernet/davicom/dm9000.c-
drivers/net/ethernet/davicom/dm9000.c-
drivers/net/ethernet/davicom/dm9000.c-
drivers/net/ethernet/davicom/dm9000.c-{
drivers/net/ethernet/davicom/dm9000.c-{
drivers/net/ethernet/davicom/dm9000.c-}
drivers/net/ethernet/davicom/dm9000.c-	}
drivers/net/ethernet/davicom/dm9000.c-		}
drivers/net/ethernet/davicom/dm9000.c-	board_info_t *db = container_of(dw, board_info_t, phy_poll);
drivers/net/ethernet/davicom/dm9000.c:	cancel_delayed_work_sync(&db->phy_poll);
drivers/net/ethernet/davicom/dm9000.c-		dev_dbg(db->dev, "shutting down %s\n", ndev->name);
drivers/net/ethernet/davicom/dm9000.c-dm9000_poll_work(struct work_struct *w)
drivers/net/ethernet/davicom/dm9000.c-			/* fire a link-change request */
drivers/net/ethernet/davicom/dm9000.c-	if (db->type == TYPE_DM9000E)
drivers/net/ethernet/davicom/dm9000.c-		if (int_status & ISR_LNKCHNG) {
drivers/net/ethernet/davicom/dm9000.c-	netif_stop_queue(ndev);
drivers/net/ethernet/davicom/dm9000.c:			schedule_delayed_work(&db->phy_poll, 1);
drivers/net/ethernet/davicom/dm9000.c:		schedule_delayed_work(&db->phy_poll, HZ * 2);
drivers/net/ethernet/davicom/dm9000.c:	struct delayed_work *dw = to_delayed_work(w);
drivers/net/ethernet/davicom/dm9000.c:	struct delayed_work phy_poll;
drivers/net/ethernet/davicom/dm9000.c-	struct mutex	 addr_lock;	/* phy and eeprom access lock */
drivers/net/ethernet/davicom/dm9000.c-	struct net_device  *ndev;
drivers/net/ethernet/davicom/dm9000.c-	struct net_device *ndev = db->ndev;
drivers/net/ethernet/emulex/benet/be_main.c-
drivers/net/ethernet/emulex/benet/be_main.c-
drivers/net/ethernet/emulex/benet/be_main.c-
drivers/net/ethernet/emulex/benet/be_main.c-
drivers/net/ethernet/emulex/benet/be_main.c-
drivers/net/ethernet/emulex/benet/be_main.c-
drivers/net/ethernet/emulex/benet/be_main.c-}
drivers/net/ethernet/emulex/benet/be_main.c-	}
drivers/net/ethernet/emulex/benet/be_main.c-	}
drivers/net/ethernet/emulex/benet/be_main.c-		adapter->flags &= ~BE_FLAGS_WORKER_SCHEDULED;
drivers/net/ethernet/emulex/benet/be_main.c-	adapter->flags |= BE_FLAGS_WORKER_SCHEDULED;
drivers/net/ethernet/emulex/benet/be_main.c-	adapter->work_counter++;
drivers/net/ethernet/emulex/benet/be_main.c:	cancel_delayed_work_sync(&adapter->work);
drivers/net/ethernet/emulex/benet/be_main.c:		cancel_delayed_work_sync(&adapter->work);
drivers/net/ethernet/emulex/benet/be_main.c-	if (adapter->flags & BE_FLAGS_WORKER_SCHEDULED) {
drivers/net/ethernet/emulex/benet/be_main.c-	netif_device_detach(adapter->netdev);
drivers/net/ethernet/emulex/benet/be_main.c-reschedule:
drivers/net/ethernet/emulex/benet/be_main.c-		return;
drivers/net/ethernet/emulex/benet/be_main.c:	schedule_delayed_work(&adapter->work, msecs_to_jiffies(1000));
drivers/net/ethernet/emulex/benet/be_main.c:	schedule_delayed_work(&adapter->work, msecs_to_jiffies(1000));
drivers/net/ethernet/ibm/ehea/ehea_main.c-
drivers/net/ethernet/ibm/ehea/ehea_main.c-
drivers/net/ethernet/ibm/ehea/ehea_main.c-
drivers/net/ethernet/ibm/ehea/ehea_main.c-}
drivers/net/ethernet/ibm/ehea/ehea_main.c:	cancel_delayed_work_sync(&port->stats_work);
drivers/net/ethernet/ibm/ehea/ehea_main.c:	cancel_delayed_work_sync(&port->stats_work);
drivers/net/ethernet/ibm/ehea/ehea_main.c-	cancel_work_sync(&port->reset_task);
drivers/net/ethernet/ibm/ehea/ehea_main.c-	cancel_work_sync(&port->reset_task);
drivers/net/ethernet/ibm/ehea/ehea_main.c-	ehea_unregister_port(port);
drivers/net/ethernet/ibm/ehea/ehea_main.c-	free_page((unsigned long)cb2);
drivers/net/ethernet/ibm/ehea/ehea_main.c-	mutex_lock(&port->port_lock);
drivers/net/ethernet/ibm/ehea/ehea_main.c-	mutex_unlock(&port->port_lock);
drivers/net/ethernet/ibm/ehea/ehea_main.c-	netif_tx_stop_all_queues(dev);
drivers/net/ethernet/ibm/ehea/ehea_main.c-resched:
drivers/net/ethernet/ibm/ehea/ehea_main.c-			      round_jiffies_relative(msecs_to_jiffies(1000)));
drivers/net/ethernet/ibm/ehea/ehea_main.c-			      round_jiffies_relative(msecs_to_jiffies(1000)));
drivers/net/ethernet/ibm/ehea/ehea_main.c:	schedule_delayed_work(&port->stats_work,
drivers/net/ethernet/ibm/ehea/ehea_main.c:	schedule_delayed_work(&port->stats_work,
drivers/net/ethernet/ibm/ehea/ehea_main.c-	set_bit(__EHEA_DISABLE_PORT_RESET, &port->flags);
drivers/net/ethernet/ibm/ehea/ehea_main.c-	unregister_netdev(port->netdev);
drivers/net/ethernet/ibm/emac/core.c-{
drivers/net/ethernet/ibm/emac/core.c-}
drivers/net/ethernet/ibm/emac/core.c-	}
drivers/net/ethernet/ibm/emac/core.c-	}
drivers/net/ethernet/ibm/emac/core.c-	}
drivers/net/ethernet/ibm/emac/core.c- bail:
drivers/net/ethernet/ibm/emac/core.c:		cancel_delayed_work_sync(&dev->link_work);
drivers/net/ethernet/ibm/emac/core.c:		cancel_delayed_work_sync(&dev->link_work);
drivers/net/ethernet/ibm/emac/core.c:		container_of(to_delayed_work(work),
drivers/net/ethernet/ibm/emac/core.c-		dev->link_polling = 0;
drivers/net/ethernet/ibm/emac/core.c-		dev->link_polling = 1;
drivers/net/ethernet/ibm/emac/core.c-	} else
drivers/net/ethernet/ibm/emac/core.c-		emac_print_link_status(dev);
drivers/net/ethernet/ibm/emac/core.c-		if (dev->link_polling)
drivers/net/ethernet/ibm/emac/core.c-	if (dev->link_polling) {
drivers/net/ethernet/ibm/emac/core.c-	if (dev->phy.address >= 0) {
drivers/net/ethernet/ibm/emac/core.c-	int link_poll_interval;
drivers/net/ethernet/ibm/emac/core.c-		link_poll_interval = PHY_POLL_LINK_OFF;
drivers/net/ethernet/ibm/emac/core.c-	mutex_lock(&dev->link_lock);
drivers/net/ethernet/ibm/emac/core.c-	mutex_unlock(&dev->link_lock);
drivers/net/ethernet/ibm/emac/core.c:		schedule_delayed_work(&dev->link_work, link_poll_interval);
drivers/net/ethernet/ibm/emac/core.c:	schedule_delayed_work(&dev->link_work, link_poll_interval);
drivers/net/ethernet/ibm/emac/core.c:			schedule_delayed_work(&dev->link_work,  PHY_POLL_LINK_OFF);
drivers/net/ethernet/ibm/emac/core.c-	smp_rmb();
drivers/net/ethernet/ibm/emac/core.c-	struct emac_instance *dev =
drivers/net/ethernet/ibm/emac/core.c-			     struct emac_instance, link_work);
drivers/net/ethernet/ibm/emac/core.c-		wmb();
drivers/net/ethernet/icplus/ipg.c-
drivers/net/ethernet/icplus/ipg.c-
drivers/net/ethernet/icplus/ipg.c-}
drivers/net/ethernet/icplus/ipg.c-	}
drivers/net/ethernet/icplus/ipg.c-	}
drivers/net/ethernet/icplus/ipg.c-	if (ipg_io_config(dev) < 0) {
drivers/net/ethernet/icplus/ipg.c-		IPG_DDEBUG_MSG("HostError Interrupt\n");
drivers/net/ethernet/icplus/ipg.c-		netdev_info(dev, "Cannot recover from PCI error\n");
drivers/net/ethernet/icplus/ipg.c:		schedule_delayed_work(&sp->task, 0);
drivers/net/ethernet/icplus/ipg.c:		schedule_delayed_work(&sp->task, HZ);
drivers/net/ethernet/intel/e1000/e1000_main.c-
drivers/net/ethernet/intel/e1000/e1000_main.c-
drivers/net/ethernet/intel/e1000/e1000_main.c-
drivers/net/ethernet/intel/e1000/e1000_main.c-
drivers/net/ethernet/intel/e1000/e1000_main.c-
drivers/net/ethernet/intel/e1000/e1000_main.c-}
drivers/net/ethernet/intel/e1000/e1000_main.c-	}
drivers/net/ethernet/intel/e1000/e1000_main.c-	}
drivers/net/ethernet/intel/e1000/e1000_main.c-	}
drivers/net/ethernet/intel/e1000/e1000_main.c-		}
drivers/net/ethernet/intel/e1000/e1000_main.c-		}
drivers/net/ethernet/intel/e1000/e1000_main.c-						      2 * HZ);
drivers/net/ethernet/intel/e1000/e1000_main.c-						      2 * HZ);
drivers/net/ethernet/intel/e1000/e1000_main.c-			adapter->smartspeed = 0;
drivers/net/ethernet/intel/e1000/e1000_main.c:	cancel_delayed_work_sync(&adapter->fifo_stall_task);
drivers/net/ethernet/intel/e1000/e1000_main.c:	cancel_delayed_work_sync(&adapter->phy_info_task);
drivers/net/ethernet/intel/e1000/e1000_main.c:	cancel_delayed_work_sync(&adapter->watchdog_task);
drivers/net/ethernet/intel/e1000/e1000_main.c-		cancel_work_sync(&adapter->reset_task);
drivers/net/ethernet/intel/e1000/e1000_main.c-		} else if (!test_bit(__E1000_DOWN, &adapter->flags)) {
drivers/net/ethernet/intel/e1000/e1000_main.c-		/* guard against interrupt when we're going down */
drivers/net/ethernet/intel/e1000/e1000_main.c-			if (!test_bit(__E1000_DOWN, &adapter->flags))
drivers/net/ethernet/intel/e1000/e1000_main.c-			if (!test_bit(__E1000_DOWN, &adapter->flags))
drivers/net/ethernet/intel/e1000/e1000_main.c-		if (!test_bit(__E1000_DOWN, &adapter->flags))
drivers/net/ethernet/intel/e1000/e1000_main.c-		if (!test_bit(__E1000_DOWN, &adapter->flags))
drivers/net/ethernet/intel/e1000/e1000_main.c-	if (!test_bit(__E1000_DOWN, &adapter->flags))
drivers/net/ethernet/intel/e1000/e1000_main.c-			netif_carrier_on(netdev);
drivers/net/ethernet/intel/e1000/e1000_main.c-		netif_stop_queue(netdev);
drivers/net/ethernet/intel/e1000/e1000_main.c-			netif_wake_queue(netdev);
drivers/net/ethernet/intel/e1000/e1000_main.c-	/* Reschedule the task */
drivers/net/ethernet/intel/e1000/e1000_main.c-		return NETDEV_TX_BUSY;
drivers/net/ethernet/intel/e1000/e1000_main.c:			schedule_delayed_work(&adapter->fifo_stall_task, 1);
drivers/net/ethernet/intel/e1000/e1000_main.c:			schedule_delayed_work(&adapter->fifo_stall_task, 1);
drivers/net/ethernet/intel/e1000/e1000_main.c:				schedule_delayed_work(&adapter->phy_info_task,
drivers/net/ethernet/intel/e1000/e1000_main.c:				schedule_delayed_work(&adapter->phy_info_task,
drivers/net/ethernet/intel/e1000/e1000_main.c:			schedule_delayed_work(&adapter->watchdog_task, 1);
drivers/net/ethernet/intel/e1000/e1000_main.c:		schedule_delayed_work(&adapter->watchdog_task, 2 * HZ);
drivers/net/ethernet/intel/e1000/e1000_main.c-unlock:
drivers/net/ethernet/intel/e1000e/netdev.c-
drivers/net/ethernet/intel/e1000e/netdev.c-
drivers/net/ethernet/intel/e1000e/netdev.c-}
drivers/net/ethernet/intel/e1000e/netdev.c-	schedule_work(&adapter->watchdog_task);
drivers/net/ethernet/intel/e1000e/netdev.c:	/* TODO: make this use queue_delayed_work() */
drivers/net/ethernet/mellanox/mlx4/en_netdev.c-
drivers/net/ethernet/mellanox/mlx4/en_netdev.c-
drivers/net/ethernet/mellanox/mlx4/en_netdev.c-
drivers/net/ethernet/mellanox/mlx4/en_netdev.c-{
drivers/net/ethernet/mellanox/mlx4/en_netdev.c-	}
drivers/net/ethernet/mellanox/mlx4/en_netdev.c-	}
drivers/net/ethernet/mellanox/mlx4/en_netdev.c:	cancel_delayed_work(&priv->stats_task);
drivers/net/ethernet/mellanox/mlx4/en_netdev.c-	/* flush any pending task for this netdev */
drivers/net/ethernet/mellanox/mlx4/en_netdev.c-	flush_workqueue(mdev->workqueue);
drivers/net/ethernet/mellanox/mlx4/en_netdev.c-	if (mdev->mac_removed[MLX4_MAX_PORTS + 1 - priv->port]) {
drivers/net/ethernet/mellanox/mlx4/en_netdev.c-			mlx4_en_auto_moderation(priv);
drivers/net/ethernet/mellanox/mlx4/en_netdev.c-	mlx4_en_set_default_moderation(priv);
drivers/net/ethernet/mellanox/mlx4/en_netdev.c-		mlx4_free_hwq_res(mdev->dev, &priv->res, MLX4_EN_PAGE_SIZE);
drivers/net/ethernet/mellanox/mlx4/en_netdev.c:		queue_delayed_work(mdev->workqueue, &priv->stats_task, STATS_DELAY);
drivers/net/ethernet/mellanox/mlx4/en_netdev.c:	queue_delayed_work(mdev->workqueue, &priv->stats_task, STATS_DELAY);
drivers/net/ethernet/mellanox/mlx4/en_netdev.c-	return 0;
drivers/net/ethernet/mellanox/mlx4/en_netdev.c-static void mlx4_en_do_get_stats(struct work_struct *work)
drivers/net/ethernet/mellanox/mlx4/en_netdev.c-						 stats_task);
drivers/net/ethernet/mellanox/mlx4/en_netdev.c:	struct delayed_work *delay = to_delayed_work(work);
drivers/net/ethernet/mellanox/mlx4/en_netdev.c-	struct mlx4_en_priv *priv = container_of(delay, struct mlx4_en_priv,
drivers/net/ethernet/mellanox/mlx4/sense.c-
drivers/net/ethernet/mellanox/mlx4/sense.c-
drivers/net/ethernet/mellanox/mlx4/sense.c-{
drivers/net/ethernet/mellanox/mlx4/sense.c-{
drivers/net/ethernet/mellanox/mlx4/sense.c-}
drivers/net/ethernet/mellanox/mlx4/sense.c-}
drivers/net/ethernet/mellanox/mlx4/sense.c-}
drivers/net/ethernet/mellanox/mlx4/sense.c:	cancel_delayed_work_sync(&mlx4_priv(dev)->sense.sense_poll);
drivers/net/ethernet/mellanox/mlx4/sense.c-	mutex_unlock(&priv->port_mutex);
drivers/net/ethernet/mellanox/mlx4/sense.c:	queue_delayed_work(mlx4_wq , &sense->sense_poll,
drivers/net/ethernet/mellanox/mlx4/sense.c:	queue_delayed_work(mlx4_wq , &sense->sense_poll,
drivers/net/ethernet/mellanox/mlx4/sense.c-		return;
drivers/net/ethernet/mellanox/mlx4/sense.c-			   round_jiffies_relative(MLX4_SENSE_RANGE));
drivers/net/ethernet/mellanox/mlx4/sense.c-			   round_jiffies_relative(MLX4_SENSE_RANGE));
drivers/net/ethernet/mellanox/mlx4/sense.c-sense_again:
drivers/net/ethernet/mellanox/mlx4/sense.c-						sense_poll);
drivers/net/ethernet/mellanox/mlx4/sense.c-static void mlx4_sense_port(struct work_struct *work)
drivers/net/ethernet/mellanox/mlx4/sense.c:	struct delayed_work *delay = to_delayed_work(work);
drivers/net/ethernet/mellanox/mlx4/sense.c-	struct mlx4_sense *sense = container_of(delay, struct mlx4_sense,
drivers/net/ethernet/mellanox/mlx4/sense.c-void mlx4_stop_sense(struct mlx4_dev *dev)
drivers/net/ethernet/qlogic/netxen/netxen_nic_main.c-
drivers/net/ethernet/qlogic/netxen/netxen_nic_main.c-
drivers/net/ethernet/qlogic/netxen/netxen_nic_main.c-
drivers/net/ethernet/qlogic/netxen/netxen_nic_main.c-{
drivers/net/ethernet/qlogic/netxen/netxen_nic_main.c-}
drivers/net/ethernet/qlogic/netxen/netxen_nic_main.c-}
drivers/net/ethernet/qlogic/netxen/netxen_nic_main.c:	cancel_delayed_work_sync(&adapter->fw_work);
drivers/net/ethernet/qlogic/netxen/netxen_nic_main.c-	INIT_DELAYED_WORK(&adapter->fw_work, func);
drivers/net/ethernet/qlogic/netxen/netxen_nic_main.c-		msleep(10);
drivers/net/ethernet/qlogic/netxen/netxen_nic_main.c:	schedule_delayed_work(&adapter->fw_work, delay);
drivers/net/ethernet/qlogic/qla3xxx.c-
drivers/net/ethernet/qlogic/qla3xxx.c-
drivers/net/ethernet/qlogic/qla3xxx.c-
drivers/net/ethernet/qlogic/qla3xxx.c-{
drivers/net/ethernet/qlogic/qla3xxx.c-}
drivers/net/ethernet/qlogic/qla3xxx.c-}
drivers/net/ethernet/qlogic/qla3xxx.c-	 */
drivers/net/ethernet/qlogic/qla3xxx.c-		}
drivers/net/ethernet/qlogic/qla3xxx.c:		cancel_delayed_work(&qdev->reset_work);
drivers/net/ethernet/qlogic/qla3xxx.c:		cancel_delayed_work(&qdev->tx_timeout_work);
drivers/net/ethernet/qlogic/qla3xxx.c-		destroy_workqueue(qdev->workqueue);
drivers/net/ethernet/qlogic/qla3xxx.c-	} else if (value & ISP_IMR_DISABLE_CMPL_INT) {
drivers/net/ethernet/qlogic/qla3xxx.c-	if (qdev->workqueue) {
drivers/net/ethernet/qlogic/qla3xxx.c-		qdev->workqueue = NULL;
drivers/net/ethernet/qlogic/qla3xxx.c:	queue_delayed_work(qdev->workqueue, &qdev->link_state_work, 0);
drivers/net/ethernet/qlogic/qla3xxx.c:		queue_delayed_work(qdev->workqueue, &qdev->reset_work, 0);
drivers/net/ethernet/qlogic/qla3xxx.c:	queue_delayed_work(qdev->workqueue, &qdev->tx_timeout_work, 0);
drivers/net/ethernet/qlogic/qla3xxx.c-		spin_unlock(&qdev->adapter_lock);
drivers/net/ethernet/qlogic/qla3xxx.c-	struct ql3_adapter *qdev = (struct ql3_adapter *)ptr;
drivers/net/ethernet/qlogic/qla3xxx.c-				   value);
drivers/net/ethernet/qlogic/qla3xxx.c-	 * Wake up the worker to process this event.
drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c-
drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c-
drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c-
drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c-
drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c-
drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c-}
drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c-}
drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c:	cancel_delayed_work_sync(&adapter->fw_work);
drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c:	cancel_delayed_work_sync(&adapter->fw_work);
drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c-	if (netif_running(netdev))
drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c-	INIT_DELAYED_WORK(&adapter->fw_work, func);
drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c-		msleep(10);
drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c-	netif_device_detach(netdev);
drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c:	queue_delayed_work(qlcnic_wq, &adapter->fw_work,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c-					round_jiffies_relative(delay));
drivers/net/ethernet/qlogic/qlge/qlge_main.c-
drivers/net/ethernet/qlogic/qlge/qlge_main.c-
drivers/net/ethernet/qlogic/qlge/qlge_main.c-
drivers/net/ethernet/qlogic/qlge/qlge_main.c-
drivers/net/ethernet/qlogic/qlge/qlge_main.c-
drivers/net/ethernet/qlogic/qlge/qlge_main.c-{
drivers/net/ethernet/qlogic/qlge/qlge_main.c-}
drivers/net/ethernet/qlogic/qlge/qlge_main.c-}
drivers/net/ethernet/qlogic/qlge/qlge_main.c-}
drivers/net/ethernet/qlogic/qlge/qlge_main.c-	 */
drivers/net/ethernet/qlogic/qlge/qlge_main.c-	 */
drivers/net/ethernet/qlogic/qlge/qlge_main.c:		cancel_delayed_work_sync(&qdev->asic_reset_work);
drivers/net/ethernet/qlogic/qlge/qlge_main.c:	cancel_delayed_work_sync(&qdev->mpi_core_to_log);
drivers/net/ethernet/qlogic/qlge/qlge_main.c:	cancel_delayed_work_sync(&qdev->mpi_idc_work);
drivers/net/ethernet/qlogic/qlge/qlge_main.c:	cancel_delayed_work_sync(&qdev->mpi_port_cfg_work);
drivers/net/ethernet/qlogic/qlge/qlge_main.c:	cancel_delayed_work_sync(&qdev->mpi_reset_work);
drivers/net/ethernet/qlogic/qlge/qlge_main.c:	cancel_delayed_work_sync(&qdev->mpi_work);
drivers/net/ethernet/qlogic/qlge/qlge_main.c-exit:
drivers/net/ethernet/qlogic/qlge/qlge_main.c-		goto exit;
drivers/net/ethernet/qlogic/qlge/qlge_main.c-	if (test_bit(QL_ADAPTER_UP, &qdev->flags))
drivers/net/ethernet/qlogic/qlge/qlge_main.c-			&qdev->mpi_port_cfg_work, 3*HZ);
drivers/net/ethernet/qlogic/qlge/qlge_main.c-				qdev->workqueue, &qdev->mpi_work, 0);
drivers/net/ethernet/qlogic/qlge/qlge_main.c-		ql_disable_completion_interrupt(qdev, intr_context->intr);
drivers/net/ethernet/qlogic/qlge/qlge_main.c-	ql_link_off(qdev);
drivers/net/ethernet/qlogic/qlge/qlge_main.c-		ql_write32(qdev, INTR_MASK, (INTR_MASK_PI << 16));
drivers/net/ethernet/qlogic/qlge/qlge_main.c:		queue_delayed_work_on(smp_processor_id(),
drivers/net/ethernet/qlogic/qlge/qlge_main.c:	queue_delayed_work(qdev->workqueue,
drivers/net/ethernet/qlogic/qlge/qlge_main.c:	queue_delayed_work(qdev->workqueue, &qdev->asic_reset_work, 0);
drivers/net/ethernet/qlogic/qlge/qlge_main.c:	queue_delayed_work(qdev->workqueue, &qdev->mpi_port_cfg_work, 0);
drivers/net/ethernet/qlogic/qlge/qlge_main.c:	queue_delayed_work(qdev->workqueue, &qdev->mpi_reset_work, 0);
drivers/net/ethernet/qlogic/qlge/qlge_main.c-		return -EINVAL;
drivers/net/ethernet/qlogic/qlge/qlge_main.c-	return status;
drivers/net/ethernet/qlogic/qlge/qlge_main.c-	set_bit(QL_ASIC_RECOVERY, &qdev->flags);
drivers/net/ethernet/qlogic/qlge/qlge_main.c-	/* Wake up a worker to get/set the TX/RX frame sizes. */
drivers/net/ethernet/qlogic/qlge/qlge_main.c-		work_done++;
drivers/net/ethernet/qlogic/qlge/qlge_mpi.c-	}
drivers/net/ethernet/qlogic/qlge/qlge_mpi.c-	}
drivers/net/ethernet/qlogic/qlge/qlge_mpi.c-	}
drivers/net/ethernet/qlogic/qlge/qlge_mpi.c-		 */
drivers/net/ethernet/qlogic/qlge/qlge_mpi.c-		 */
drivers/net/ethernet/qlogic/qlge/qlge_mpi.c:	cancel_delayed_work_sync(&qdev->mpi_idc_work);
drivers/net/ethernet/qlogic/qlge/qlge_mpi.c:	cancel_delayed_work_sync(&qdev->mpi_port_cfg_work);
drivers/net/ethernet/qlogic/qlge/qlge_mpi.c:	cancel_delayed_work_sync(&qdev->mpi_work);
drivers/net/ethernet/qlogic/qlge/qlge_mpi.c-	    container_of(work, struct ql_adapter, mpi_reset_work.work);
drivers/net/ethernet/qlogic/qlge/qlge_mpi.c-	/* If we're not the dominant NIC function,
drivers/net/ethernet/qlogic/qlge/qlge_mpi.c-		netif_err(qdev, drv, qdev->ndev, "Core is dumped!\n");
drivers/net/ethernet/qlogic/qlge/qlge_mpi.c-		qdev->core_is_dumped = 1;
drivers/net/ethernet/qlogic/qlge/qlge_mpi.c-			&qdev->mpi_core_to_log, 5 * HZ);
drivers/net/ethernet/qlogic/qlge/qlge_mpi.c-				&qdev->mpi_port_cfg_work, 0);
drivers/net/ethernet/qlogic/qlge/qlge_mpi.c-		ql_write32(qdev, INTR_MASK, (INTR_MASK_PI << 16));
drivers/net/ethernet/qlogic/qlge/qlge_mpi.c-		ql_write32(qdev, INTR_MASK, (INTR_MASK_PI << 16));
drivers/net/ethernet/qlogic/qlge/qlge_mpi.c:		queue_delayed_work(qdev->workqueue,
drivers/net/ethernet/qlogic/qlge/qlge_mpi.c:		queue_delayed_work(qdev->workqueue,
drivers/net/ethernet/qlogic/qlge/qlge_mpi.c:		queue_delayed_work(qdev->workqueue, &qdev->mpi_idc_work, 0);
drivers/net/ethernet/qlogic/qlge/qlge_mpi.c-	return status;
drivers/net/ethernet/qlogic/qlge/qlge_mpi.c-	struct ql_adapter *qdev =
drivers/net/ethernet/qlogic/qlge/qlge_mpi.c-	 * then there is nothing to do.
drivers/net/ethernet/realtek/8139too.c-
drivers/net/ethernet/realtek/8139too.c-
drivers/net/ethernet/realtek/8139too.c-
drivers/net/ethernet/realtek/8139too.c-
drivers/net/ethernet/realtek/8139too.c-
drivers/net/ethernet/realtek/8139too.c-
drivers/net/ethernet/realtek/8139too.c-
drivers/net/ethernet/realtek/8139too.c-}
drivers/net/ethernet/realtek/8139too.c-}
drivers/net/ethernet/realtek/8139too.c-	}
drivers/net/ethernet/realtek/8139too.c-	assert (dev != NULL);
drivers/net/ethernet/realtek/8139too.c:	cancel_delayed_work_sync(&tp->thread);
drivers/net/ethernet/realtek/8139too.c-	if (tp->have_thread)
drivers/net/ethernet/realtek/8139too.c-	if (!tp->have_thread) {
drivers/net/ethernet/realtek/8139too.c-		INIT_DELAYED_WORK(&tp->thread, rtl8139_thread);
drivers/net/ethernet/realtek/8139too.c-out_unlock:
drivers/net/ethernet/realtek/8139too.c-	rtnl_unlock ();
drivers/net/ethernet/realtek/8139too.c:		schedule_delayed_work(&tp->thread, next_tick);
drivers/net/ethernet/realtek/8139too.c:	schedule_delayed_work(&tp->thread, next_tick);
drivers/net/ethernet/realtek/8139too.c:		schedule_delayed_work(&tp->thread, thr_delay);
drivers/net/ethernet/realtek/8139too.c:	struct delayed_work	thread;
drivers/net/ethernet/realtek/8139too.c-	struct mii_if_info	mii;
drivers/net/ethernet/realtek/8139too.c-	struct rtl_extra_stats	xstats;
drivers/net/ethernet/realtek/8139too.c-	tp->watchdog_fired = 0;
drivers/net/ethernet/realtek/8139too.c-	unregister_netdev (dev);
drivers/net/ethernet/sfc/efx.c-
drivers/net/ethernet/sfc/efx.c-{
drivers/net/ethernet/sfc/efx.c-}
drivers/net/ethernet/sfc/efx.c-	}
drivers/net/ethernet/sfc/efx.c:	cancel_delayed_work_sync(&efx->monitor_work);
drivers/net/ethernet/sfc/efx.c-			   efx_monitor_interval);
drivers/net/ethernet/sfc/efx.c-				   efx_monitor_interval);
drivers/net/ethernet/sfc/efx.c-	efx_selftest_async_cancel(efx);
drivers/net/ethernet/sfc/efx.c-	} else {
drivers/net/ethernet/sfc/efx.c-	 * flush, we could have a missed a link state change */
drivers/net/ethernet/sfc/efx.c-	if (efx->type->monitor != NULL) {
drivers/net/ethernet/sfc/efx.c-	/* Make sure the hardware monitor and event self-test are stopped */
drivers/net/ethernet/sfc/efx.c:		queue_delayed_work(efx->workqueue, &efx->monitor_work,
drivers/net/ethernet/sfc/efx.c:	queue_delayed_work(efx->workqueue, &efx->monitor_work,
drivers/net/ethernet/sfc/efx.c-	/* Stop scheduled port reconfigurations */
drivers/net/ethernet/sfc/selftest.c-
drivers/net/ethernet/sfc/selftest.c-
drivers/net/ethernet/sfc/selftest.c-{
drivers/net/ethernet/sfc/selftest.c-}
drivers/net/ethernet/sfc/selftest.c-}
drivers/net/ethernet/sfc/selftest.c:	cancel_delayed_work_sync(&efx->selftest_work);
drivers/net/ethernet/sfc/selftest.c-	efx_for_each_channel(channel, efx)
drivers/net/ethernet/sfc/selftest.c-		efx_nic_event_test_start(channel);
drivers/net/ethernet/sfc/selftest.c:	schedule_delayed_work(&efx->selftest_work, IRQ_TIMEOUT);
drivers/net/ethernet/sfc/selftest.c-void efx_selftest_async_cancel(struct efx_nic *efx)
drivers/net/ethernet/tile/tilepro.c-
drivers/net/ethernet/tile/tilepro.c-
drivers/net/ethernet/tile/tilepro.c-
drivers/net/ethernet/tile/tilepro.c-
drivers/net/ethernet/tile/tilepro.c-{
drivers/net/ethernet/tile/tilepro.c-	 */
drivers/net/ethernet/tile/tilepro.c-	 */
drivers/net/ethernet/tile/tilepro.c:	cancel_delayed_work_sync(&priv->retry_work);
drivers/net/ethernet/tile/tilepro.c-	/* Can't transmit any more. */
drivers/net/ethernet/tile/tilepro.c:		container_of(w, struct delayed_work, work);
drivers/net/ethernet/tile/tilepro.c-	else
drivers/net/ethernet/tile/tilepro.c-	/* For NetIO bringup retries. */
drivers/net/ethernet/tile/tilepro.c-	if (tile_net_open_inner(priv->dev) != 0)
drivers/net/ethernet/tile/tilepro.c-	/* ISSUE: Only needed if not yet fully open. */
drivers/net/ethernet/tile/tilepro.c-	netif_carrier_off(dev);
drivers/net/ethernet/tile/tilepro.c-	/* Quick access to per cpu data. */
drivers/net/ethernet/tile/tilepro.c-	return 0;
drivers/net/ethernet/tile/tilepro.c:		schedule_delayed_work(&priv->retry_work,
drivers/net/ethernet/tile/tilepro.c:	schedule_delayed_work(&priv->retry_work, TILE_NET_RETRY_INTERVAL);
drivers/net/ethernet/tile/tilepro.c-static void tile_net_open_retry(struct work_struct *w)
drivers/net/ethernet/tile/tilepro.c:	struct delayed_work *dw =
drivers/net/ethernet/tile/tilepro.c:	struct delayed_work retry_work;
drivers/net/ethernet/tile/tilepro.c-	struct net_device_stats stats;
drivers/net/ethernet/tile/tilepro.c-	struct tile_net_cpu *cpu[NR_CPUS];
drivers/net/ethernet/tile/tilepro.c-	struct tile_net_priv *priv =
drivers/net/ethernet/tile/tilepro.c-				      TILE_NET_RETRY_INTERVAL);
drivers/net/ethernet/toshiba/ps3_gelic_wireless.c-
drivers/net/ethernet/toshiba/ps3_gelic_wireless.c-
drivers/net/ethernet/toshiba/ps3_gelic_wireless.c-
drivers/net/ethernet/toshiba/ps3_gelic_wireless.c-}
drivers/net/ethernet/toshiba/ps3_gelic_wireless.c-	}
drivers/net/ethernet/toshiba/ps3_gelic_wireless.c-	 */
drivers/net/ethernet/toshiba/ps3_gelic_wireless.c-	/* cancel all work queue */
drivers/net/ethernet/toshiba/ps3_gelic_wireless.c:	cancel_delayed_work(&wl->assoc_work);
drivers/net/ethernet/toshiba/ps3_gelic_wireless.c:	cancel_delayed_work(&wl->assoc_work);
drivers/net/ethernet/toshiba/ps3_gelic_wireless.c:	cancel_delayed_work(&wl->event_work);
drivers/net/ethernet/toshiba/ps3_gelic_wireless.c-do_associate:
drivers/net/ethernet/toshiba/ps3_gelic_wireless.c-	} else if (ret) {
drivers/net/ethernet/toshiba/ps3_gelic_wireless.c-	 * event work can run after netdev down
drivers/net/ethernet/toshiba/ps3_gelic_wireless.c-	flush_workqueue(wl->eurus_cmd_queue);
drivers/net/ethernet/toshiba/ps3_gelic_wireless.c-	flush_workqueue(wl->event_queue);
drivers/net/ethernet/toshiba/ps3_gelic_wireless.c-		goto out;
drivers/net/ethernet/toshiba/ps3_gelic_wireless.c-	if (ret == -ERESTARTSYS) {
drivers/net/ethernet/toshiba/ps3_gelic_wireless.c-	if (status & GELIC_CARD_WLAN_EVENT_RECEIVED) {
drivers/net/ethernet/toshiba/ps3_gelic_wireless.c-	if (wl->assoc_stat == GELIC_WL_ASSOC_STAT_ASSOCIATED)
drivers/net/ethernet/toshiba/ps3_gelic_wireless.c-		pr_debug("%s:event received\n", __func__);
drivers/net/ethernet/toshiba/ps3_gelic_wireless.c-		pr_debug("%s: scan start failed association\n", __func__);
drivers/net/ethernet/toshiba/ps3_gelic_wireless.c-	pr_debug("%s: start association work %d\n", __func__, ret);
drivers/net/ethernet/toshiba/ps3_gelic_wireless.c:		queue_delayed_work(wl->event_queue, &wl->event_work, 0);
drivers/net/ethernet/toshiba/ps3_gelic_wireless.c:	ret = schedule_delayed_work(&wl->assoc_work, 0);
drivers/net/ethernet/toshiba/ps3_gelic_wireless.c-	return ret;
drivers/net/ethernet/toshiba/ps3_gelic_wireless.c:		schedule_delayed_work(&wl->assoc_work, HZ/10); /*FIXME*/
drivers/net/hamradio/baycom_epp.c-
drivers/net/hamradio/baycom_epp.c-	bc->debug_vals.demod_cycles = time3 - time2;
drivers/net/hamradio/baycom_epp.c-	bc->hdlctx.calibrate = 0;
drivers/net/hamradio/baycom_epp.c-	bc->stat = EPP_DCDBIT;
drivers/net/hamradio/baycom_epp.c-	bc->work_running = 0;
drivers/net/hamradio/baycom_epp.c:	cancel_delayed_work_sync(&bc->run_work);
drivers/net/hamradio/baycom_epp.c-#endif /* BAYCOM_DEBUG */
drivers/net/hamradio/baycom_epp.c-	if (!bc->skb)
drivers/net/hamradio/baycom_epp.c-	netif_start_queue(dev);
drivers/net/hamradio/baycom_epp.c-		netif_wake_queue(dev);
drivers/net/hamradio/baycom_epp.c-	return 0;
drivers/net/hamradio/baycom_epp.c:	schedule_delayed_work(&bc->run_work, 1);
drivers/net/hamradio/baycom_epp.c:	schedule_delayed_work(&bc->run_work, 1);
drivers/net/hamradio/baycom_epp.c-	/* start the bottom half stuff */
drivers/net/hamradio/baycom_epp.c:	struct delayed_work run_work;
drivers/net/hamradio/baycom_epp.c-	struct net_device *dev;
drivers/net/hamradio/baycom_epp.c-	tmp[0] = 0;
drivers/net/hamradio/baycom_epp.c-	unsigned int bitrate;
drivers/net/hamradio/baycom_epp.c-	unsigned int modem;
drivers/net/hamradio/baycom_epp.c-	unsigned int work_running;
drivers/net/hyperv/netvsc_drv.c-
drivers/net/hyperv/netvsc_drv.c-
drivers/net/hyperv/netvsc_drv.c-};
drivers/net/hyperv/netvsc_drv.c:	cancel_delayed_work_sync(&ndev_ctx->dwork);
drivers/net/hyperv/netvsc_drv.c-	cancel_work_sync(&ndev_ctx->work);
drivers/net/hyperv/netvsc_drv.c-	} else {
drivers/net/hyperv/netvsc_drv.c-		ndev_ctx = netdev_priv(net);
drivers/net/hyperv/netvsc_drv.c-	ndev_ctx = netdev_priv(net);
drivers/net/hyperv/netvsc_drv.c-		netif_carrier_off(net);
drivers/net/hyperv/netvsc_drv.c-		netif_wake_queue(net);
drivers/net/hyperv/netvsc_drv.c-	/* point back to our device context */
drivers/net/hyperv/netvsc_drv.c:		schedule_delayed_work(&ndev_ctx->dwork, 0);
drivers/net/hyperv/netvsc_drv.c:		schedule_delayed_work(&ndev_ctx->dwork, msecs_to_jiffies(20));
drivers/net/hyperv/netvsc_drv.c:	struct delayed_work dwork;
drivers/net/hyperv/netvsc_drv.c-	struct hv_device *device_ctx;
drivers/net/hyperv/netvsc_drv.c-	struct work_struct work;
drivers/net/irda/sir_dev.c-
drivers/net/irda/sir_dev.c-
drivers/net/irda/sir_dev.c-
drivers/net/irda/sir_dev.c-}
drivers/net/irda/sir_dev.c-}
drivers/net/irda/sir_dev.c-	INIT_DELAYED_WORK(&fsm->work, sirdev_config_fsm);
drivers/net/irda/sir_dev.c:	queue_delayed_work(irda_sir_wq, &fsm->work, 0);
drivers/net/irda/sir_dev.c:	queue_delayed_work(irda_sir_wq, &fsm->work, msecs_to_jiffies(delay));
drivers/net/irda/sir_dev.c-	return 0;
drivers/net/irda/sir_dev.c-	} while(!delay);
drivers/net/phy/phy.c-
drivers/net/phy/phy.c-
drivers/net/phy/phy.c-
drivers/net/phy/phy.c-
drivers/net/phy/phy.c-
drivers/net/phy/phy.c-
drivers/net/phy/phy.c-{
drivers/net/phy/phy.c-{
drivers/net/phy/phy.c-}
drivers/net/phy/phy.c-}
drivers/net/phy/phy.c:	cancel_delayed_work_sync(&phydev->state_queue);
drivers/net/phy/phy.c:	cancel_delayed_work_sync(&phydev->state_queue);
drivers/net/phy/phy.c-			container_of(dwork, struct phy_device, state_queue);
drivers/net/phy/phy.c-	mutex_lock(&phydev->lock);
drivers/net/phy/phy.c-	phydev->adjust_state = handler;
drivers/net/phy/phy.c-		phy_error(phydev);
drivers/net/phy/phy.c-			PHY_STATE_TIME * HZ);
drivers/net/phy/phy.c-	/* reschedule state queue work to run as soon as possible */
drivers/net/phy/phy.c-	return;
drivers/net/phy/phy.c:	schedule_delayed_work(&phydev->state_queue,
drivers/net/phy/phy.c:	schedule_delayed_work(&phydev->state_queue, 0);
drivers/net/phy/phy.c:	schedule_delayed_work(&phydev->state_queue, HZ);
drivers/net/phy/phy.c:	struct delayed_work *dwork = to_delayed_work(work);
drivers/net/phy/phy.c-	struct phy_device *phydev =
drivers/net/phy/phy.c-void phy_state_machine(struct work_struct *work)
drivers/net/phy/phy.c-void phy_stop_machine(struct phy_device *phydev)
drivers/net/plip/plip.c-
drivers/net/plip/plip.c-
drivers/net/plip/plip.c-
drivers/net/plip/plip.c-}
drivers/net/plip/plip.c-	{
drivers/net/plip/plip.c-	}
drivers/net/plip/plip.c-	}
drivers/net/plip/plip.c-	}
drivers/net/plip/plip.c-	}
drivers/net/plip/plip.c-		atomic_set (&nl->kill_timer, 0);
drivers/net/plip/plip.c-	} else {
drivers/net/plip/plip.c-	else {
drivers/net/plip/plip.c-		ENABLE(dev->irq);
drivers/net/plip/plip.c-				ENABLE(dev->irq);
drivers/net/plip/plip.c-				enable_parport_interrupts (dev);
drivers/net/plip/plip.c-		enable_parport_interrupts (dev);
drivers/net/plip/plip.c-		nl->connection = PLIP_CN_CLOSING;
drivers/net/plip/plip.c-				nl->connection = PLIP_CN_SEND;
drivers/net/plip/plip.c-				nl->is_deferred = 1;
drivers/net/plip/plip.c-		nl->is_deferred = 1;
drivers/net/plip/plip.c-		nl->is_deferred = 1;
drivers/net/plip/plip.c-		nl->is_deferred = 1;
drivers/net/plip/plip.c-		plip_interrupt (nl->dev);
drivers/net/plip/plip.c-	    (r = plip_bh_timeout_error(nl->dev, nl, snd, rcv, r)) != OK) {
drivers/net/plip/plip.c:				schedule_delayed_work(&nl->deferred, 1);
drivers/net/plip/plip.c:		schedule_delayed_work(&nl->deferred, 1);
drivers/net/plip/plip.c:		schedule_delayed_work(&nl->deferred, 1);
drivers/net/plip/plip.c:		schedule_delayed_work(&nl->deferred, 1);
drivers/net/plip/plip.c:		schedule_delayed_work(&nl->timer, 1);
drivers/net/plip/plip.c:		schedule_delayed_work(&nl->timer, 1);
drivers/net/plip/plip.c:	struct delayed_work deferred;
drivers/net/plip/plip.c:	struct delayed_work timer;
drivers/net/plip/plip.c-	struct net_device *dev;
drivers/net/plip/plip.c-	struct plip_local rcv_data;
drivers/net/plip/plip.c-	struct plip_local snd_data;
drivers/net/plip/plip.c-	struct work_struct immediate;
drivers/net/usb/ipheth.c-
drivers/net/usb/ipheth.c-
drivers/net/usb/ipheth.c-
drivers/net/usb/ipheth.c-
drivers/net/usb/ipheth.c-
drivers/net/usb/ipheth.c-}
drivers/net/usb/ipheth.c-};
drivers/net/usb/ipheth.c:	cancel_delayed_work_sync(&dev->carrier_work);
drivers/net/usb/ipheth.c-	ipheth_carrier_set(dev);
drivers/net/usb/ipheth.c-	netif_start_queue(net);
drivers/net/usb/ipheth.c-	netif_stop_queue(net);
drivers/net/usb/ipheth.c-	return 0;
drivers/net/usb/ipheth.c-		return retval;
drivers/net/usb/ipheth.c-	return retval;
drivers/net/usb/ipheth.c:	schedule_delayed_work(&dev->carrier_work, IPHETH_CARRIER_CHECK_TIMEOUT);
drivers/net/usb/ipheth.c:	schedule_delayed_work(&dev->carrier_work, IPHETH_CARRIER_CHECK_TIMEOUT);
drivers/net/usb/ipheth.c:	struct delayed_work carrier_work;
drivers/net/usb/ipheth.c-	struct ipheth_device *dev = netdev_priv(net);
drivers/net/usb/ipheth.c-	u8 bulk_in;
drivers/net/usb/ipheth.c-	u8 bulk_out;
drivers/net/usb/kaweth.c-
drivers/net/usb/kaweth.c-
drivers/net/usb/kaweth.c-
drivers/net/usb/kaweth.c-		}
drivers/net/usb/kaweth.c-	/* a scheduled work may have resubmitted,
drivers/net/usb/kaweth.c:	cancel_delayed_work_sync(&kaweth->lowmem_work);
drivers/net/usb/kaweth.c-	} else {
drivers/net/usb/kaweth.c-		err("resubmitting rx_urb %d failed", result);
drivers/net/usb/kaweth.c-		if (result == -ENOMEM) {
drivers/net/usb/kaweth.c-	if (unlikely(status == -ENOMEM)) {
drivers/net/usb/kaweth.c-	int linkstate;
drivers/net/usb/kaweth.c-	int opened;
drivers/net/usb/kaweth.c-		kaweth->suspend_lowmem_ctrl = 0;
drivers/net/usb/kaweth.c-		kaweth->suspend_lowmem_ctrl = 1;
drivers/net/usb/kaweth.c-			kaweth->suspend_lowmem_rx = 1;
drivers/net/usb/kaweth.c:			schedule_delayed_work(&kaweth->lowmem_work, HZ/4);
drivers/net/usb/kaweth.c:		schedule_delayed_work(&kaweth->lowmem_work, HZ/4);
drivers/net/usb/kaweth.c:	struct delayed_work lowmem_work;
drivers/net/usb/kaweth.c-	struct usb_device *dev;
drivers/net/usb/kaweth.c-	usb_kill_urb(kaweth->tx_urb);
drivers/net/usb/pegasus.c-
drivers/net/usb/pegasus.c-
drivers/net/usb/pegasus.c-
drivers/net/usb/pegasus.c-	}
drivers/net/usb/pegasus.c-	}
drivers/net/usb/pegasus.c:	cancel_delayed_work(&pegasus->carrier_check);
drivers/net/usb/pegasus.c:	cancel_delayed_work(&pegasus->carrier_check);
drivers/net/usb/pegasus.c-			CARRIER_CHECK_DELAY);
drivers/net/usb/pegasus.c-				CARRIER_CHECK_DELAY);
drivers/net/usb/pegasus.c-				CARRIER_CHECK_DELAY);
drivers/net/usb/pegasus.c-		goto out3;
drivers/net/usb/pegasus.c-	if (netif_running(pegasus->net)) {
drivers/net/usb/pegasus.c-	if (!(pegasus->flags & PEGASUS_UNPLUG)) {
drivers/net/usb/pegasus.c-	if (res)
drivers/net/usb/pegasus.c-		intr_callback(pegasus->intr_urb);
drivers/net/usb/pegasus.c-	netif_device_detach(pegasus->net);
drivers/net/usb/pegasus.c-	pegasus->flags |= PEGASUS_UNPLUG;
drivers/net/usb/pegasus.c:		queue_delayed_work(pegasus_workqueue, &pegasus->carrier_check,
drivers/net/usb/pegasus.c:	queue_delayed_work(pegasus_workqueue, &pegasus->carrier_check,
drivers/net/usb/pegasus.c:	queue_delayed_work(pegasus_workqueue, &pegasus->carrier_check,
drivers/net/usb/pegasus.c-	return 0;
drivers/net/usb/pegasus.c-	set_carrier(pegasus->net);
drivers/net/usb/pegasus.c-	unregister_netdev(pegasus->net);
drivers/net/usb/pegasus.c-		usb_kill_urb(pegasus->rx_urb);
drivers/net/usb/pegasus.c-	usb_put_dev(interface_to_usbdev(intf));
drivers/net/virtio_net.c-
drivers/net/virtio_net.c-
drivers/net/virtio_net.c-
drivers/net/virtio_net.c-
drivers/net/virtio_net.c-
drivers/net/virtio_net.c-
drivers/net/virtio_net.c-
drivers/net/virtio_net.c-
drivers/net/virtio_net.c-
drivers/net/virtio_net.c-
drivers/net/virtio_net.c-
drivers/net/virtio_net.c-}
drivers/net/virtio_net.c-	}
drivers/net/virtio_net.c:	cancel_delayed_work_sync(&vi->refill);
drivers/net/virtio_net.c:	cancel_delayed_work_sync(&vi->refill);
drivers/net/virtio_net.c-	/* Chain pages by the private ptr. */
drivers/net/virtio_net.c-	if (netif_running(vi->dev))
drivers/net/virtio_net.c-	if (still_empty)
drivers/net/virtio_net.c-		if (!try_fill_recv(vi, GFP_ATOMIC))
drivers/net/virtio_net.c-	if (!try_fill_recv(vi, GFP_KERNEL))
drivers/net/virtio_net.c-	if (!try_fill_recv(vi, GFP_KERNEL))
drivers/net/virtio_net.c-	if (vi->num < vi->max / 2) {
drivers/net/virtio_net.c-	/* Make sure refill_work doesn't re-enable napi! */
drivers/net/virtio_net.c-	/* Make sure we have some buffers: if oom use wq. */
drivers/net/virtio_net.c-	napi_disable(&vi->napi);
drivers/net/virtio_net.c-	netif_device_detach(vi->dev);
drivers/net/virtio_net.c-	return 0;
drivers/net/virtio_net.c:			schedule_delayed_work(&vi->refill, 0);
drivers/net/virtio_net.c:		schedule_delayed_work(&vi->refill, 0);
drivers/net/virtio_net.c:		schedule_delayed_work(&vi->refill, 0);
drivers/net/virtio_net.c:		schedule_delayed_work(&vi->refill, HZ/2);
drivers/net/virtio_net.c:	struct delayed_work refill;
drivers/net/virtio_net.c-	virtnet_napi_enable(vi);
drivers/net/virtio_net.c-	 * we will *never* try to fill again. */
drivers/net/virtio_net.c-	/* Work struct for refilling if we run low on memory. */
drivers/net/wireless/at76c50x-usb.c-
drivers/net/wireless/at76c50x-usb.c-
drivers/net/wireless/at76c50x-usb.c-
drivers/net/wireless/at76c50x-usb.c-
drivers/net/wireless/at76c50x-usb.c-	}
drivers/net/wireless/at76c50x-usb.c-	at76_dbg(DBG_MAC80211, "%s()", __func__);
drivers/net/wireless/at76c50x-usb.c:	cancel_delayed_work(&priv->dwork_hw_scan);
drivers/net/wireless/at76c50x-usb.c-	cancel_work_sync(&priv->work_join_bssid);
drivers/net/wireless/at76c50x-usb.c-	cancel_work_sync(&priv->work_set_promisc);
drivers/net/wireless/at76c50x-usb.c:		ieee80211_queue_delayed_work(priv->hw, &priv->dwork_hw_scan,
drivers/net/wireless/at76c50x-usb.c:	ieee80211_queue_delayed_work(priv->hw, &priv->dwork_hw_scan,
drivers/net/wireless/at76c50x-usb.c-	if (ret != CMD_STATUS_COMPLETE) {
drivers/net/wireless/at76c50x-usb.c-		mutex_unlock(&priv->mtx);
drivers/net/wireless/at76c50x-usb.c-				     SCAN_POLL_INTERVAL);
drivers/net/wireless/at76c50x-usb.c-					     SCAN_POLL_INTERVAL);
drivers/net/wireless/ath/ath5k/base.c-
drivers/net/wireless/ath/ath5k/base.c-
drivers/net/wireless/ath/ath5k/base.c-
drivers/net/wireless/ath/ath5k/base.c-
drivers/net/wireless/ath/ath5k/base.c-
drivers/net/wireless/ath/ath5k/base.c-}
drivers/net/wireless/ath/ath5k/base.c-	ath5k_stop_tasklets(ah);
drivers/net/wireless/ath/ath5k/base.c:	cancel_delayed_work_sync(&ah->tx_complete_work);
drivers/net/wireless/ath/ath5k/base.c:	ieee80211_queue_delayed_work(ah->hw, &ah->tx_complete_work,
drivers/net/wireless/ath/ath5k/base.c:	ieee80211_queue_delayed_work(ah->hw, &ah->tx_complete_work,
drivers/net/wireless/ath/ath5k/base.c-	if (!ath5k_modparam_no_hw_rfkill_switch)
drivers/net/wireless/ath/ath5k/base.c-		msecs_to_jiffies(ATH5K_TX_COMPLETE_POLL_INT));
drivers/net/wireless/ath/ath5k/base.c-			msecs_to_jiffies(ATH5K_TX_COMPLETE_POLL_INT));
drivers/net/wireless/ath/ath5k/base.c-	mutex_unlock(&ah->lock);
drivers/net/wireless/ath/ath5k/base.c-	mutex_unlock(&ah->lock);
drivers/net/wireless/ath/ath9k/htc_drv_gpio.c-
drivers/net/wireless/ath/ath9k/htc_drv_gpio.c-
drivers/net/wireless/ath/ath9k/htc_drv_gpio.c-{
drivers/net/wireless/ath/ath9k/htc_drv_gpio.c-}
drivers/net/wireless/ath/ath9k/htc_drv_gpio.c-}
drivers/net/wireless/ath/ath9k/htc_drv_gpio.c-}
drivers/net/wireless/ath/ath9k/htc_drv_gpio.c-		btcoex->btcoex_no_stomp;
drivers/net/wireless/ath/ath9k/htc_drv_gpio.c-	btcoex->bt_priority_time = jiffies;
drivers/net/wireless/ath/ath9k/htc_drv_gpio.c:	cancel_delayed_work_sync(&priv->coex_period_work);
drivers/net/wireless/ath/ath9k/htc_drv_gpio.c:	cancel_delayed_work_sync(&priv->duty_cycle_work);
drivers/net/wireless/ath/ath9k/htc_drv_gpio.c:	ieee80211_queue_delayed_work(priv->hw, &priv->coex_period_work,
drivers/net/wireless/ath/ath9k/htc_drv_gpio.c:	ieee80211_queue_delayed_work(priv->hw, &priv->coex_period_work, 0);
drivers/net/wireless/ath/ath9k/htc_drv_gpio.c:	ieee80211_queue_delayed_work(priv->hw, &priv->duty_cycle_work,
drivers/net/wireless/ath/ath9k/htc_drv_gpio.c-				     msecs_to_jiffies(btcoex->btcoex_period));
drivers/net/wireless/ath/ath9k/htc_drv_gpio.c-				     msecs_to_jiffies(timer_period));
drivers/net/wireless/ath/ath9k/htc_drv_gpio.c-	priv->op_flags &= ~(OP_BT_PRIORITY_DETECTED | OP_BT_SCAN);
drivers/net/wireless/ath/ath9k/htc_drv_gpio.c-static void ath_htc_cancel_btcoex_work(struct ath9k_htc_priv *priv)
drivers/net/wireless/ath/ath9k/htc_drv_gpio.c-	timer_period = is_btscan ? btcoex->btscan_no_stomp :
drivers/net/wireless/ath/ath9k/htc_drv_main.c-
drivers/net/wireless/ath/ath9k/htc_drv_main.c-
drivers/net/wireless/ath/ath9k/htc_drv_main.c-{
drivers/net/wireless/ath/ath9k/htc_drv_main.c-}
drivers/net/wireless/ath/ath9k/htc_drv_main.c-}
drivers/net/wireless/ath/ath9k/htc_drv_main.c-}
drivers/net/wireless/ath/ath9k/htc_drv_main.c-		cal_interval = min(cal_interval, (u32)short_cal_interval);
drivers/net/wireless/ath/ath9k/htc_drv_main.c:	cancel_delayed_work_sync(&priv->ani_work);
drivers/net/wireless/ath/ath9k/htc_drv_main.c:	ieee80211_queue_delayed_work(common->hw, &priv->ani_work,
drivers/net/wireless/ath/ath9k/htc_drv_main.c:	ieee80211_queue_delayed_work(common->hw, &priv->ani_work,
drivers/net/wireless/ath/ath9k/htc_drv_main.c-				     msecs_to_jiffies(ATH_ANI_POLLINTERVAL));
drivers/net/wireless/ath/ath9k/htc_drv_main.c-				     msecs_to_jiffies(cal_interval));
drivers/net/wireless/ath/ath9k/htc_drv_main.c-	priv->op_flags |= OP_ANI_RUNNING;
drivers/net/wireless/ath/ath9k/htc_drv_main.c-	priv->op_flags &= ~OP_ANI_RUNNING;
drivers/net/wireless/ath/ath9k/htc_drv_main.c-void ath9k_htc_stop_ani(struct ath9k_htc_priv *priv)
drivers/net/wireless/ath/ath9k/main.c-
drivers/net/wireless/ath/ath9k/main.c-
drivers/net/wireless/ath/ath9k/main.c-
drivers/net/wireless/ath/ath9k/main.c-
drivers/net/wireless/ath/ath9k/main.c-
drivers/net/wireless/ath/ath9k/main.c-
drivers/net/wireless/ath/ath9k/main.c-}
drivers/net/wireless/ath/ath9k/main.c-}
drivers/net/wireless/ath/ath9k/main.c-}
drivers/net/wireless/ath/ath9k/main.c-	}
drivers/net/wireless/ath/ath9k/main.c-	}
drivers/net/wireless/ath/ath9k/main.c-		ath_hw_pll_rx_hang_check(sc, pll_sqsum);
drivers/net/wireless/ath/ath9k/main.c-			ath_set_beacon(sc);
drivers/net/wireless/ath/ath9k/main.c-			ath_start_ani(common);
drivers/net/wireless/ath/ath9k/main.c:	cancel_delayed_work_sync(&sc->hw_pll_work);
drivers/net/wireless/ath/ath9k/main.c:	cancel_delayed_work_sync(&sc->tx_complete_work);
drivers/net/wireless/ath/ath9k/main.c:	cancel_delayed_work_sync(&sc->tx_complete_work);
drivers/net/wireless/ath/ath9k/main.c-	cancel_work_sync(&sc->hw_check_work);
drivers/net/wireless/ath/ath9k/main.c-	cancel_work_sync(&sc->paprd_work);
drivers/net/wireless/ath/ath9k/main.c:	ieee80211_queue_delayed_work(hw, &sc->tx_complete_work, 0);
drivers/net/wireless/ath/ath9k/main.c:		ieee80211_queue_delayed_work(sc->hw, &sc->hw_pll_work, HZ/2);
drivers/net/wireless/ath/ath9k/main.c:		ieee80211_queue_delayed_work(sc->hw, &sc->hw_pll_work, HZ/5);
drivers/net/wireless/ath/ath9k/main.c:		ieee80211_queue_delayed_work(sc->hw, &sc->tx_complete_work, 0);
drivers/net/wireless/ath/ath9k/main.c-	if (ah->ah_flags & AH_UNPLUGGED) {
drivers/net/wireless/ath/ath9k/main.c-		if (!common->disable_ani)
drivers/net/wireless/ath/ath9k/main.c-	mutex_lock(&sc->mutex);
drivers/net/wireless/ath/ath9k/main.c-	mutex_unlock(&sc->mutex);
drivers/net/wireless/ath/ath9k/xmit.c-
drivers/net/wireless/ath/ath9k/xmit.c-}
drivers/net/wireless/ath/ath9k/xmit.c-	}
drivers/net/wireless/ath/ath9k/xmit.c:	ieee80211_queue_delayed_work(sc->hw, &sc->tx_complete_work,
drivers/net/wireless/ath/ath9k/xmit.c-			msecs_to_jiffies(ATH_TX_COMPLETE_POLL_INT));
drivers/net/wireless/ath/carl9170/led.c-
drivers/net/wireless/ath/carl9170/led.c-
drivers/net/wireless/ath/carl9170/led.c-
drivers/net/wireless/ath/carl9170/led.c-
drivers/net/wireless/ath/carl9170/led.c-
drivers/net/wireless/ath/carl9170/led.c-}
drivers/net/wireless/ath/carl9170/led.c-}
drivers/net/wireless/ath/carl9170/led.c-		}
drivers/net/wireless/ath/carl9170/led.c-				     &ar->led_work,
drivers/net/wireless/ath/carl9170/led.c:	cancel_delayed_work_sync(&ar->led_work);
drivers/net/wireless/ath/carl9170/led.c:	ieee80211_queue_delayed_work(ar->hw,
drivers/net/wireless/ath/carl9170/led.c:		ieee80211_queue_delayed_work(ar->hw, &ar->led_work, HZ / 10);
drivers/net/wireless/ath/carl9170/led.c-	if (likely(IS_ACCEPTING_CMD(ar) && arl->toggled))
drivers/net/wireless/ath/carl9170/led.c-				     msecs_to_jiffies(blink_delay));
drivers/net/wireless/ath/carl9170/led.c-		return;
drivers/net/wireless/ath/carl9170/main.c-
drivers/net/wireless/ath/carl9170/main.c-
drivers/net/wireless/ath/carl9170/main.c-
drivers/net/wireless/ath/carl9170/main.c-{
drivers/net/wireless/ath/carl9170/main.c-}
drivers/net/wireless/ath/carl9170/main.c:	cancel_delayed_work_sync(&ar->led_work);
drivers/net/wireless/ath/carl9170/main.c:	cancel_delayed_work_sync(&ar->stat_work);
drivers/net/wireless/ath/carl9170/main.c:	cancel_delayed_work_sync(&ar->tx_janitor);
drivers/net/wireless/ath/carl9170/main.c-	cancel_work_sync(&ar->ps_work);
drivers/net/wireless/ath/carl9170/main.c-	carl9170_set_state_when(ar, CARL9170_IDLE, CARL9170_STARTED);
drivers/net/wireless/ath/carl9170/main.c-#endif /* CONFIG_CARL9170_LEDS */
drivers/net/wireless/ath/carl9170/main.c:	ieee80211_queue_delayed_work(ar->hw, &ar->stat_work,
drivers/net/wireless/ath/carl9170/main.c:	ieee80211_queue_delayed_work(ar->hw, &ar->stat_work,
drivers/net/wireless/ath/carl9170/main.c-#ifdef CONFIG_CARL9170_LEDS
drivers/net/wireless/ath/carl9170/main.c-		return;
drivers/net/wireless/ath/carl9170/main.c-		round_jiffies(msecs_to_jiffies(CARL9170_STAT_WORK)));
drivers/net/wireless/ath/carl9170/main.c-		round_jiffies(msecs_to_jiffies(CARL9170_STAT_WORK)));
drivers/net/wireless/ath/carl9170/main.c-static void carl9170_cancel_worker(struct ar9170 *ar)
drivers/net/wireless/ath/carl9170/tx.c-
drivers/net/wireless/ath/carl9170/tx.c-
drivers/net/wireless/ath/carl9170/tx.c-}
drivers/net/wireless/ath/carl9170/tx.c-}
drivers/net/wireless/ath/carl9170/tx.c:	ieee80211_queue_delayed_work(ar->hw, &ar->tx_janitor,
drivers/net/wireless/ath/carl9170/tx.c:	ieee80211_queue_delayed_work(ar->hw, &ar->tx_janitor,
drivers/net/wireless/ath/carl9170/tx.c-		msecs_to_jiffies(CARL9170_TX_TIMEOUT));
drivers/net/wireless/ath/carl9170/tx.c-		msecs_to_jiffies(CARL9170_TX_TIMEOUT));
drivers/net/wireless/ath/carl9170/tx.c-		return;
drivers/net/wireless/ath/carl9170/tx.c-		return;
drivers/net/wireless/b43legacy/main.c-
drivers/net/wireless/b43legacy/main.c-
drivers/net/wireless/b43legacy/main.c-{
drivers/net/wireless/b43legacy/main.c-}
drivers/net/wireless/b43legacy/main.c:	cancel_delayed_work_sync(&dev->periodic_work);
drivers/net/wireless/b43legacy/main.c-	 * Cancel the possibly running self-rearming periodic work. */
drivers/net/wireless/b43legacy/main.c-	cancel_work_sync(&wl->tx_work);
drivers/net/wireless/b43legacy/main.c-		delay = round_jiffies_relative(HZ * 15);
drivers/net/wireless/b43legacy/main.c-	dev->periodic_state = 0;
drivers/net/wireless/b43legacy/main.c-	else
drivers/net/wireless/b43legacy/main.c:	ieee80211_queue_delayed_work(dev->wl->hw, work, 0);
drivers/net/wireless/b43legacy/main.c:	ieee80211_queue_delayed_work(wl->hw, &dev->periodic_work, delay);
drivers/net/wireless/b43legacy/main.c-	INIT_DELAYED_WORK(work, b43legacy_periodic_work_handler);
drivers/net/wireless/b43legacy/main.c-	/* Must unlock as it would otherwise deadlock. No races here.
drivers/net/wireless/b43legacy/main.c-	mutex_lock(&wl->mutex);
drivers/net/wireless/b43legacy/main.c-	mutex_unlock(&wl->mutex);
drivers/net/wireless/b43legacy/main.c-out:
drivers/net/wireless/b43legacy/main.c-static void b43legacy_periodic_tasks_setup(struct b43legacy_wldev *dev)
drivers/net/wireless/b43legacy/main.c:	struct delayed_work *work = &dev->periodic_work;
drivers/net/wireless/b43/main.c-
drivers/net/wireless/b43/main.c-
drivers/net/wireless/b43/main.c-{
drivers/net/wireless/b43/main.c-}
drivers/net/wireless/b43/main.c:	cancel_delayed_work_sync(&dev->periodic_work);
drivers/net/wireless/b43/main.c-	cancel_work_sync(&wl->firmware_load);
drivers/net/wireless/b43/main.c-	cancel_work_sync(&wl->tx_work);
drivers/net/wireless/b43/main.c-	/* Cancel work. Unlock to avoid deadlocks. */
drivers/net/wireless/b43/main.c-		delay = round_jiffies_relative(HZ * 15);
drivers/net/wireless/b43/main.c-	dev->periodic_state = 0;
drivers/net/wireless/b43/main.c-	else
drivers/net/wireless/b43/main.c:	ieee80211_queue_delayed_work(dev->wl->hw, work, 0);
drivers/net/wireless/b43/main.c:	ieee80211_queue_delayed_work(wl->hw, &dev->periodic_work, delay);
drivers/net/wireless/b43/main.c-	INIT_DELAYED_WORK(work, b43_periodic_work_handler);
drivers/net/wireless/b43/main.c-	mutex_unlock(&wl->mutex);
drivers/net/wireless/b43/main.c-	mutex_unlock(&wl->mutex);
drivers/net/wireless/b43/main.c-out:
drivers/net/wireless/b43/main.c-static void b43_periodic_tasks_setup(struct b43_wldev *dev)
drivers/net/wireless/b43/main.c:	struct delayed_work *work = &dev->periodic_work;
drivers/net/wireless/bcmdhd/wl_cfg80211.c:					cancel_delayed_work_sync(&cfg->pm_enable_work);
drivers/net/wireless/bcmdhd/wl_cfg80211.c-				case WL_HANDLER_DEL:
drivers/net/wireless/bcmdhd/wl_cfg80211.c-					cfg->pm_enable_work_on = false;
drivers/net/wireless/bcmdhd/wl_cfg80211.c-				default:
drivers/net/wireless/bcmdhd/wl_cfg80211.c-			DHD_OS_WAKE_LOCK(cfg->pub);
drivers/net/wireless/bcmdhd/wl_cfg80211.c-		} else {
drivers/net/wireless/bcmdhd/wl_cfg80211.c-#endif /* CUSTOMER_HW4 */
drivers/net/wireless/bcmdhd/wl_cfg80211.c-#ifdef CUSTOMER_HW4
drivers/net/wireless/bcmdhd/wl_cfg80211.c-				msecs_to_jiffies(WL_PM_ENABLE_TIMEOUT));
drivers/net/wireless/bcmdhd/wl_cfg80211.c:			schedule_delayed_work(&cfg->pm_enable_work,
drivers/net/wireless/brcm80211/brcmsmac/mac80211_if.c-
drivers/net/wireless/brcm80211/brcmsmac/mac80211_if.c-
drivers/net/wireless/brcm80211/brcmsmac/mac80211_if.c-
drivers/net/wireless/brcm80211/brcmsmac/mac80211_if.c-}
drivers/net/wireless/brcm80211/brcmsmac/mac80211_if.c-	}
drivers/net/wireless/brcm80211/brcmsmac/mac80211_if.c-			atomic_inc(&t->wl->callbacks);
drivers/net/wireless/brcm80211/brcmsmac/mac80211_if.c:	ieee80211_queue_delayed_work(hw, &t->dly_wrk, msecs_to_jiffies(ms));
drivers/net/wireless/brcm80211/brcmsmac/mac80211_if.c:			ieee80211_queue_delayed_work(t->wl->pub->ieee_hw,
drivers/net/wireless/brcm80211/brcmsmac/mac80211_if.c:		if (!cancel_delayed_work(&t->dly_wrk))
drivers/net/wireless/brcm80211/brcmsmac/mac80211_if.c-		if (t->periodic) {
drivers/net/wireless/brcm80211/brcmsmac/mac80211_if.c-	if (t->set) {
drivers/net/wireless/brcm80211/brcmsmac/mac80211_if.c-						     msecs_to_jiffies(t->ms));
drivers/net/wireless/brcm80211/brcmsmac/mac80211_if.c-			return false;
drivers/net/wireless/brcm80211/brcmsmac/mac80211_if.c-						     &t->dly_wrk,
drivers/net/wireless/brcm80211/brcmsmac/mac80211_if.c-		t->set = false;
drivers/net/wireless/ipw2x00/ipw2100.c-
drivers/net/wireless/ipw2x00/ipw2100.c-
drivers/net/wireless/ipw2x00/ipw2100.c-
drivers/net/wireless/ipw2x00/ipw2100.c-
drivers/net/wireless/ipw2x00/ipw2100.c-
drivers/net/wireless/ipw2x00/ipw2100.c-
drivers/net/wireless/ipw2x00/ipw2100.c-
drivers/net/wireless/ipw2x00/ipw2100.c-
drivers/net/wireless/ipw2x00/ipw2100.c-
drivers/net/wireless/ipw2x00/ipw2100.c-
drivers/net/wireless/ipw2x00/ipw2100.c-
drivers/net/wireless/ipw2x00/ipw2100.c-
drivers/net/wireless/ipw2x00/ipw2100.c-
drivers/net/wireless/ipw2x00/ipw2100.c-
drivers/net/wireless/ipw2x00/ipw2100.c-
drivers/net/wireless/ipw2x00/ipw2100.c-
drivers/net/wireless/ipw2x00/ipw2100.c-}
drivers/net/wireless/ipw2x00/ipw2100.c-}
drivers/net/wireless/ipw2x00/ipw2100.c-}
drivers/net/wireless/ipw2x00/ipw2100.c-}
drivers/net/wireless/ipw2x00/ipw2100.c-	}
drivers/net/wireless/ipw2x00/ipw2100.c-	}
drivers/net/wireless/ipw2x00/ipw2100.c-	}
drivers/net/wireless/ipw2x00/ipw2100.c-	}
drivers/net/wireless/ipw2x00/ipw2100.c-	}
drivers/net/wireless/ipw2x00/ipw2100.c-		}
drivers/net/wireless/ipw2x00/ipw2100.c:	cancel_delayed_work(&priv->hang_check);
drivers/net/wireless/ipw2x00/ipw2100.c:		cancel_delayed_work(&priv->hang_check);
drivers/net/wireless/ipw2x00/ipw2100.c:		cancel_delayed_work(&priv->hang_check);
drivers/net/wireless/ipw2x00/ipw2100.c:	cancel_delayed_work(&priv->reset_work);
drivers/net/wireless/ipw2x00/ipw2100.c:		cancel_delayed_work(&priv->reset_work);
drivers/net/wireless/ipw2x00/ipw2100.c:		cancel_delayed_work(&priv->rf_kill);
drivers/net/wireless/ipw2x00/ipw2100.c:		cancel_delayed_work(&priv->scan_event_later);
drivers/net/wireless/ipw2x00/ipw2100.c:	cancel_delayed_work_sync(&priv->hang_check);
drivers/net/wireless/ipw2x00/ipw2100.c:	cancel_delayed_work_sync(&priv->reset_work);
drivers/net/wireless/ipw2x00/ipw2100.c:	cancel_delayed_work_sync(&priv->rf_kill);
drivers/net/wireless/ipw2x00/ipw2100.c:	cancel_delayed_work_sync(&priv->scan_event_later);
drivers/net/wireless/ipw2x00/ipw2100.c:	cancel_delayed_work_sync(&priv->security_work);
drivers/net/wireless/ipw2x00/ipw2100.c:	cancel_delayed_work_sync(&priv->wx_event_work);
drivers/net/wireless/ipw2x00/ipw2100.c-	cancel_work_sync(&priv->scan_event_now);
drivers/net/wireless/ipw2x00/ipw2100.c-	} else {
drivers/net/wireless/ipw2x00/ipw2100.c-		else
drivers/net/wireless/ipw2x00/ipw2100.c-		} else
drivers/net/wireless/ipw2x00/ipw2100.c-	/* Force a power cycle even if interface hasn't been opened
drivers/net/wireless/ipw2x00/ipw2100.c-		goto exit_unlock;
drivers/net/wireless/ipw2x00/ipw2100.c:		if (!delayed_work_pending(&priv->scan_event_later))
drivers/net/wireless/ipw2x00/ipw2100.c-		if (priv->reset_backoff)
drivers/net/wireless/ipw2x00/ipw2100.c-		if (priv->reset_backoff < MAX_RESET_BACKOFF)
drivers/net/wireless/ipw2x00/ipw2100.c-	if (priv->status & STATUS_RESET_PENDING)
drivers/net/wireless/ipw2x00/ipw2100.c-	if (priv->status & STATUS_SECURITY_UPDATED)
drivers/net/wireless/ipw2x00/ipw2100.c-	if (!priv->stop_hang_check)
drivers/net/wireless/ipw2x00/ipw2100.c-	if (!priv->stop_hang_check) {
drivers/net/wireless/ipw2x00/ipw2100.c-	if (!priv->stop_hang_check) {
drivers/net/wireless/ipw2x00/ipw2100.c-	if (priv->stop_hang_check) {
drivers/net/wireless/ipw2x00/ipw2100.c-		if (!priv->stop_rf_kill)
drivers/net/wireless/ipw2x00/ipw2100.c-		if (priv->stop_rf_kill) {
drivers/net/wireless/ipw2x00/ipw2100.c-	if (!priv->stop_rf_kill) {
drivers/net/wireless/ipw2x00/ipw2100.c-	if (!priv->user_requested_scan) {
drivers/net/wireless/ipw2x00/ipw2100.c-		IPW_DEBUG_RF_KILL("RF Kill active, rescheduling GPIO check\n");
drivers/net/wireless/ipw2x00/ipw2100.c-	/* Kill any pending resets */
drivers/net/wireless/ipw2x00/ipw2100.c-	/* Make sure the interrupt is on so that FW commands will be
drivers/net/wireless/ipw2x00/ipw2100.c-			/* Make sure the RF_KILL check timer is running */
drivers/net/wireless/ipw2x00/ipw2100.c-	/* Make sure the RF Kill check timer is running */
drivers/net/wireless/ipw2x00/ipw2100.c:			mod_delayed_work(system_wq, &priv->rf_kill,
drivers/net/wireless/ipw2x00/ipw2100.c:	mod_delayed_work(system_wq, &priv->rf_kill, round_jiffies_relative(HZ));
drivers/net/wireless/ipw2x00/ipw2100.c-	/* Only userspace-requested scan completion events go out immediately */
drivers/net/wireless/ipw2x00/ipw2100.c-	priv->connect_start = get_seconds();
drivers/net/wireless/ipw2x00/ipw2100.c-					      priv->reset_backoff * HZ);
drivers/net/wireless/ipw2x00/ipw2100.c-		priv->status |= STATUS_RESET_PENDING;
drivers/net/wireless/ipw2x00/ipw2100.c-	priv->status |= STATUS_RESET_PENDING;
drivers/net/wireless/ipw2x00/ipw2100.c-		priv->stop_hang_check = 0;
drivers/net/wireless/ipw2x00/ipw2100.c-		priv->stop_hang_check = 1;
drivers/net/wireless/ipw2x00/ipw2100.c-		priv->stop_hang_check = 1;
drivers/net/wireless/ipw2x00/ipw2100.c-	priv->stop_hang_check = 1;
drivers/net/wireless/ipw2x00/ipw2100.c-	priv->stop_hang_check = 1;
drivers/net/wireless/ipw2x00/ipw2100.c-			priv->stop_rf_kill = 0;
drivers/net/wireless/ipw2x00/ipw2100.c-			priv->stop_rf_kill = 0;
drivers/net/wireless/ipw2x00/ipw2100.c-	priv->stop_rf_kill = 0;
drivers/net/wireless/ipw2x00/ipw2100.c-		priv->stop_rf_kill = 1;
drivers/net/wireless/ipw2x00/ipw2100.c-	priv->stop_rf_kill = 1;
drivers/net/wireless/ipw2x00/ipw2100.c-		priv->user_requested_scan = 0;
drivers/net/wireless/ipw2x00/ipw2100.c-					 round_jiffies_relative(HZ));
drivers/net/wireless/ipw2x00/ipw2100.c-					      round_jiffies_relative(HZ));
drivers/net/wireless/ipw2x00/ipw2100.c-					      round_jiffies_relative(HZ));
drivers/net/wireless/ipw2x00/ipw2100.c-					      round_jiffies_relative(msecs_to_jiffies(4000)));
drivers/net/wireless/ipw2x00/ipw2100.c:		schedule_delayed_work(&priv->hang_check, HZ / 2);
drivers/net/wireless/ipw2x00/ipw2100.c:		schedule_delayed_work(&priv->hang_check, HZ / 2);
drivers/net/wireless/ipw2x00/ipw2100.c:			schedule_delayed_work(&priv->reset_work,
drivers/net/wireless/ipw2x00/ipw2100.c:			schedule_delayed_work(&priv->reset_work, 0);
drivers/net/wireless/ipw2x00/ipw2100.c:			schedule_delayed_work(&priv->rf_kill,
drivers/net/wireless/ipw2x00/ipw2100.c:			schedule_delayed_work(&priv->rf_kill,
drivers/net/wireless/ipw2x00/ipw2100.c:			schedule_delayed_work(&priv->scan_event_later,
drivers/net/wireless/ipw2x00/ipw2100.c:		schedule_delayed_work(&priv->security_work, 0);
drivers/net/wireless/ipw2x00/ipw2100.c:	schedule_delayed_work(&priv->wx_event_work, 0);
drivers/net/wireless/ipw2x00/ipw2100.c:	schedule_delayed_work(&priv->wx_event_work, HZ / 10);
drivers/net/wireless/ipw2x00/ipw2100.c-		schedule_work(&priv->scan_event_now);
drivers/net/wireless/ipw2x00/ipw2100.c-	spin_unlock_irqrestore(&priv->low_lock, flags);
drivers/net/wireless/ipw2x00/ipw2100.c-	spin_unlock_irqrestore(&priv->low_lock, flags);
drivers/net/wireless/ipw2x00/ipw2100.c-	/* stop timed checks so that they don't interfere with reset */
drivers/net/wireless/ipw2x00/ipw2100.c-	/* We have to signal any supplicant if we are disassociating */
drivers/net/wireless/ipw2x00/ipw2100.c-	 * yet */
drivers/net/wireless/ipw2x00/ipw2200.c-
drivers/net/wireless/ipw2x00/ipw2200.c-
drivers/net/wireless/ipw2x00/ipw2200.c-
drivers/net/wireless/ipw2x00/ipw2200.c-
drivers/net/wireless/ipw2x00/ipw2200.c-
drivers/net/wireless/ipw2x00/ipw2200.c-
drivers/net/wireless/ipw2x00/ipw2200.c-
drivers/net/wireless/ipw2x00/ipw2200.c-
drivers/net/wireless/ipw2x00/ipw2200.c-
drivers/net/wireless/ipw2x00/ipw2200.c-
drivers/net/wireless/ipw2x00/ipw2200.c-
drivers/net/wireless/ipw2x00/ipw2200.c-
drivers/net/wireless/ipw2x00/ipw2200.c-
drivers/net/wireless/ipw2x00/ipw2200.c-
drivers/net/wireless/ipw2x00/ipw2200.c-
drivers/net/wireless/ipw2x00/ipw2200.c-
drivers/net/wireless/ipw2x00/ipw2200.c-
drivers/net/wireless/ipw2x00/ipw2200.c-
drivers/net/wireless/ipw2x00/ipw2200.c-
drivers/net/wireless/ipw2x00/ipw2200.c-
drivers/net/wireless/ipw2x00/ipw2200.c-
drivers/net/wireless/ipw2x00/ipw2200.c-
drivers/net/wireless/ipw2x00/ipw2200.c-
drivers/net/wireless/ipw2x00/ipw2200.c-
drivers/net/wireless/ipw2x00/ipw2200.c-
drivers/net/wireless/ipw2x00/ipw2200.c-
drivers/net/wireless/ipw2x00/ipw2200.c-
drivers/net/wireless/ipw2x00/ipw2200.c-}
drivers/net/wireless/ipw2x00/ipw2200.c-}
drivers/net/wireless/ipw2x00/ipw2200.c-}
drivers/net/wireless/ipw2x00/ipw2200.c-}
drivers/net/wireless/ipw2x00/ipw2200.c-}
drivers/net/wireless/ipw2x00/ipw2200.c-}
drivers/net/wireless/ipw2x00/ipw2200.c-}
drivers/net/wireless/ipw2x00/ipw2200.c-	}
drivers/net/wireless/ipw2x00/ipw2200.c-	}
drivers/net/wireless/ipw2x00/ipw2200.c-	}
drivers/net/wireless/ipw2x00/ipw2200.c-	}
drivers/net/wireless/ipw2x00/ipw2200.c-	}
drivers/net/wireless/ipw2x00/ipw2200.c-	}
drivers/net/wireless/ipw2x00/ipw2200.c-		}
drivers/net/wireless/ipw2x00/ipw2200.c-		}
drivers/net/wireless/ipw2x00/ipw2200.c-		}
drivers/net/wireless/ipw2x00/ipw2200.c-			}
drivers/net/wireless/ipw2x00/ipw2200.c-				break;
drivers/net/wireless/ipw2x00/ipw2200.c-	/* Cancel any queued work ... */
drivers/net/wireless/ipw2x00/ipw2200.c:	cancel_delayed_work(&priv->adhoc_check);
drivers/net/wireless/ipw2x00/ipw2200.c:	cancel_delayed_work(&priv->gather_stats);
drivers/net/wireless/ipw2x00/ipw2200.c:	cancel_delayed_work(&priv->led_act_off);
drivers/net/wireless/ipw2x00/ipw2200.c:		cancel_delayed_work(&priv->led_act_off);
drivers/net/wireless/ipw2x00/ipw2200.c:		cancel_delayed_work(&priv->led_act_off);
drivers/net/wireless/ipw2x00/ipw2200.c:	cancel_delayed_work(&priv->led_link_off);
drivers/net/wireless/ipw2x00/ipw2200.c:	cancel_delayed_work(&priv->led_link_on);
drivers/net/wireless/ipw2x00/ipw2200.c:	cancel_delayed_work(&priv->request_direct_scan);
drivers/net/wireless/ipw2x00/ipw2200.c:	cancel_delayed_work(&priv->request_direct_scan);
drivers/net/wireless/ipw2x00/ipw2200.c:		cancel_delayed_work(&priv->request_direct_scan);
drivers/net/wireless/ipw2x00/ipw2200.c:		cancel_delayed_work(&priv->request_direct_scan);
drivers/net/wireless/ipw2x00/ipw2200.c:	cancel_delayed_work(&priv->request_passive_scan);
drivers/net/wireless/ipw2x00/ipw2200.c:	cancel_delayed_work(&priv->request_passive_scan);
drivers/net/wireless/ipw2x00/ipw2200.c:		cancel_delayed_work(&priv->request_passive_scan);
drivers/net/wireless/ipw2x00/ipw2200.c:		cancel_delayed_work(&priv->request_passive_scan);
drivers/net/wireless/ipw2x00/ipw2200.c:	cancel_delayed_work(&priv->request_scan);
drivers/net/wireless/ipw2x00/ipw2200.c:	cancel_delayed_work(&priv->request_scan);
drivers/net/wireless/ipw2x00/ipw2200.c:		cancel_delayed_work(&priv->request_scan);
drivers/net/wireless/ipw2x00/ipw2200.c:		cancel_delayed_work(&priv->request_scan);
drivers/net/wireless/ipw2x00/ipw2200.c:			cancel_delayed_work(&priv->rf_kill);
drivers/net/wireless/ipw2x00/ipw2200.c:			cancel_delayed_work(&priv->scan_check);
drivers/net/wireless/ipw2x00/ipw2200.c:	cancel_delayed_work(&priv->scan_event);
drivers/net/wireless/ipw2x00/ipw2200.c:		cancel_delayed_work(&priv->scan_event);
drivers/net/wireless/ipw2x00/ipw2200.c:		cancel_delayed_work(&priv->scan_event);
drivers/net/wireless/ipw2x00/ipw2200.c:		cancel_delayed_work(&priv->scan_event);
drivers/net/wireless/ipw2x00/ipw2200.c:		cancel_delayed_work(&priv->scan_event);
drivers/net/wireless/ipw2x00/ipw2200.c:	cancel_delayed_work_sync(&priv->adhoc_check);
drivers/net/wireless/ipw2x00/ipw2200.c:	cancel_delayed_work_sync(&priv->gather_stats);
drivers/net/wireless/ipw2x00/ipw2200.c:	cancel_delayed_work_sync(&priv->led_act_off);
drivers/net/wireless/ipw2x00/ipw2200.c:	cancel_delayed_work_sync(&priv->led_link_off);
drivers/net/wireless/ipw2x00/ipw2200.c:	cancel_delayed_work_sync(&priv->led_link_on);
drivers/net/wireless/ipw2x00/ipw2200.c:	cancel_delayed_work_sync(&priv->request_direct_scan);
drivers/net/wireless/ipw2x00/ipw2200.c:	cancel_delayed_work_sync(&priv->request_passive_scan);
drivers/net/wireless/ipw2x00/ipw2200.c:	cancel_delayed_work_sync(&priv->request_scan);
drivers/net/wireless/ipw2x00/ipw2200.c:	cancel_delayed_work_sync(&priv->rf_kill);
drivers/net/wireless/ipw2x00/ipw2200.c:	cancel_delayed_work_sync(&priv->scan_check);
drivers/net/wireless/ipw2x00/ipw2200.c:	cancel_delayed_work_sync(&priv->scan_event);
drivers/net/wireless/ipw2x00/ipw2200.c-	cancel_work_sync(&priv->abort_scan);
drivers/net/wireless/ipw2x00/ipw2200.c-	cancel_work_sync(&priv->adapter_restart);
drivers/net/wireless/ipw2x00/ipw2200.c-	cancel_work_sync(&priv->associate);
drivers/net/wireless/ipw2x00/ipw2200.c-	cancel_work_sync(&priv->disassociate);
drivers/net/wireless/ipw2x00/ipw2200.c-	cancel_work_sync(&priv->down);
drivers/net/wireless/ipw2x00/ipw2200.c-	cancel_work_sync(&priv->link_down);
drivers/net/wireless/ipw2x00/ipw2200.c-	cancel_work_sync(&priv->link_up);
drivers/net/wireless/ipw2x00/ipw2200.c-	cancel_work_sync(&priv->merge_networks);
drivers/net/wireless/ipw2x00/ipw2200.c-	cancel_work_sync(&priv->roam);
drivers/net/wireless/ipw2x00/ipw2200.c-	cancel_work_sync(&priv->rx_replenish);
drivers/net/wireless/ipw2x00/ipw2200.c-	cancel_work_sync(&priv->up);
drivers/net/wireless/ipw2x00/ipw2200.c-					  "disabled by HW switch\n");
drivers/net/wireless/ipw2x00/ipw2200.c-done:
drivers/net/wireless/ipw2x00/ipw2200.c-			/* Do queued direct scans first */
drivers/net/wireless/ipw2x00/ipw2200.c-	} else
drivers/net/wireless/ipw2x00/ipw2200.c-	} else {
drivers/net/wireless/ipw2x00/ipw2200.c-	} else {
drivers/net/wireless/ipw2x00/ipw2200.c-	} else {
drivers/net/wireless/ipw2x00/ipw2200.c-		} else
drivers/net/wireless/ipw2x00/ipw2200.c-			else
drivers/net/wireless/ipw2x00/ipw2200.c-			else if (priv->config & CFG_BACKGROUND_SCAN
drivers/net/wireless/ipw2x00/ipw2200.c-			} else if (priv->status & STATUS_SCAN_PENDING)
drivers/net/wireless/ipw2x00/ipw2200.c-	/* Ensure the rate is updated immediately */
drivers/net/wireless/ipw2x00/ipw2200.c-		goto exit_unlock;
drivers/net/wireless/ipw2x00/ipw2200.c-		handled |= IPW_INTA_BIT_RF_KILL_DONE;
drivers/net/wireless/ipw2x00/ipw2200.c-			/* If configure to try and auto-associate, kick
drivers/net/wireless/ipw2x00/ipw2200.c:		if (!delayed_work_pending(&priv->scan_event))
drivers/net/wireless/ipw2x00/ipw2200.c-	if (priv->config & CFG_BACKGROUND_SCAN)
drivers/net/wireless/ipw2x00/ipw2200.c-			if (!(priv->config & CFG_SPEED_SCAN))
drivers/net/wireless/ipw2x00/ipw2200.c-			if (priv->ieee->iw_mode == IW_MODE_MONITOR) {
drivers/net/wireless/ipw2x00/ipw2200.c-			if (!(priv->status & (STATUS_ASSOCIATED |
drivers/net/wireless/ipw2x00/ipw2200.c-		if (!(priv->status & STATUS_ASSOCIATED))
drivers/net/wireless/ipw2x00/ipw2200.c-			if (priv->status & STATUS_DIRECT_SCAN_PENDING)
drivers/net/wireless/ipw2x00/ipw2200.c-			if (priv->status & STATUS_EXIT_PENDING)
drivers/net/wireless/ipw2x00/ipw2200.c-	if (!(priv->status & STATUS_EXIT_PENDING)) {
drivers/net/wireless/ipw2x00/ipw2200.c-		if (!(priv->status & STATUS_RF_KILL_MASK) &&
drivers/net/wireless/ipw2x00/ipw2200.c-			if (!(priv->status & STATUS_SCANNING))
drivers/net/wireless/ipw2x00/ipw2200.c-		if (!(priv->status & STATUS_SCANNING)) {
drivers/net/wireless/ipw2x00/ipw2200.c-	if (!priv->user_requested_scan) {
drivers/net/wireless/ipw2x00/ipw2200.c-	if (rf_kill_active(priv)) {
drivers/net/wireless/ipw2x00/ipw2200.c-		/* If we aren't associated, schedule turning the LED off */
drivers/net/wireless/ipw2x00/ipw2200.c-		ipw_abort_scan(priv);
drivers/net/wireless/ipw2x00/ipw2200.c-						IPW_DEBUG_ASSOC
drivers/net/wireless/ipw2x00/ipw2200.c-		IPW_DEBUG_RF_KILL("RF Kill active, rescheduling GPIO check\n");
drivers/net/wireless/ipw2x00/ipw2200.c-	IPW_DEBUG_WX("Start scan\n");
drivers/net/wireless/ipw2x00/ipw2200.c-	ipw_led_band_off(priv);
drivers/net/wireless/ipw2x00/ipw2200.c-	ipw_led_link_off(priv);
drivers/net/wireless/ipw2x00/ipw2200.c-	ipw_reset_stats(priv);
drivers/net/wireless/ipw2x00/ipw2200.c-	ipw_reset_stats(priv);
drivers/net/wireless/ipw2x00/ipw2200.c-			       jiffies_to_msecs(IPW_SCAN_CHECK_WATCHDOG));
drivers/net/wireless/ipw2x00/ipw2200.c-				    "Kill switch must be turned off for "
drivers/net/wireless/ipw2x00/ipw2200.c-					      LD_TIME_LINK_OFF);
drivers/net/wireless/ipw2x00/ipw2200.c-					      LD_TIME_LINK_ON);
drivers/net/wireless/ipw2x00/ipw2200.c-							le16_to_cpu(priv->
drivers/net/wireless/ipw2x00/ipw2200.c-			      le16_to_cpu(priv->assoc_request.beacon_interval));
drivers/net/wireless/ipw2x00/ipw2200.c-	/* make sure all works are inactive */
drivers/net/wireless/ipw2x00/ipw2200.c-			/* Make sure the RF_KILL check timer is running */
drivers/net/wireless/ipw2x00/ipw2200.c-	mutex_lock(&priv->mutex);
drivers/net/wireless/ipw2x00/ipw2200.c-	mutex_unlock(&priv->mutex);
drivers/net/wireless/ipw2x00/ipw2200.c-	netif_carrier_on(priv->net_dev);
drivers/net/wireless/ipw2x00/ipw2200.c-			 * off a scan. */
drivers/net/wireless/ipw2x00/ipw2200.c-	/* Only userspace-requested scan completion events go out immediately */
drivers/net/wireless/ipw2x00/ipw2200.c-							&priv->adhoc_check,
drivers/net/wireless/ipw2x00/ipw2200.c-	priv->quality = quality;
drivers/net/wireless/ipw2x00/ipw2200.c-		    !(priv->status & STATUS_ASSOCIATED))
drivers/net/wireless/ipw2x00/ipw2200.c-				 && priv->status & STATUS_ASSOCIATED)
drivers/net/wireless/ipw2x00/ipw2200.c-		priv->status &= ~(STATUS_ASSOCIATED | STATUS_ASSOCIATING);
drivers/net/wireless/ipw2x00/ipw2200.c-		priv->status |= STATUS_LED_ACT_ON;
drivers/net/wireless/ipw2x00/ipw2200.c-		priv->status |= STATUS_RF_KILL_SW;
drivers/net/wireless/ipw2x00/ipw2200.c-					priv->status &= ~STATUS_ROAMING;
drivers/net/wireless/ipw2x00/ipw2200.c-			priv->status |= STATUS_ROAMING;
drivers/net/wireless/ipw2x00/ipw2200.c-				priv->status |= STATUS_SCAN_FORCED;
drivers/net/wireless/ipw2x00/ipw2200.c-		priv->status &= ~STATUS_SCAN_PENDING;
drivers/net/wireless/ipw2x00/ipw2200.c-		priv->user_requested_scan = 0;
drivers/net/wireless/ipw2x00/ipw2200.c-						    ("queueing adhoc check\n");
drivers/net/wireless/ipw2x00/ipw2200.c-		/* Queue up another scan... */
drivers/net/wireless/ipw2x00/ipw2200.c-		/* Reschedule LED off for full time period */
drivers/net/wireless/ipw2x00/ipw2200.c-		return;
drivers/net/wireless/ipw2x00/ipw2200.c-			return 0;
drivers/net/wireless/ipw2x00/ipw2200.c-			return 0;
drivers/net/wireless/ipw2x00/ipw2200.c-	return 0;
drivers/net/wireless/ipw2x00/ipw2200.c-					      round_jiffies_relative(2 * HZ));
drivers/net/wireless/ipw2x00/ipw2200.c-						      round_jiffies_relative(HZ));
drivers/net/wireless/ipw2x00/ipw2200.c-					      round_jiffies_relative(msecs_to_jiffies(4000)));
drivers/net/wireless/ipw2x00/ipw2200.c-						      SCAN_INTERVAL);
drivers/net/wireless/ipw2x00/ipw2200.c:						schedule_delayed_work(
drivers/net/wireless/ipw2x00/ipw2200.c:	schedule_delayed_work(&priv->adhoc_check,
drivers/net/wireless/ipw2x00/ipw2200.c:	schedule_delayed_work(&priv->gather_stats, IPW_STATS_INTERVAL);
drivers/net/wireless/ipw2x00/ipw2200.c:		schedule_delayed_work(&priv->led_act_off, LD_TIME_ACT_ON);
drivers/net/wireless/ipw2x00/ipw2200.c:		schedule_delayed_work(&priv->led_act_off, LD_TIME_ACT_ON);
drivers/net/wireless/ipw2x00/ipw2200.c:			schedule_delayed_work(&priv->led_link_off,
drivers/net/wireless/ipw2x00/ipw2200.c:			schedule_delayed_work(&priv->led_link_on,
drivers/net/wireless/ipw2x00/ipw2200.c:				schedule_delayed_work(&priv->request_direct_scan, 0);
drivers/net/wireless/ipw2x00/ipw2200.c:				schedule_delayed_work(&priv->request_scan,
drivers/net/wireless/ipw2x00/ipw2200.c:				schedule_delayed_work(&priv->request_scan,
drivers/net/wireless/ipw2x00/ipw2200.c:				schedule_delayed_work(&priv->request_scan, 0);
drivers/net/wireless/ipw2x00/ipw2200.c:				schedule_delayed_work(&priv->request_scan, 0);
drivers/net/wireless/ipw2x00/ipw2200.c:				schedule_delayed_work(&priv->request_scan, 0);
drivers/net/wireless/ipw2x00/ipw2200.c:				schedule_delayed_work(&priv->request_scan, 0);
drivers/net/wireless/ipw2x00/ipw2200.c:			schedule_delayed_work(&priv->request_scan, 0);
drivers/net/wireless/ipw2x00/ipw2200.c:		schedule_delayed_work(&priv->request_scan, 0);
drivers/net/wireless/ipw2x00/ipw2200.c:		schedule_delayed_work(&priv->request_scan, HZ);
drivers/net/wireless/ipw2x00/ipw2200.c:			schedule_delayed_work(&priv->rf_kill,
drivers/net/wireless/ipw2x00/ipw2200.c:			schedule_delayed_work(&priv->rf_kill, 2 * HZ);
drivers/net/wireless/ipw2x00/ipw2200.c:		schedule_delayed_work(&priv->rf_kill, 2 * HZ);
drivers/net/wireless/ipw2x00/ipw2200.c:		schedule_delayed_work(&priv->rf_kill, 2 * HZ);
drivers/net/wireless/ipw2x00/ipw2200.c:		schedule_delayed_work(&priv->scan_check, HZ);
drivers/net/wireless/ipw2x00/ipw2200.c:	schedule_delayed_work(&priv->scan_check, IPW_SCAN_CHECK_WATCHDOG);
drivers/net/wireless/ipw2x00/ipw2200.c:			schedule_delayed_work(&priv->scan_event,
drivers/net/wireless/ipw2x00/ipw2200.c:	schedule_delayed_work(work, 0);
drivers/net/wireless/ipw2x00/ipw2200.c-		schedule_work(&priv->down);
drivers/net/wireless/ipw2x00/ipw2200.c-		schedule_work(&priv->link_down);
drivers/net/wireless/ipw2x00/ipw2200.c:	struct delayed_work *work = NULL;
drivers/net/wireless/ipw2x00/ipw2200.c-	struct ipw_priv *priv = libipw_priv(dev);
drivers/net/wireless/ipw2x00/ipw2200.c-	struct iw_scan_req *req = (struct iw_scan_req *)extra;
drivers/net/wireless/ipw2x00/ipw2200.c-		wake_up_interruptible(&priv->wait_command_queue);
drivers/net/wireless/ipw2x00/ipw2200.c-			wake_up_interruptible(&priv->wait_state);
drivers/net/wireless/ipw2x00/ipw2200.c-				    "wireless networking to work.\n");
drivers/net/wireless/ipw2x00/ipw2200.c-		wrqu.data.length = 0;
drivers/net/wireless/iwlegacy/3945.c-
drivers/net/wireless/iwlegacy/3945.c-
drivers/net/wireless/iwlegacy/3945.c-{
drivers/net/wireless/iwlegacy/3945.c-}
drivers/net/wireless/iwlegacy/3945.c-}
drivers/net/wireless/iwlegacy/3945.c:	cancel_delayed_work(&il->_3945.thermal_periodic);
drivers/net/wireless/iwlegacy/3945.c-il3945_hw_cancel_deferred_work(struct il_priv *il)
drivers/net/wireless/iwlegacy/3945.c:	queue_delayed_work(il->workqueue, &il->_3945.thermal_periodic,
drivers/net/wireless/iwlegacy/3945.c-			   REG_RECALIB_PERIOD * HZ);
drivers/net/wireless/iwlegacy/3945.c-reschedule:
drivers/net/wireless/iwlegacy/3945-mac.c-
drivers/net/wireless/iwlegacy/3945-mac.c-
drivers/net/wireless/iwlegacy/3945-mac.c-
drivers/net/wireless/iwlegacy/3945-mac.c-
drivers/net/wireless/iwlegacy/3945-mac.c-
drivers/net/wireless/iwlegacy/3945-mac.c-
drivers/net/wireless/iwlegacy/3945-mac.c-
drivers/net/wireless/iwlegacy/3945-mac.c-
drivers/net/wireless/iwlegacy/3945-mac.c-
drivers/net/wireless/iwlegacy/3945-mac.c-
drivers/net/wireless/iwlegacy/3945-mac.c-
drivers/net/wireless/iwlegacy/3945-mac.c:	cancel_delayed_work(&il->_3945.rfkill_poll);
drivers/net/wireless/iwlegacy/3945-mac.c:	cancel_delayed_work(&il->alive_start);
drivers/net/wireless/iwlegacy/3945-mac.c:	cancel_delayed_work_sync(&il->_3945.rfkill_poll);
drivers/net/wireless/iwlegacy/3945-mac.c:	cancel_delayed_work_sync(&il->init_alive_start);
drivers/net/wireless/iwlegacy/3945-mac.c-	 * cancelled in mac_start() if system decides to start again */
drivers/net/wireless/iwlegacy/3945-mac.c-	else
drivers/net/wireless/iwlegacy/3945-mac.c-	 * give the HW RF Kill time to activate... */
drivers/net/wireless/iwlegacy/3945-mac.c-	if (palive->is_valid == UCODE_VALID_OK)
drivers/net/wireless/iwlegacy/3945-mac.c-	il3945_dealloc_ucode_pci(il);
drivers/net/wireless/iwlegacy/3945-mac.c-	il3945_hw_cancel_deferred_work(il);
drivers/net/wireless/iwlegacy/3945-mac.c-	il_cancel_scan_deferred_work(il);
drivers/net/wireless/iwlegacy/3945-mac.c-	il->is_open = 1;
drivers/net/wireless/iwlegacy/3945-mac.c-		IL_WARN("uCode did not respond OK.\n");
drivers/net/wireless/iwlegacy/3945-mac.c-	/* Keep this running, even if radio now enabled.  This will be
drivers/net/wireless/iwlegacy/3945-mac.c-	 * no need to poll the killswitch state anymore */
drivers/net/wireless/iwlegacy/3945-mac.c-	palive = &pkt->u.alive_frame;
drivers/net/wireless/iwlegacy/3945-mac.c:	queue_delayed_work(il->workqueue, &il->_3945.rfkill_poll,
drivers/net/wireless/iwlegacy/3945-mac.c:	queue_delayed_work(il->workqueue, &il->_3945.rfkill_poll,
drivers/net/wireless/iwlegacy/3945-mac.c:	queue_delayed_work(il->workqueue, &il->_3945.rfkill_poll, 2 * HZ);
drivers/net/wireless/iwlegacy/3945-mac.c:		queue_delayed_work(il->workqueue, pwork, msecs_to_jiffies(5));
drivers/net/wireless/iwlegacy/3945-mac.c-	return 0;
drivers/net/wireless/iwlegacy/3945-mac.c-			   round_jiffies_relative(2 * HZ));
drivers/net/wireless/iwlegacy/3945-mac.c-			   round_jiffies_relative(2 * HZ));
drivers/net/wireless/iwlegacy/3945-mac.c-	/* Start monitoring the killswitch */
drivers/net/wireless/iwlegacy/3945-mac.c-	/* start polling the killswitch state again */
drivers/net/wireless/iwlegacy/3945-mac.c:	struct delayed_work *pwork;
drivers/net/wireless/iwlegacy/3945-mac.c-	struct il_alive_resp *palive;
drivers/net/wireless/iwlegacy/3945-mac.c-	struct il_rx_pkt *pkt = rxb_addr(rxb);
drivers/net/wireless/iwlegacy/3945-mac.c-	sysfs_remove_group(&pdev->dev.kobj, &il3945_attribute_group);
drivers/net/wireless/iwlegacy/3945-mac.c-	/* ucode is running and will send rfkill notifications,
drivers/net/wireless/iwlegacy/4965-mac.c-
drivers/net/wireless/iwlegacy/4965-mac.c-
drivers/net/wireless/iwlegacy/4965-mac.c-{
drivers/net/wireless/iwlegacy/4965-mac.c:	cancel_delayed_work(&il->alive_start);
drivers/net/wireless/iwlegacy/4965-mac.c:	cancel_delayed_work_sync(&il->init_alive_start);
drivers/net/wireless/iwlegacy/4965-mac.c-	cancel_work_sync(&il->run_time_calib_work);
drivers/net/wireless/iwlegacy/4965-mac.c-	cancel_work_sync(&il->txpower_work);
drivers/net/wireless/iwlegacy/4965-mac.c-	else
drivers/net/wireless/iwlegacy/4965-mac.c-	 * give the HW RF Kill time to activate... */
drivers/net/wireless/iwlegacy/4965-mac.c-	if (palive->is_valid == UCODE_VALID_OK)
drivers/net/wireless/iwlegacy/4965-mac.c-		IL_WARN("uCode did not respond OK.\n");
drivers/net/wireless/iwlegacy/4965-mac.c-	palive = &pkt->u.alive_frame;
drivers/net/wireless/iwlegacy/4965-mac.c:		queue_delayed_work(il->workqueue, pwork, msecs_to_jiffies(5));
drivers/net/wireless/iwlegacy/4965-mac.c:	struct delayed_work *pwork;
drivers/net/wireless/iwlegacy/4965-mac.c-	struct il_alive_resp *palive;
drivers/net/wireless/iwlegacy/4965-mac.c-	struct il_rx_pkt *pkt = rxb_addr(rxb);
drivers/net/wireless/iwlegacy/common.c-
drivers/net/wireless/iwlegacy/common.c-
drivers/net/wireless/iwlegacy/common.c-
drivers/net/wireless/iwlegacy/common.c-
drivers/net/wireless/iwlegacy/common.c-
drivers/net/wireless/iwlegacy/common.c-
drivers/net/wireless/iwlegacy/common.c-
drivers/net/wireless/iwlegacy/common.c-	}
drivers/net/wireless/iwlegacy/common.c:	cancel_delayed_work(&il->scan_check);
drivers/net/wireless/iwlegacy/common.c:	cancel_delayed_work(&il->scan_check);
drivers/net/wireless/iwlegacy/common.c-	cancel_work_sync(&il->scan_completed);
drivers/net/wireless/iwlegacy/common.c-	D_SCAN("Completed scan.\n");
drivers/net/wireless/iwlegacy/common.c:	if (cancel_delayed_work_sync(&il->scan_check)) {
drivers/net/wireless/iwlegacy/common.c-	if (!il_is_ready_rf(il)) {
drivers/net/wireless/iwlegacy/common.c-		il_force_scan_end(il);
drivers/net/wireless/iwlegacy/common.c-			   IL_SCAN_CHECK_WATCHDOG);
drivers/net/wireless/iwlegacy/common.c-	lockdep_assert_held(&il->mutex);
drivers/net/wireless/iwlegacy/common.c-	mutex_lock(&il->mutex);
drivers/net/wireless/iwlegacy/common.c-		mutex_lock(&il->mutex);
drivers/net/wireless/iwlegacy/common.c:	queue_delayed_work(il->workqueue, &il->scan_check,
drivers/net/wireless/iwlwifi/iwl-scan.c-
drivers/net/wireless/iwlwifi/iwl-scan.c-
drivers/net/wireless/iwlwifi/iwl-scan.c-
drivers/net/wireless/iwlwifi/iwl-scan.c-
drivers/net/wireless/iwlwifi/iwl-scan.c-
drivers/net/wireless/iwlwifi/iwl-scan.c-
drivers/net/wireless/iwlwifi/iwl-scan.c-
drivers/net/wireless/iwlwifi/iwl-scan.c-
drivers/net/wireless/iwlwifi/iwl-scan.c-
drivers/net/wireless/iwlwifi/iwl-scan.c-	}
drivers/net/wireless/iwlwifi/iwl-scan.c-	}
drivers/net/wireless/iwlwifi/iwl-scan.c-	}
drivers/net/wireless/iwlwifi/iwl-scan.c-	aborted = test_and_clear_bit(STATUS_SCAN_ABORTING, &priv->status);
drivers/net/wireless/iwlwifi/iwl-scan.c:	cancel_delayed_work(&priv->scan_check);
drivers/net/wireless/iwlwifi/iwl-scan.c:	cancel_delayed_work(&priv->scan_check);
drivers/net/wireless/iwlwifi/iwl-scan.c-	cancel_work_sync(&priv->scan_completed);
drivers/net/wireless/iwlwifi/iwl-scan.c-		ieee80211_remain_on_channel_expired(priv->hw);
drivers/net/wireless/iwlwifi/iwl-scan.c-		ieee80211_remain_on_channel_expired(priv->hw);
drivers/net/wireless/iwlwifi/iwl-scan.c:	if (cancel_delayed_work_sync(&priv->scan_check)) {
drivers/net/wireless/iwlwifi/iwl-scan.c-	if (!iwl_is_ready_rf(priv)) {
drivers/net/wireless/iwlwifi/iwl-scan.c-	IWL_DEBUG_SCAN(priv, "Completed scan.\n");
drivers/net/wireless/iwlwifi/iwl-scan.c-		iwl_force_scan_end(priv);
drivers/net/wireless/iwlwifi/iwl-scan.c-			   IWL_SCAN_CHECK_WATCHDOG);
drivers/net/wireless/iwlwifi/iwl-scan.c-	lockdep_assert_held(&priv->mutex);
drivers/net/wireless/iwlwifi/iwl-scan.c-		mutex_lock(&priv->mutex);
drivers/net/wireless/iwlwifi/iwl-scan.c-		priv->hw_roc_channel = NULL;
drivers/net/wireless/iwlwifi/iwl-scan.c-		priv->hw_roc_channel = NULL;
drivers/net/wireless/iwlwifi/iwl-scan.c:	queue_delayed_work(priv->workqueue, &priv->scan_check,
drivers/net/wireless/iwlwifi/iwl-scan.c:		schedule_delayed_work(&priv->hw_roc_disable_work, 10 * HZ);
drivers/net/wireless/iwlwifi/iwl-scan.c:		schedule_delayed_work(&priv->hw_roc_disable_work, 10 * HZ);
drivers/net/wireless/iwmc3200wifi/rx.c-
drivers/net/wireless/iwmc3200wifi/rx.c-
drivers/net/wireless/iwmc3200wifi/rx.c-
drivers/net/wireless/iwmc3200wifi/rx.c-
drivers/net/wireless/iwmc3200wifi/rx.c-
drivers/net/wireless/iwmc3200wifi/rx.c-	}
drivers/net/wireless/iwmc3200wifi/rx.c-		}
drivers/net/wireless/iwmc3200wifi/rx.c-		 */
drivers/net/wireless/iwmc3200wifi/rx.c-			break;
drivers/net/wireless/iwmc3200wifi/rx.c:			cancel_delayed_work(&iwm->disconnect);
drivers/net/wireless/iwmc3200wifi/rx.c:			cancel_delayed_work(&iwm->disconnect);
drivers/net/wireless/iwmc3200wifi/rx.c:		cancel_delayed_work_sync(&iwm->ct_kill_delay);
drivers/net/wireless/iwmc3200wifi/rx.c-			cfg80211_roamed(iwm_to_ndev(iwm), NULL,
drivers/net/wireless/iwmc3200wifi/rx.c-					complete->bssid,
drivers/net/wireless/iwmc3200wifi/rx.c-		if (!test_and_clear_bit(IWM_STATUS_SME_CONNECTING, &iwm->status)
drivers/net/wireless/iwmc3200wifi/rx.c-		if (!test_and_clear_bit(IWM_STATUS_SME_CONNECTING, &iwm->status)
drivers/net/wireless/iwmc3200wifi/rx.c-		    && iwm->conf.mode == UMAC_MODE_BSS) {
drivers/net/wireless/iwmc3200wifi/rx.c-		    && iwm->conf.mode == UMAC_MODE_BSS) {
drivers/net/wireless/iwmc3200wifi/rx.c-	IWM_DBG_MLME(iwm, DBG, "Connection terminated\n");
drivers/net/wireless/iwmc3200wifi/rx.c-	mod_timer(&iwm->watchdog, round_jiffies(jiffies + IWM_WATCHDOG_PERIOD));
drivers/net/wireless/iwmc3200wifi/rx.c-	return 0;
drivers/net/wireless/iwmc3200wifi/rx.c:		schedule_delayed_work(&iwm->ct_kill_delay, CT_KILL_DELAY);
drivers/net/wireless/iwmc3200wifi/rx.c:	schedule_delayed_work(&iwm->disconnect, IWM_DISCONNECT_INTERVAL);
drivers/net/wireless/iwmc3200wifi/rx.c:	schedule_delayed_work(&iwm->stats_request, IWM_STATS_UPDATE_INTERVAL);
drivers/net/wireless/iwmc3200wifi/rx.c-		 * this code path again.
drivers/net/wireless/iwmc3200wifi/rx.c-	wstats->qual.updated = IW_QUAL_ALL_UPDATED | IW_QUAL_DBM;
drivers/net/wireless/libertas/cfg.c-
drivers/net/wireless/libertas/cfg.c-
drivers/net/wireless/libertas/cfg.c-
drivers/net/wireless/libertas/cfg.c-
drivers/net/wireless/libertas/cfg.c-
drivers/net/wireless/libertas/cfg.c-{
drivers/net/wireless/libertas/cfg.c-}
drivers/net/wireless/libertas/cfg.c-	}
drivers/net/wireless/libertas/cfg.c-	}
drivers/net/wireless/libertas/cfg.c:		cancel_delayed_work(&priv->scan_work);
drivers/net/wireless/libertas/cfg.c:		cancel_delayed_work(&priv->scan_work);
drivers/net/wireless/libertas/cfg.c:	cancel_delayed_work_sync(&priv->scan_work);
drivers/net/wireless/libertas/cfg.c-		if (netif_running(priv->dev))
drivers/net/wireless/libertas/cfg.c-	if (priv->scan_channel < priv->scan_req->n_channels) {
drivers/net/wireless/libertas/cfg.c-	if (priv->scan_channel >= priv->scan_req->n_channels) {
drivers/net/wireless/libertas/cfg.c:	if (priv->scan_req || delayed_work_pending(&priv->scan_work)) {
drivers/net/wireless/libertas/cfg.c-	lbs_deb_enter(LBS_DEB_CFG80211);
drivers/net/wireless/libertas/cfg.c-	lbs_deb_enter(LBS_DEB_CFG80211);
drivers/net/wireless/libertas/cfg.c-		lbs_scan_done(priv);
drivers/net/wireless/libertas/cfg.c-		/* Mark scan done */
drivers/net/wireless/libertas/cfg.c-				msecs_to_jiffies(300));
drivers/net/wireless/libertas/cfg.c-		msecs_to_jiffies(50));
drivers/net/wireless/libertas/cfg.c-		/* old scan request not yet processed */
drivers/net/wireless/libertas/cfg.c-	priv->internal_scan = internal;
drivers/net/wireless/libertas/cfg.c:			queue_delayed_work(priv->work_thread, &priv->scan_work,
drivers/net/wireless/libertas/cfg.c:	queue_delayed_work(priv->work_thread, &priv->scan_work,
drivers/net/wireless/libertas/cfg.c-		ret = -EAGAIN;
drivers/net/wireless/mac80211_hwsim.c-
drivers/net/wireless/mac80211_hwsim.c-
drivers/net/wireless/mac80211_hwsim.c-
drivers/net/wireless/mac80211_hwsim.c-};
drivers/net/wireless/mac80211_hwsim.c-			16, 1, req->ie, req->ie_len, 1);
drivers/net/wireless/mac80211_hwsim.c:	ieee80211_queue_delayed_work(hw, &hsd->w, 2 * HZ);
drivers/net/wireless/mac80211_hwsim.c-	return 0;
drivers/net/wireless/mac80211_hwsim.c:	struct delayed_work w;
drivers/net/wireless/mac80211_hwsim.c-struct hw_scan_done {
drivers/net/wireless/mac80211_hwsim.c-	struct ieee80211_hw *hw;
drivers/net/wireless/p54/led.c-
drivers/net/wireless/p54/led.c-
drivers/net/wireless/p54/led.c-}
drivers/net/wireless/p54/led.c-}
drivers/net/wireless/p54/led.c-}
drivers/net/wireless/p54/led.c-	}
drivers/net/wireless/p54/led.c-	}
drivers/net/wireless/p54/led.c:	cancel_delayed_work_sync(&priv->led_work);
drivers/net/wireless/p54/led.c:		ieee80211_queue_delayed_work(priv->hw, &priv->led_work,
drivers/net/wireless/p54/led.c:		ieee80211_queue_delayed_work(priv->hw, &priv->led_work, HZ/10);
drivers/net/wireless/p54/led.c-	if ((brightness) && (led->registered)) {
drivers/net/wireless/p54/led.c-	if (rerun)
drivers/net/wireless/p54/led.c-		led->toggled++;
drivers/net/wireless/p54/led.c-			msecs_to_jiffies(blink_delay));
drivers/net/wireless/p54/main.c-
drivers/net/wireless/p54/main.c-
drivers/net/wireless/p54/main.c-	}
drivers/net/wireless/p54/main.c:	cancel_delayed_work_sync(&priv->work);
drivers/net/wireless/p54/main.c:	ieee80211_queue_delayed_work(dev, &priv->work, 0);
drivers/net/wireless/p54/main.c-	mutex_lock(&priv->conf_mutex);
drivers/net/wireless/p54/main.c-	p54_set_leds(priv);
drivers/net/wireless/p54/main.c-	priv->mode = NL80211_IFTYPE_UNSPECIFIED;
drivers/net/wireless/p54/main.c-	priv->softled_state = 0;
drivers/net/wireless/p54/main.c-	priv->softled_state = 0;
drivers/net/wireless/p54/txrx.c-
drivers/net/wireless/p54/txrx.c-
drivers/net/wireless/p54/txrx.c:	ieee80211_queue_delayed_work(priv->hw, &priv->work,
drivers/net/wireless/p54/txrx.c-	ieee80211_rx_irqsafe(priv->hw, skb);
drivers/net/wireless/p54/txrx.c-			   msecs_to_jiffies(P54_STATISTICS_UPDATE));
drivers/net/wireless/rndis_wlan.c-
drivers/net/wireless/rndis_wlan.c-
drivers/net/wireless/rndis_wlan.c-
drivers/net/wireless/rndis_wlan.c-
drivers/net/wireless/rndis_wlan.c-
drivers/net/wireless/rndis_wlan.c-
drivers/net/wireless/rndis_wlan.c-
drivers/net/wireless/rndis_wlan.c-
drivers/net/wireless/rndis_wlan.c-
drivers/net/wireless/rndis_wlan.c-}
drivers/net/wireless/rndis_wlan.c-	}
drivers/net/wireless/rndis_wlan.c-	}
drivers/net/wireless/rndis_wlan.c:	cancel_delayed_work_sync(&priv->dev_poller_work);
drivers/net/wireless/rndis_wlan.c:	cancel_delayed_work_sync(&priv->dev_poller_work);
drivers/net/wireless/rndis_wlan.c:	cancel_delayed_work_sync(&priv->dev_poller_work);
drivers/net/wireless/rndis_wlan.c:	cancel_delayed_work_sync(&priv->scan_work);
drivers/net/wireless/rndis_wlan.c:	cancel_delayed_work_sync(&priv->scan_work);
drivers/net/wireless/rndis_wlan.c:	cancel_delayed_work_sync(&priv->scan_work);
drivers/net/wireless/rndis_wlan.c-	cancel_work_sync(&priv->work);
drivers/net/wireless/rndis_wlan.c-	cancel_work_sync(&priv->work);
drivers/net/wireless/rndis_wlan.c-	cancel_work_sync(&priv->work);
drivers/net/wireless/rndis_wlan.c-	disassociate(usbdev, false);
drivers/net/wireless/rndis_wlan.c-fail:
drivers/net/wireless/rndis_wlan.c-	flush_workqueue(priv->workqueue);
drivers/net/wireless/rndis_wlan.c-	flush_workqueue(priv->workqueue);
drivers/net/wireless/rndis_wlan.c-	flush_workqueue(priv->workqueue);
drivers/net/wireless/rndis_wlan.c-	priv->work_pending = 0;
drivers/net/wireless/rndis_wlan.c:	queue_delayed_work(priv->workqueue, &priv->dev_poller_work,
drivers/net/wireless/rndis_wlan.c:	queue_delayed_work(priv->workqueue, &priv->dev_poller_work,
drivers/net/wireless/rndis_wlan.c:		queue_delayed_work(priv->workqueue, &priv->scan_work, delay);
drivers/net/wireless/rndis_wlan.c-		round_jiffies_relative(DEVICE_POLLER_JIFFIES));
drivers/net/wireless/rndis_wlan.c-	set_multicast_list(usbdev);
drivers/net/wireless/rndis_wlan.c:	struct delayed_work dev_poller_work;
drivers/net/wireless/rndis_wlan.c:	struct delayed_work scan_work;
drivers/net/wireless/rndis_wlan.c-	struct mutex command_lock;
drivers/net/wireless/rndis_wlan.c-	struct workqueue_struct *workqueue;
drivers/net/wireless/rndis_wlan.c-	struct work_struct work;
drivers/net/wireless/rndis_wlan.c-								update_jiffies);
drivers/net/wireless/rndis_wlan.c-		/* Wait before retrieving scan results from device */
drivers/net/wireless/rt2x00/rt2x00config.c-
drivers/net/wireless/rt2x00/rt2x00config.c-
drivers/net/wireless/rt2x00/rt2x00config.c-	/*
drivers/net/wireless/rt2x00/rt2x00config.c-				   autowake_timeout - 15);
drivers/net/wireless/rt2x00/rt2x00config.c-		autowake_timeout = (conf->max_sleep_period * beacon_int) - beacon_diff;
drivers/net/wireless/rt2x00/rt2x00config.c:		cancel_delayed_work_sync(&rt2x00dev->autowakeup_work);
drivers/net/wireless/rt2x00/rt2x00config.c-	    (ieee80211_flags & IEEE80211_CONF_CHANGE_PS))
drivers/net/wireless/rt2x00/rt2x00config.c-	if (test_bit(REQUIRE_PS_AUTOWAKE, &rt2x00dev->cap_flags) &&
drivers/net/wireless/rt2x00/rt2x00config.c:		queue_delayed_work(rt2x00dev->workqueue,
drivers/net/wireless/rt2x00/rt2x00config.c-				   &rt2x00dev->autowakeup_work,
drivers/net/wireless/rt2x00/rt2x00link.c-
drivers/net/wireless/rt2x00/rt2x00link.c-
drivers/net/wireless/rt2x00/rt2x00link.c-
drivers/net/wireless/rt2x00/rt2x00link.c-
drivers/net/wireless/rt2x00/rt2x00link.c-
drivers/net/wireless/rt2x00/rt2x00link.c-
drivers/net/wireless/rt2x00/rt2x00link.c-
drivers/net/wireless/rt2x00/rt2x00link.c-
drivers/net/wireless/rt2x00/rt2x00link.c-
drivers/net/wireless/rt2x00/rt2x00link.c-{
drivers/net/wireless/rt2x00/rt2x00link.c-{
drivers/net/wireless/rt2x00/rt2x00link.c-{
drivers/net/wireless/rt2x00/rt2x00link.c-{
drivers/net/wireless/rt2x00/rt2x00link.c-}
drivers/net/wireless/rt2x00/rt2x00link.c-}
drivers/net/wireless/rt2x00/rt2x00link.c-}
drivers/net/wireless/rt2x00/rt2x00link.c-}
drivers/net/wireless/rt2x00/rt2x00link.c-}
drivers/net/wireless/rt2x00/rt2x00link.c-}
drivers/net/wireless/rt2x00/rt2x00link.c-					     AGC_INTERVAL);
drivers/net/wireless/rt2x00/rt2x00link.c-					     AGC_INTERVAL);
drivers/net/wireless/rt2x00/rt2x00link.c:	cancel_delayed_work_sync(&rt2x00dev->link.agc_work);
drivers/net/wireless/rt2x00/rt2x00link.c:	cancel_delayed_work_sync(&rt2x00dev->link.vco_work);
drivers/net/wireless/rt2x00/rt2x00link.c:	cancel_delayed_work_sync(&rt2x00dev->link.watchdog_work);
drivers/net/wireless/rt2x00/rt2x00link.c:	cancel_delayed_work_sync(&rt2x00dev->link.work);
drivers/net/wireless/rt2x00/rt2x00link.c:		ieee80211_queue_delayed_work(rt2x00dev->hw,
drivers/net/wireless/rt2x00/rt2x00link.c:		ieee80211_queue_delayed_work(rt2x00dev->hw,
drivers/net/wireless/rt2x00/rt2x00link.c:		ieee80211_queue_delayed_work(rt2x00dev->hw,
drivers/net/wireless/rt2x00/rt2x00link.c:		ieee80211_queue_delayed_work(rt2x00dev->hw,
drivers/net/wireless/rt2x00/rt2x00link.c:		ieee80211_queue_delayed_work(rt2x00dev->hw,
drivers/net/wireless/rt2x00/rt2x00link.c:		ieee80211_queue_delayed_work(rt2x00dev->hw,
drivers/net/wireless/rt2x00/rt2x00link.c:		ieee80211_queue_delayed_work(rt2x00dev->hw,
drivers/net/wireless/rt2x00/rt2x00link.c:		ieee80211_queue_delayed_work(rt2x00dev->hw,
drivers/net/wireless/rt2x00/rt2x00link.c-	if (test_bit(DEVICE_STATE_PRESENT, &rt2x00dev->flags))
drivers/net/wireless/rt2x00/rt2x00link.c-	if (test_bit(DEVICE_STATE_PRESENT, &rt2x00dev->flags))
drivers/net/wireless/rt2x00/rt2x00link.c-	if (test_bit(DEVICE_STATE_PRESENT, &rt2x00dev->flags))
drivers/net/wireless/rt2x00/rt2x00link.c-	if (test_bit(DEVICE_STATE_PRESENT, &rt2x00dev->flags))
drivers/net/wireless/rt2x00/rt2x00link.c-	if (test_bit(DEVICE_STATE_PRESENT, &rt2x00dev->flags))
drivers/net/wireless/rt2x00/rt2x00link.c-	if (test_bit(DEVICE_STATE_PRESENT, &rt2x00dev->flags) &&
drivers/net/wireless/rt2x00/rt2x00link.c-	if (test_bit(DEVICE_STATE_PRESENT, &rt2x00dev->flags) &&
drivers/net/wireless/rt2x00/rt2x00link.c-	if (test_bit(DEVICE_STATE_PRESENT, &rt2x00dev->flags) &&
drivers/net/wireless/rt2x00/rt2x00link.c-					     &link->agc_work,
drivers/net/wireless/rt2x00/rt2x00link.c-					     &link->agc_work,
drivers/net/wireless/rt2x00/rt2x00link.c-					     &link->vco_work,
drivers/net/wireless/rt2x00/rt2x00link.c-					     &link->vco_work,
drivers/net/wireless/rt2x00/rt2x00link.c-					     &link->watchdog_work,
drivers/net/wireless/rt2x00/rt2x00link.c-					     &link->watchdog_work,
drivers/net/wireless/rt2x00/rt2x00link.c-					     &link->work, LINK_TUNE_INTERVAL);
drivers/net/wireless/rt2x00/rt2x00link.c-					     &link->work, LINK_TUNE_INTERVAL);
drivers/net/wireless/rt2x00/rt2x00link.c-	    rt2x00dev->ops->lib->gain_calibration)
drivers/net/wireless/rt2x00/rt2x00link.c-	    rt2x00dev->ops->lib->vco_calibration)
drivers/net/wireless/rt2x00/rt2x00link.c-	    rt2x00dev->ops->lib->watchdog)
drivers/net/wireless/rt2x00/rt2x00link.c-					     VCO_INTERVAL);
drivers/net/wireless/rt2x00/rt2x00link.c-					     VCO_INTERVAL);
drivers/net/wireless/rt2x00/rt2x00link.c-void rt2x00link_stop_agc(struct rt2x00_dev *rt2x00dev)
drivers/net/wireless/rt2x00/rt2x00link.c-void rt2x00link_stop_tuner(struct rt2x00_dev *rt2x00dev)
drivers/net/wireless/rt2x00/rt2x00link.c-void rt2x00link_stop_vcocal(struct rt2x00_dev *rt2x00dev)
drivers/net/wireless/rt2x00/rt2x00link.c-void rt2x00link_stop_watchdog(struct rt2x00_dev *rt2x00dev)
drivers/net/wireless/rt2x00/rt2x00link.c-					     WATCHDOG_INTERVAL);
drivers/net/wireless/rt2x00/rt2x00link.c-					     WATCHDOG_INTERVAL);
drivers/net/wireless/rtl818x/rtl8180/dev.c-
drivers/net/wireless/rtl818x/rtl8180/dev.c-}
drivers/net/wireless/rtl818x/rtl8180/dev.c-	 */
drivers/net/wireless/rtl818x/rtl8180/dev.c:		cancel_delayed_work_sync(&vif_priv->beacon_work);
drivers/net/wireless/rtl818x/rtl8180/dev.c-	if (changed & (BSS_CHANGED_BEACON_ENABLED | BSS_CHANGED_BEACON)) {
drivers/net/wireless/rtl818x/rtl8180/dev.c-		if (vif_priv->enable_beacon)
drivers/net/wireless/rtl818x/rtl8180/dev.c:	schedule_delayed_work(&vif_priv->beacon_work,
drivers/net/wireless/rtl818x/rtl8180/dev.c-			schedule_work(&vif_priv->beacon_work.work);
drivers/net/wireless/rtl818x/rtl8180/dev.c-	 * TODO: use hardware support for beacon timing
drivers/net/wireless/rtl818x/rtl8180/dev.c-			usecs_to_jiffies(1024 * vif->bss_conf.beacon_int));
drivers/net/wireless/rtl818x/rtl8187/dev.c-
drivers/net/wireless/rtl818x/rtl8187/dev.c-
drivers/net/wireless/rtl818x/rtl8187/dev.c-
drivers/net/wireless/rtl818x/rtl8187/dev.c-}
drivers/net/wireless/rtl818x/rtl8187/dev.c-}
drivers/net/wireless/rtl818x/rtl8187/dev.c-}
drivers/net/wireless/rtl818x/rtl8187/dev.c-	}
drivers/net/wireless/rtl818x/rtl8187/dev.c-	 */
drivers/net/wireless/rtl818x/rtl8187/dev.c:		cancel_delayed_work_sync(&priv->work);
drivers/net/wireless/rtl818x/rtl8187/dev.c:		cancel_delayed_work_sync(&vif_priv->beacon_work);
drivers/net/wireless/rtl818x/rtl8187/dev.c-		 * here, thus queue the skb and finish on a work queue. */
drivers/net/wireless/rtl818x/rtl8187/dev.c:		ieee80211_queue_delayed_work(hw, &priv->work, 0);
drivers/net/wireless/rtl818x/rtl8187/dev.c-	if (changed & (BSS_CHANGED_BEACON_ENABLED | BSS_CHANGED_BEACON)) {
drivers/net/wireless/rtl818x/rtl8187/dev.c-	if (!priv->is_rtl8187b)
drivers/net/wireless/rtl818x/rtl8187/dev.c-		if (vif_priv->enable_beacon)
drivers/net/wireless/rtl818x/rtl8187/dev.c:	schedule_delayed_work(&vif_priv->beacon_work,
drivers/net/wireless/rtl818x/rtl8187/dev.c-			schedule_work(&vif_priv->beacon_work.work);
drivers/net/wireless/rtl818x/rtl8187/dev.c-		skb_queue_tail(&priv->b_tx_status.queue, skb);
drivers/net/wireless/rtl818x/rtl8187/dev.c-	 * TODO: use hardware support for beacon timing
drivers/net/wireless/rtl818x/rtl8187/dev.c-			usecs_to_jiffies(1024 * vif->bss_conf.beacon_int));
drivers/net/wireless/rtl818x/rtl8187/leds.c-
drivers/net/wireless/rtl818x/rtl8187/leds.c-}
drivers/net/wireless/rtl818x/rtl8187/leds.c-}
drivers/net/wireless/rtl818x/rtl8187/leds.c-}
drivers/net/wireless/rtl818x/rtl8187/leds.c-	}
drivers/net/wireless/rtl818x/rtl8187/leds.c-		}
drivers/net/wireless/rtl818x/rtl8187/leds.c:			cancel_delayed_work(&priv->led_on);
drivers/net/wireless/rtl818x/rtl8187/leds.c:	cancel_delayed_work_sync(&priv->led_off);
drivers/net/wireless/rtl818x/rtl8187/leds.c:	cancel_delayed_work_sync(&priv->led_on);
drivers/net/wireless/rtl818x/rtl8187/leds.c-		} else
drivers/net/wireless/rtl818x/rtl8187/leds.c-	} else if (radio_on) {
drivers/net/wireless/rtl818x/rtl8187/leds.c-		} else if (radio_on) {
drivers/net/wireless/rtl818x/rtl8187/leds.c-#endif /* def CONFIG_RTL8187_LEDS */
drivers/net/wireless/rtl818x/rtl8187/leds.c:	flush_delayed_work(&priv->led_off);
drivers/net/wireless/rtl818x/rtl8187/leds.c-						     HZ / 20);
drivers/net/wireless/rtl818x/rtl8187/leds.c:			ieee80211_queue_delayed_work(hw, &priv->led_off, 0);
drivers/net/wireless/rtl818x/rtl8187/leds.c:			ieee80211_queue_delayed_work(hw, &priv->led_off, 0);
drivers/net/wireless/rtl818x/rtl8187/leds.c:			ieee80211_queue_delayed_work(hw, &priv->led_on,
drivers/net/wireless/rtl818x/rtl8187/leds.c:			ieee80211_queue_delayed_work(hw, &priv->led_on, 0);
drivers/net/wireless/rtl818x/rtl8187/leds.c:			ieee80211_queue_delayed_work(hw, &priv->led_on, 0);
drivers/net/wireless/rtl818x/rtl8187/leds.c-		if (brightness == LED_FULL) {
drivers/net/wireless/rtl818x/rtl8187/leds.c-		if (brightness == LED_OFF) {
drivers/net/wireless/rtl818x/rtl8187/leds.c-	if (led->is_radio) {
drivers/net/wireless/rtl818x/rtl8187/leds.c-	led_classdev_unregister(&led->led_dev);
drivers/net/wireless/rtl818x/rtl8187/leds.c-	led->dev = NULL;
drivers/net/wireless/rtl818x/rtl8187/leds.c-			radio_on = false;
drivers/net/wireless/rtl818x/rtl8187/leds.c-			radio_on = true;
drivers/net/wireless/rtl818x/rtl8187/leds.c-	rtl8187_unregister_led(&priv->led_rx);
drivers/net/wireless/rtl818x/rtl8187/leds.c-	rtl8187_unregister_led(&priv->led_tx);
drivers/net/wireless/rtl818x/rtl8187/leds.c-			/* The LED is off for 1/20 sec - it just blinks. */
drivers/net/wireless/rtlwifi/base.c-
drivers/net/wireless/rtlwifi/base.c-
drivers/net/wireless/rtlwifi/base.c-
drivers/net/wireless/rtlwifi/base.c-
drivers/net/wireless/rtlwifi/base.c-}
drivers/net/wireless/rtlwifi/base.c:	cancel_delayed_work(&rtlpriv->works.ips_nic_off_wq);
drivers/net/wireless/rtlwifi/base.c:	cancel_delayed_work(&rtlpriv->works.ps_rfon_wq);
drivers/net/wireless/rtlwifi/base.c:	cancel_delayed_work(&rtlpriv->works.ps_work);
drivers/net/wireless/rtlwifi/base.c:	cancel_delayed_work(&rtlpriv->works.watchdog_wq);
drivers/net/wireless/rtlwifi/base.c-	del_timer_sync(&rtlpriv->works.watchdog_timer);
drivers/net/wireless/rtlwifi/base.c:	queue_delayed_work(rtlpriv->works.rtl_wq,
drivers/net/wireless/rtlwifi/base.c-			   &rtlpriv->works.watchdog_wq, 0);
drivers/net/wireless/rtlwifi/base.c-	struct rtl_priv *rtlpriv = rtl_priv(hw);
drivers/net/wireless/rtlwifi/core.c:		cancel_delayed_work(&rtlpriv->works.ps_rfon_wq);
drivers/net/wireless/rtlwifi/core.c:		cancel_delayed_work(&rtlpriv->works.ps_work);
drivers/net/wireless/rtlwifi/core.c-	/*For LPS */
drivers/net/wireless/rtlwifi/core.c-	if (changed & IEEE80211_CONF_CHANGE_PS) {
drivers/net/wireless/rtlwifi/core.c-		if (conf->flags & IEEE80211_CONF_PS) {
drivers/net/wireless/rtlwifi/core.c-			if (!rtlpriv->psc.multi_buffered)
drivers/net/wireless/rtlwifi/core.c-			 * is worked very well */
drivers/net/wireless/rtlwifi/core.c-						MSECS(5));
drivers/net/wireless/rtlwifi/core.c:				queue_delayed_work(rtlpriv->works.rtl_wq,
drivers/net/wireless/rtlwifi/core.c-			rtlpriv->psc.sw_ps_enabled = true;
drivers/net/wireless/rtlwifi/core.c-						&rtlpriv->works.ps_work,
drivers/net/wireless/rtlwifi/ps.c-
drivers/net/wireless/rtlwifi/ps.c-}
drivers/net/wireless/rtlwifi/ps.c-}
drivers/net/wireless/rtlwifi/ps.c-	 */
drivers/net/wireless/rtlwifi/ps.c-		/* back to low-power land. and delay is
drivers/net/wireless/rtlwifi/ps.c-	} else {
drivers/net/wireless/rtlwifi/ps.c-			MSECS(sleep_intv * mac->vif->bss_conf.beacon_int - 40));
drivers/net/wireless/rtlwifi/ps.c-		 * prevent null power save frame tx fail */
drivers/net/wireless/rtlwifi/ps.c:	queue_delayed_work(rtlpriv->works.rtl_wq,
drivers/net/wireless/rtlwifi/ps.c:		queue_delayed_work(rtlpriv->works.rtl_wq,
drivers/net/wireless/rtlwifi/ps.c:	queue_delayed_work(rtlpriv->works.rtl_wq, &rtlpriv->works.ps_rfon_wq,
drivers/net/wireless/rtlwifi/ps.c-			   &rtlpriv->works.ips_nic_off_wq, MSECS(100));
drivers/net/wireless/rtlwifi/ps.c-				&rtlpriv->works.ps_work, MSECS(5));
drivers/net/wireless/rtlwifi/ps.c-	 *this will cause link failed, so we delay 100ms here
drivers/net/wireless/rtlwifi/ps.c-	/* we tested that 40ms is enough for sw & hw sw delay */
drivers/net/wireless/wcnss/wcnss_wlan.c-
drivers/net/wireless/wcnss/wcnss_wlan.c-{
drivers/net/wireless/wcnss/wcnss_wlan.c-}
drivers/net/wireless/wcnss/wcnss_wlan.c-EXPORT_SYMBOL(wcnss_flush_delayed_boot_votes);
drivers/net/wireless/wcnss/wcnss_wlan.c:	flush_delayed_work(&penv->wcnss_work);
drivers/net/wireless/wcnss/wcnss_wlan.c-	INIT_DELAYED_WORK(&penv->wcnss_work, wcnss_post_bootup);
drivers/net/wireless/wcnss/wcnss_wlan.c-	return 0;
drivers/net/wireless/wcnss/wcnss_wlan.c-	/* Schedule a work to do any post boot up activity */
drivers/net/wireless/wcnss/wcnss_wlan.c:	schedule_delayed_work(&penv->wcnss_work, msecs_to_jiffies(10000));
drivers/net/wireless/wcnss/wcnss_wlan.c:	struct delayed_work wcnss_work;
drivers/net/wireless/wcnss/wcnss_wlan.c-	struct wcnss_wlan_config wlan_config;
drivers/net/wireless/wcnss/wcnss_wlan.c-	struct work_struct wcnssctrl_nvbin_dnld_work;
drivers/net/wireless/wcnss/wcnss_wlan.c-	struct work_struct wcnssctrl_version_work;
drivers/net/wireless/wcnss/wcnss_wlan.c-	void		(*tm_notify)(struct device *, int);
drivers/net/wireless/wcnss/wcnss_wlan.c-void wcnss_flush_delayed_boot_votes()
drivers/net/wireless/wl1251/ps.c-
drivers/net/wireless/wl1251/ps.c-
drivers/net/wireless/wl1251/ps.c-
drivers/net/wireless/wl1251/ps.c-
drivers/net/wireless/wl1251/ps.c-{
drivers/net/wireless/wl1251/ps.c-}
drivers/net/wireless/wl1251/ps.c-	}
drivers/net/wireless/wl1251/ps.c:		cancel_delayed_work(&wl->elp_work);
drivers/net/wireless/wl1251/ps.c-		delay = msecs_to_jiffies(ELP_ENTRY_DELAY);
drivers/net/wireless/wl1251/ps.c:	dwork = container_of(work, struct delayed_work, work);
drivers/net/wireless/wl1251/ps.c:		ieee80211_queue_delayed_work(wl->hw, &wl->elp_work, delay);
drivers/net/wireless/wl1251/ps.c:	if (delayed_work_pending(&wl->elp_work))
drivers/net/wireless/wl1251/ps.c-	if (!wl->elp)
drivers/net/wireless/wl1251/ps.c-	if (wl->station_mode != STATION_ACTIVE_MODE) {
drivers/net/wireless/wl1251/ps.c:	struct delayed_work *dwork;
drivers/net/wireless/wl1251/ps.c-	struct wl1251 *wl;
drivers/net/wireless/wl1251/ps.c-	u32 elp_reg;
drivers/net/wireless/wl1251/ps.c-void wl1251_elp_work(struct work_struct *work)
drivers/net/wireless/wl1251/ps.c-	wl = container_of(dwork, struct wl1251, elp_work);
drivers/net/wireless/wl12xx/main.c-
drivers/net/wireless/wl12xx/main.c-
drivers/net/wireless/wl12xx/main.c-
drivers/net/wireless/wl12xx/main.c-
drivers/net/wireless/wl12xx/main.c-
drivers/net/wireless/wl12xx/main.c-
drivers/net/wireless/wl12xx/main.c-
drivers/net/wireless/wl12xx/main.c-
drivers/net/wireless/wl12xx/main.c-
drivers/net/wireless/wl12xx/main.c-
drivers/net/wireless/wl12xx/main.c-{
drivers/net/wireless/wl12xx/main.c-}
drivers/net/wireless/wl12xx/main.c-}
drivers/net/wireless/wl12xx/main.c-	}
drivers/net/wireless/wl12xx/main.c:	cancel_delayed_work_sync(&wl->elp_work);
drivers/net/wireless/wl12xx/main.c:	cancel_delayed_work_sync(&wl->elp_work);
drivers/net/wireless/wl12xx/main.c:	cancel_delayed_work_sync(&wl->scan_complete_work);
drivers/net/wireless/wl12xx/main.c:	cancel_delayed_work_sync(&wl->scan_complete_work);
drivers/net/wireless/wl12xx/main.c:	cancel_delayed_work_sync(&wl->tx_watchdog_work);
drivers/net/wireless/wl12xx/main.c:	cancel_delayed_work_sync(&wl->tx_watchdog_work);
drivers/net/wireless/wl12xx/main.c:	cancel_delayed_work(&wl->tx_watchdog_work);
drivers/net/wireless/wl12xx/main.c:			cancel_delayed_work(&wl->tx_watchdog_work);
drivers/net/wireless/wl12xx/main.c-	cancel_work_sync(&wl->netstack_work);
drivers/net/wireless/wl12xx/main.c-	cancel_work_sync(&wl->netstack_work);
drivers/net/wireless/wl12xx/main.c-	cancel_work_sync(&wl->recovery_work);
drivers/net/wireless/wl12xx/main.c-	cancel_work_sync(&wl->tx_work);
drivers/net/wireless/wl12xx/main.c:	dwork = container_of(work, struct delayed_work, work);
drivers/net/wireless/wl12xx/main.c-		else
drivers/net/wireless/wl12xx/main.c:	flush_delayed_work(&wl->elp_work);
drivers/net/wireless/wl12xx/main.c-	flush_work(&wl->tx_work);
drivers/net/wireless/wl12xx/main.c:	ieee80211_queue_delayed_work(wl->hw, &wl->tx_watchdog_work,
drivers/net/wireless/wl12xx/main.c-	/* let's notify MAC80211 about the remaining pending TX frames */
drivers/net/wireless/wl12xx/main.c-		msecs_to_jiffies(wl->conf.tx.tx_watchdog_timeout));
drivers/net/wireless/wl12xx/main.c-	mutex_lock(&wl->mutex);
drivers/net/wireless/wl12xx/main.c-	mutex_unlock(&wl->mutex);
drivers/net/wireless/wl12xx/main.c-		return;
drivers/net/wireless/wl12xx/main.c-	return 0;
drivers/net/wireless/wl12xx/main.c-static void wl12xx_tx_watchdog_work(struct work_struct *work)
drivers/net/wireless/wl12xx/main.c:	struct delayed_work *dwork;
drivers/net/wireless/wl12xx/main.c-	struct wl1271 *wl;
drivers/net/wireless/wl12xx/main.c-	wl1271_enable_interrupts(wl);
drivers/net/wireless/wl12xx/main.c-	wl1271_flush_deferred_work(wl);
drivers/net/wireless/wl12xx/main.c-			wl12xx_rearm_tx_watchdog_locked(wl);
drivers/net/wireless/wl12xx/main.c-	wl = container_of(dwork, struct wl1271, tx_watchdog_work);
drivers/net/wireless/wl12xx/ps.c-
drivers/net/wireless/wl12xx/ps.c-
drivers/net/wireless/wl12xx/ps.c-
drivers/net/wireless/wl12xx/ps.c-
drivers/net/wireless/wl12xx/ps.c-
drivers/net/wireless/wl12xx/ps.c-{
drivers/net/wireless/wl12xx/ps.c-}
drivers/net/wireless/wl12xx/ps.c-	}
drivers/net/wireless/wl12xx/ps.c:	cancel_delayed_work(&wl->elp_work);
drivers/net/wireless/wl12xx/ps.c-	/* don't cancel_sync as it might contend for a mutex and deadlock */
drivers/net/wireless/wl12xx/ps.c:	dwork = container_of(work, struct delayed_work, work);
drivers/net/wireless/wl12xx/ps.c:	ieee80211_queue_delayed_work(wl->hw, &wl->elp_work,
drivers/net/wireless/wl12xx/ps.c-	if (!test_bit(WL1271_FLAG_IN_ELP, &wl->flags))
drivers/net/wireless/wl12xx/ps.c-		msecs_to_jiffies(wl->conf.conn.dynamic_ps_timeout));
drivers/net/wireless/wl12xx/ps.c:	struct delayed_work *dwork;
drivers/net/wireless/wl12xx/ps.c-	struct wl1271 *wl;
drivers/net/wireless/wl12xx/ps.c-	struct wl12xx_vif *wlvif;
drivers/net/wireless/wl12xx/ps.c-void wl1271_elp_work(struct work_struct *work)
drivers/net/wireless/wl12xx/ps.c-	wl = container_of(dwork, struct wl1271, elp_work);
drivers/net/wireless/wl12xx/scan.c-
drivers/net/wireless/wl12xx/scan.c-
drivers/net/wireless/wl12xx/scan.c-
drivers/net/wireless/wl12xx/scan.c-
drivers/net/wireless/wl12xx/scan.c-{
drivers/net/wireless/wl12xx/scan.c-	}
drivers/net/wireless/wl12xx/scan.c-		break;
drivers/net/wireless/wl12xx/scan.c:		cancel_delayed_work(&wl->scan_complete_work);
drivers/net/wireless/wl12xx/scan.c:		cancel_delayed_work(&wl->scan_complete_work);
drivers/net/wireless/wl12xx/scan.c-	case WL1271_SCAN_STATE_DONE:
drivers/net/wireless/wl12xx/scan.c:	dwork = container_of(work, struct delayed_work, work);
drivers/net/wireless/wl12xx/scan.c:		ieee80211_queue_delayed_work(wl->hw, &wl->scan_complete_work,
drivers/net/wireless/wl12xx/scan.c:		ieee80211_queue_delayed_work(wl->hw, &wl->scan_complete_work,
drivers/net/wireless/wl12xx/scan.c:	ieee80211_queue_delayed_work(wl->hw, &wl->scan_complete_work,
drivers/net/wireless/wl12xx/scan.c-	if (ret < 0) {
drivers/net/wireless/wl12xx/scan.c-	int ret;
drivers/net/wireless/wl12xx/scan.c-					     msecs_to_jiffies(0));
drivers/net/wireless/wl12xx/scan.c-					     msecs_to_jiffies(0));
drivers/net/wireless/wl12xx/scan.c-				     msecs_to_jiffies(WL1271_SCAN_TIMEOUT));
drivers/net/wireless/wl12xx/scan.c:	struct delayed_work *dwork;
drivers/net/wireless/wl12xx/scan.c-	struct ieee80211_vif *vif;
drivers/net/wireless/wl12xx/scan.c-	struct wl1271 *wl;
drivers/net/wireless/wl12xx/scan.c-void wl1271_scan_complete_work(struct work_struct *work)
drivers/net/wireless/wl12xx/scan.c-	/* we assume failure so that timeout scenarios are handled correctly */
drivers/net/wireless/wl12xx/scan.c-	wl = container_of(dwork, struct wl1271, scan_complete_work);
drivers/net/wireless/wl12xx/scan.c-		wl->scan.failed = false;
drivers/net/wireless/wl12xx/scan.c-	wl->scan.failed = true;
drivers/net/wireless/zd1211rw/zd_mac.c-
drivers/net/wireless/zd1211rw/zd_mac.c-
drivers/net/wireless/zd1211rw/zd_mac.c-
drivers/net/wireless/zd1211rw/zd_mac.c-
drivers/net/wireless/zd1211rw/zd_mac.c-{
drivers/net/wireless/zd1211rw/zd_mac.c-{
drivers/net/wireless/zd1211rw/zd_mac.c-{
drivers/net/wireless/zd1211rw/zd_mac.c-}
drivers/net/wireless/zd1211rw/zd_mac.c-}
drivers/net/wireless/zd1211rw/zd_mac.c-}
drivers/net/wireless/zd1211rw/zd_mac.c-}
drivers/net/wireless/zd1211rw/zd_mac.c-}
drivers/net/wireless/zd1211rw/zd_mac.c-			   0);
drivers/net/wireless/zd1211rw/zd_mac.c-			   BEACON_WATCHDOG_DELAY);
drivers/net/wireless/zd1211rw/zd_mac.c-			   BEACON_WATCHDOG_DELAY);
drivers/net/wireless/zd1211rw/zd_mac.c:	cancel_delayed_work_sync(&mac->beacon.watchdog_work);
drivers/net/wireless/zd1211rw/zd_mac.c:	cancel_delayed_work_sync(&mac->housekeeping.link_led_work);
drivers/net/wireless/zd1211rw/zd_mac.c-	dev_dbg_f(zd_mac_dev(mac), "\n");
drivers/net/wireless/zd1211rw/zd_mac.c-	dev_dbg_f(zd_mac_dev(mac), "\n");
drivers/net/wireless/zd1211rw/zd_mac.c-	dev_dbg_f(zd_mac_dev(mac), "\n");
drivers/net/wireless/zd1211rw/zd_mac.c-		           LINK_LED_WORK_DELAY);
drivers/net/wireless/zd1211rw/zd_mac.c-	mac->beacon.last_update = jiffies;
drivers/net/wireless/zd1211rw/zd_mac.c:	queue_delayed_work(zd_workqueue, &mac->beacon.watchdog_work,
drivers/net/wireless/zd1211rw/zd_mac.c:	queue_delayed_work(zd_workqueue, &mac->beacon.watchdog_work,
drivers/net/wireless/zd1211rw/zd_mac.c:	queue_delayed_work(zd_workqueue, &mac->housekeeping.link_led_work,
drivers/net/wireless/zd1211rw/zd_mac.c:	queue_delayed_work(zd_workqueue, &mac->housekeeping.link_led_work,
drivers/net/wireless/zd1211rw/zd_mac.c-rearm:
drivers/net/wireless/zd1211rw/zd_mac.c-requeue:
drivers/net/wireless/zd1211rw/zd_mac.c-	zd_chip_control_leds(&mac->chip, ZD_LED_OFF);
drivers/net/wireless/zd1211rw/zd_mac.c-	zd_mac_free_cur_beacon(mac);
drivers/net/wireless/zd1211rw/zd_usb.c-
drivers/net/wireless/zd1211rw/zd_usb.c-
drivers/net/wireless/zd1211rw/zd_usb.c-
drivers/net/wireless/zd1211rw/zd_usb.c-
drivers/net/wireless/zd1211rw/zd_usb.c-}
drivers/net/wireless/zd1211rw/zd_usb.c-}
drivers/net/wireless/zd1211rw/zd_usb.c-}
drivers/net/wireless/zd1211rw/zd_usb.c-}
drivers/net/wireless/zd1211rw/zd_usb.c-	}
drivers/net/wireless/zd1211rw/zd_usb.c:	cancel_delayed_work_sync(&rx->idle_work);
drivers/net/wireless/zd1211rw/zd_usb.c:		cancel_delayed_work_sync(&tx->watchdog_work);
drivers/net/wireless/zd1211rw/zd_usb.c-		dev_dbg_f(zd_usb_dev(usb), "\n");
drivers/net/wireless/zd1211rw/zd_usb.c-		dev_dbg_f(zd_usb_dev(usb), "\n");
drivers/net/wireless/zd1211rw/zd_usb.c-	if (!tx->watchdog_enabled) {
drivers/net/wireless/zd1211rw/zd_usb.c:	mod_delayed_work(zd_workqueue, &rx->idle_work, ZD_RX_IDLE_INTERVAL);
drivers/net/wireless/zd1211rw/zd_usb.c-out:
drivers/net/wireless/zd1211rw/zd_usb.c:		queue_delayed_work(zd_workqueue, &tx->watchdog_work,
drivers/net/wireless/zd1211rw/zd_usb.c:	queue_delayed_work(zd_workqueue, &tx->watchdog_work,
drivers/net/wireless/zd1211rw/zd_usb.c-	return;
drivers/net/wireless/zd1211rw/zd_usb.c-	struct zd_usb_rx *rx = &usb->rx;
drivers/net/wireless/zd1211rw/zd_usb.c-	tasklet_kill(&rx->reset_timer_tasklet);
drivers/net/wireless/zd1211rw/zd_usb.c-		tx->watchdog_enabled = 0;
drivers/net/wireless/zd1211rw/zd_usb.c-		tx->watchdog_enabled = 1;
drivers/net/wireless/zd1211rw/zd_usb.c-			   ZD_TX_WATCHDOG_INTERVAL);
drivers/net/wireless/zd1211rw/zd_usb.c-				   ZD_TX_WATCHDOG_INTERVAL);
drivers/oprofile/cpu_buffer.c-
drivers/oprofile/cpu_buffer.c-}
drivers/oprofile/cpu_buffer.c-}
drivers/oprofile/cpu_buffer.c-}
drivers/oprofile/cpu_buffer.c- *
drivers/oprofile/cpu_buffer.c- */
drivers/oprofile/cpu_buffer.c-	}
drivers/oprofile/cpu_buffer.c-	}
drivers/oprofile/cpu_buffer.c-	}
drivers/oprofile/cpu_buffer.c-		 */
drivers/oprofile/cpu_buffer.c: * By using schedule_delayed_work_on and then schedule_delayed_work
drivers/oprofile/cpu_buffer.c:		cancel_delayed_work(&b->work);
drivers/oprofile/cpu_buffer.c-		container_of(work, struct oprofile_cpu_buffer, work.work);
drivers/oprofile/cpu_buffer.c-	/* don't re-add the work if we're shutting down */
drivers/oprofile/cpu_buffer.c-		 * fire at once.
drivers/oprofile/cpu_buffer.c:		flush_delayed_work(&b->work);
drivers/oprofile/cpu_buffer.c-	if (b->cpu != smp_processor_id() && !cpu_online(b->cpu)) {
drivers/oprofile/cpu_buffer.c-	if (work_enabled)
drivers/oprofile/cpu_buffer.c-		return;
drivers/oprofile/cpu_buffer.c:		schedule_delayed_work(&b->work, DEFAULT_TIMER_EXPIRE);
drivers/oprofile/cpu_buffer.c:		schedule_delayed_work_on(i, &b->work, DEFAULT_TIMER_EXPIRE + i);
drivers/oprofile/cpu_buffer.c-		/* these works are per-cpu, no need for flush_sync */
drivers/oprofile/cpu_buffer.c- * the task mortuary progresses
drivers/oprofile/cpu_buffer.c- * we guarantee this will stay on the correct cpu
drivers/oprofile/oprof.c-
drivers/oprofile/oprof.c-
drivers/oprofile/oprof.c-{
drivers/oprofile/oprof.c-{
drivers/oprofile/oprof.c-}
drivers/oprofile/oprof.c-}
drivers/oprofile/oprof.c:	cancel_delayed_work_sync(&switch_work);
drivers/oprofile/oprof.c-	if (oprofile_ops.switch_events)
drivers/oprofile/oprof.c:		schedule_delayed_work(&switch_work, oprofile_time_slice);
drivers/oprofile/oprof.c-static void stop_switch_worker(void)
drivers/parisc/led.c-
drivers/parisc/led.c-
drivers/parisc/led.c-
drivers/parisc/led.c-
drivers/parisc/led.c-
drivers/parisc/led.c-
drivers/parisc/led.c-}
drivers/parisc/led.c-	}
drivers/parisc/led.c-	}
drivers/parisc/led.c-	}
drivers/parisc/led.c:		cancel_delayed_work_sync(&led_task);
drivers/parisc/led.c:		cancel_delayed_work_sync(&led_task);
drivers/parisc/led.c-	/* Cancel the work item and delete the queue */
drivers/parisc/led.c-	/* copy display string to buffer for procfs */
drivers/parisc/led.c-	/* Create the work queue and queue the LED task */
drivers/parisc/led.c-		destroy_workqueue(led_wq);
drivers/parisc/led.c-	/* Ensure the work is queued */
drivers/parisc/led.c-	if (led_wq)
drivers/parisc/led.c-	if (led_wq) {
drivers/parisc/led.c-	if (led_wq) {
drivers/parisc/led.c-	if (led_wq) {
drivers/parisc/led.c-	led_wq = create_singlethread_workqueue("led_wq");	
drivers/parisc/led.c-		led_wq = NULL;
drivers/parisc/led.c:		queue_delayed_work(led_wq, &led_task, 0);
drivers/parisc/led.c:		queue_delayed_work(led_wq, &led_task, 0);
drivers/parisc/led.c:	queue_delayed_work(led_wq, &led_task, 0);
drivers/parisc/led.c:	queue_delayed_work(led_wq, &led_task, LED_UPDATE_INTERVAL);
drivers/parisc/led.c-	/* re-queue the work */
drivers/parisc/led.c-	return 0;
drivers/parisc/led.c-	/* temporarily disable the led work task */
drivers/pci/hotplug/pciehp_ctrl.c-
drivers/pci/hotplug/pciehp_ctrl.c-		 */
drivers/pci/hotplug/pciehp_ctrl.c-		break;
drivers/pci/hotplug/pciehp_ctrl.c:		cancel_delayed_work(&p_slot->work);
drivers/pci/hotplug/pciehp_ctrl.c:		cancel_delayed_work(&p_slot->work);
drivers/pci/hotplug/pciehp_ctrl.c:		cancel_delayed_work(&p_slot->work);
drivers/pci/hotplug/pciehp_ctrl.c-	case BLINKINGOFF_STATE:
drivers/pci/hotplug/pciehp_ctrl.c-	case BLINKINGOFF_STATE:
drivers/pci/hotplug/pciehp_ctrl.c-	case BLINKINGON_STATE:
drivers/pci/hotplug/pciehp_ctrl.c-	case STATIC_STATE:
drivers/pci/hotplug/pciehp_ctrl.c-	case STATIC_STATE:
drivers/pci/hotplug/pciehp_ctrl.c-		ctrl_info(ctrl, "Button cancel on Slot(%s)\n", slot_name(p_slot));
drivers/pci/hotplug/pciehp_ctrl.c-		if (p_slot->state == BLINKINGOFF_STATE) {
drivers/pci/hotplug/pciehp_ctrl.c-			if (PWR_LED(ctrl))
drivers/pci/hotplug/pciehp_ctrl.c-			pciehp_set_attention_status(p_slot, 0);
drivers/pci/hotplug/pciehp_ctrl.c-		p_slot->state = POWEROFF_STATE;
drivers/pci/hotplug/pciehp_ctrl.c-		p_slot->state = POWERON_STATE;
drivers/pci/hotplug/pciehp_ctrl.c:		queue_delayed_work(p_slot->wq, &p_slot->work, 5*HZ);
drivers/pci/hotplug/pciehp_ctrl.c-	switch (p_slot->state) {
drivers/pci/hotplug/pciehp_ctrl.c-	switch (p_slot->state) {
drivers/pci/hotplug/shpchp_ctrl.c-
drivers/pci/hotplug/shpchp_ctrl.c-		break;
drivers/pci/hotplug/shpchp_ctrl.c:		cancel_delayed_work(&p_slot->work);
drivers/pci/hotplug/shpchp_ctrl.c:		cancel_delayed_work(&p_slot->work);
drivers/pci/hotplug/shpchp_ctrl.c:		cancel_delayed_work(&p_slot->work);
drivers/pci/hotplug/shpchp_ctrl.c-	case BLINKINGOFF_STATE:
drivers/pci/hotplug/shpchp_ctrl.c-	case BLINKINGOFF_STATE:
drivers/pci/hotplug/shpchp_ctrl.c-	case BLINKINGON_STATE:
drivers/pci/hotplug/shpchp_ctrl.c-	case STATIC_STATE:
drivers/pci/hotplug/shpchp_ctrl.c-	case STATIC_STATE:
drivers/pci/hotplug/shpchp_ctrl.c-		ctrl_info(ctrl, "Button cancel on Slot(%s)\n",
drivers/pci/hotplug/shpchp_ctrl.c-		if (p_slot->state == BLINKINGOFF_STATE)
drivers/pci/hotplug/shpchp_ctrl.c-			p_slot->hpc_ops->green_led_on(p_slot);
drivers/pci/hotplug/shpchp_ctrl.c-		p_slot->hpc_ops->set_attention_status(p_slot, 0);
drivers/pci/hotplug/shpchp_ctrl.c-		p_slot->state = POWEROFF_STATE;
drivers/pci/hotplug/shpchp_ctrl.c-		p_slot->state = POWERON_STATE;
drivers/pci/hotplug/shpchp_ctrl.c:		queue_delayed_work(p_slot->wq, &p_slot->work, 5*HZ);
drivers/pci/hotplug/shpchp_ctrl.c-			  slot_name(p_slot));
drivers/pci/hotplug/shpchp_ctrl.c-	switch (p_slot->state) {
drivers/pci/hotplug/shpchp_ctrl.c-	switch (p_slot->state) {
drivers/pci/pci.c-	}
drivers/pci/pci.c-		}
drivers/pci/pci.c-		if (!list_empty(&pci_pme_list))
drivers/pci/pci.c-			if (list_is_singular(&pci_pme_list))
drivers/pci/pci.c-			list_add(&pme_dev->list, &pci_pme_list);
drivers/pci/pci.c-					      msecs_to_jiffies(PME_TIMEOUT));
drivers/pci/pci.c-						      msecs_to_jiffies(PME_TIMEOUT));
drivers/pci/pci.c-			mutex_unlock(&pci_pme_list_mutex);
drivers/pci/pci.c:			schedule_delayed_work(&pci_pme_work,
drivers/pci/pci.c:				schedule_delayed_work(&pci_pme_work,
drivers/platform/msm/ipa/ipa.c-
drivers/platform/msm/ipa/ipa.c-
drivers/platform/msm/ipa/ipa.c-{
drivers/platform/msm/ipa/ipa.c-	}
drivers/platform/msm/ipa/ipa.c-		}
drivers/platform/msm/ipa/ipa.c:	cancel_delayed_work(&ipa_ctx->poll_work);
drivers/platform/msm/ipa/ipa.c-fail_data_out:
drivers/platform/msm/ipa/ipa.c:fail_schedule_delayed_work:
drivers/platform/msm/ipa/ipa.c:			goto fail_schedule_delayed_work;
drivers/platform/msm/ipa/ipa.c-		if (!result) {
drivers/platform/msm/ipa/ipa.c-		INIT_DELAYED_WORK(&ipa_ctx->poll_work, ipa_poll_function);
drivers/platform/msm/ipa/ipa.c-	INIT_DELAYED_WORK(&ipa_ctx->poll_work, ipa_poll_function);
drivers/platform/msm/ipa/ipa.c-					&ipa_ctx->poll_work,
drivers/platform/msm/ipa/ipa.c-			IPAERR(":schedule delayed work failed.\n");
drivers/platform/msm/ipa/ipa.c-	ipa_teardown_sys_pipe(ipa_ctx->clnt_hdl_data_in);
drivers/platform/msm/ipa/ipa.c-	ipa_teardown_sys_pipe(ipa_ctx->clnt_hdl_data_out);
drivers/platform/msm/ipa/ipa.c-	ipa_teardown_sys_pipe(ipa_ctx->clnt_hdl_data_out);
drivers/platform/msm/ipa/ipa.c-			msecs_to_jiffies(polling_delay_ms));
drivers/platform/msm/ipa/ipa.c-					msecs_to_jiffies(polling_delay_ms));
drivers/platform/msm/ipa/ipa.c-	/* re-post the poll work */
drivers/platform/msm/ipa/ipa.c-		result =
drivers/platform/msm/ipa/ipa.c:	ret = schedule_delayed_work_on(smp_processor_id(), &ipa_ctx->poll_work,
drivers/platform/msm/ipa/ipa.c-	return 0;
drivers/platform/msm/ipa/ipa.c:		   schedule_delayed_work_on(smp_processor_id(),
drivers/platform/msm/ipa/ipa.c-static void ipa_teardown_a5_pipes(void)
drivers/platform/msm/qpnp-power-on.c-
drivers/platform/msm/qpnp-power-on.c-
drivers/platform/msm/qpnp-power-on.c-
drivers/platform/msm/qpnp-power-on.c-
drivers/platform/msm/qpnp-power-on.c-};
drivers/platform/msm/qpnp-power-on.c-	}
drivers/platform/msm/qpnp-power-on.c-		}
drivers/platform/msm/qpnp-power-on.c:	cancel_delayed_work_sync(&pon->bark_work);
drivers/platform/msm/qpnp-power-on.c-err_exit:
drivers/platform/msm/qpnp-power-on.c-	if (pon->pon_input)
drivers/platform/msm/qpnp-power-on.c-	input_sync(pon->pon_input);
drivers/platform/msm/qpnp-power-on.c-	int num_pon_config;
drivers/platform/msm/qpnp-power-on.c-		/* re-arm the work */
drivers/platform/msm/qpnp-power-on.c-	return IRQ_HANDLED;
drivers/platform/msm/qpnp-power-on.c:		schedule_delayed_work(&pon->bark_work, QPNP_KEY_STATUS_DELAY);
drivers/platform/msm/qpnp-power-on.c:	schedule_delayed_work(&pon->bark_work, QPNP_KEY_STATUS_DELAY);
drivers/platform/msm/qpnp-power-on.c-	/* schedule work to check the bark status for key-release */
drivers/platform/msm/qpnp-power-on.c:	struct delayed_work bark_work;
drivers/platform/msm/qpnp-power-on.c-	struct qpnp_pon *pon = dev_get_drvdata(&spmi->dev);
drivers/platform/msm/qpnp-power-on.c-	u16 base;
drivers/platform/x86/acer-wmi.c-
drivers/platform/x86/acer-wmi.c-
drivers/platform/x86/acer-wmi.c-
drivers/platform/x86/acer-wmi.c-
drivers/platform/x86/acer-wmi.c-}
drivers/platform/x86/acer-wmi.c-	}
drivers/platform/x86/acer-wmi.c:		cancel_delayed_work_sync(&acer_rfkill_work);
drivers/platform/x86/acer-wmi.c-	    has_cap(ACER_CAP_WIRELESS | ACER_CAP_BLUETOOTH | ACER_CAP_THREEG))
drivers/platform/x86/acer-wmi.c-	    has_cap(ACER_CAP_WIRELESS | ACER_CAP_BLUETOOTH | ACER_CAP_THREEG))
drivers/platform/x86/acer-wmi.c-	if ((ec_raw_mode || !wmi_has_guid(ACERWMID_EVENT_GUID)) &&
drivers/platform/x86/acer-wmi.c-	if ((ec_raw_mode || !wmi_has_guid(ACERWMID_EVENT_GUID)) &&
drivers/platform/x86/acer-wmi.c-	if (has_cap(ACER_CAP_WIRELESS)) {
drivers/platform/x86/acer-wmi.c-			round_jiffies_relative(HZ));
drivers/platform/x86/acer-wmi.c:		schedule_delayed_work(&acer_rfkill_work,
drivers/platform/x86/acer-wmi.c:	schedule_delayed_work(&acer_rfkill_work, round_jiffies_relative(HZ));
drivers/platform/x86/dell-laptop.c-	backlight_device_unregister(dell_backlight_device);
drivers/platform/x86/dell-laptop.c-			break;
drivers/platform/x86/dell-laptop.c:	cancel_delayed_work_sync(&dell_rfkill_work);
drivers/platform/x86/dell-laptop.c:	cancel_delayed_work_sync(&dell_rfkill_work);
drivers/platform/x86/dell-laptop.c-		case 0x8:
drivers/platform/x86/dell-laptop.c-	dell_cleanup_rfkill();
drivers/platform/x86/dell-laptop.c-	dell_cleanup_rfkill();
drivers/platform/x86/dell-laptop.c-fail_backlight:
drivers/platform/x86/dell-laptop.c-fail_filter:
drivers/platform/x86/dell-laptop.c-	i8042_remove_filter(dell_laptop_i8042_filter);
drivers/platform/x86/dell-laptop.c-	i8042_remove_filter(dell_laptop_i8042_filter);
drivers/platform/x86/dell-laptop.c-					      round_jiffies_relative(HZ));
drivers/platform/x86/dell-laptop.c:			schedule_delayed_work(&dell_rfkill_work,
drivers/platform/x86/dell-laptop.c-		switch (data) {
drivers/platform/x86/dell-laptop.c-		touchpad_led_exit();
drivers/platform/x86/msi-laptop.c-
drivers/platform/x86/msi-laptop.c-
drivers/platform/x86/msi-laptop.c-	}
drivers/platform/x86/msi-laptop.c-	}
drivers/platform/x86/msi-laptop.c-			break;
drivers/platform/x86/msi-laptop.c-			break;
drivers/platform/x86/msi-laptop.c:		cancel_delayed_work_sync(&msi_rfkill_work);
drivers/platform/x86/msi-laptop.c:		cancel_delayed_work_sync(&msi_rfkill_work);
drivers/platform/x86/msi-laptop.c-		case 0x62:
drivers/platform/x86/msi-laptop.c-		case 0x76:
drivers/platform/x86/msi-laptop.c-		case 0xE4:
drivers/platform/x86/msi-laptop.c-		i8042_remove_filter(msi_laptop_i8042_filter);
drivers/platform/x86/msi-laptop.c-		i8042_remove_filter(msi_laptop_i8042_filter);
drivers/platform/x86/msi-laptop.c-	if (load_scm_model) {
drivers/platform/x86/msi-laptop.c-		msi_laptop_input_destroy();
drivers/platform/x86/msi-laptop.c-		rfkill_cleanup();
drivers/platform/x86/msi-laptop.c-		rfkill_cleanup();
drivers/platform/x86/msi-laptop.c-				round_jiffies_relative(0.5 * HZ));
drivers/platform/x86/msi-laptop.c-				round_jiffies_relative(0.5 * HZ));
drivers/platform/x86/msi-laptop.c-				round_jiffies_relative(1 * HZ));
drivers/platform/x86/msi-laptop.c:	schedule_delayed_work(&msi_rfkill_init,
drivers/platform/x86/msi-laptop.c:			schedule_delayed_work(&msi_rfkill_work,
drivers/platform/x86/msi-laptop.c:			schedule_delayed_work(&msi_touchpad_work,
drivers/platform/x86/msi-laptop.c-	/* schedule to run rfkill state initial */
drivers/platform/x86/msi-laptop.c-		switch (data) {
drivers/platform/x86/thinkpad_acpi.c-
drivers/platform/x86/thinkpad_acpi.c-
drivers/platform/x86/thinkpad_acpi.c-}
drivers/platform/x86/thinkpad_acpi.c-}
drivers/platform/x86/thinkpad_acpi.c:	cancel_delayed_work(&fan_watchdog_task);
drivers/platform/x86/thinkpad_acpi.c:		cancel_delayed_work(&fan_watchdog_task);
drivers/platform/x86/thinkpad_acpi.c-			   &driver_attr_fan_watchdog);
drivers/platform/x86/thinkpad_acpi.c-	else
drivers/platform/x86/thinkpad_acpi.c-	flush_workqueue(tpacpi_wq);
drivers/platform/x86/thinkpad_acpi.c-	if (fan_watchdog_maxinterval > 0 &&
drivers/platform/x86/thinkpad_acpi.c:		mod_delayed_work(tpacpi_wq, &fan_watchdog_task,
drivers/platform/x86/thinkpad_acpi.c-			msecs_to_jiffies(fan_watchdog_maxinterval * 1000));
drivers/platform/x86/thinkpad_acpi.c-	    tpacpi_lifecycle != TPACPI_LIFE_EXITING)
drivers/power/ab8500_btemp.c-
drivers/power/ab8500_btemp.c-
drivers/power/ab8500_btemp.c-
drivers/power/ab8500_btemp.c-
drivers/power/ab8500_btemp.c-}
drivers/power/ab8500_btemp.c-};
drivers/power/ab8500_btemp.c-	 */
drivers/power/ab8500_btemp.c-	 * any pending work
drivers/power/ab8500_btemp.c:	cancel_delayed_work_sync(&di->btemp_periodic_work);
drivers/power/ab8500_btemp.c-		&di->btemp_periodic_work,
drivers/power/ab8500_btemp.c-	if (enable)
drivers/power/ab8500_btemp.c:	queue_delayed_work(di->btemp_wq,
drivers/power/ab8500_btemp.c:		queue_delayed_work(di->btemp_wq, &di->btemp_periodic_work, 0);
drivers/power/ab8500_btemp.c-		round_jiffies(interval * HZ));
drivers/power/ab8500_btemp.c-	/* Schedule a new measurement */
drivers/power/ab8500_btemp.c-	struct ab8500_btemp_ranges btemp_ranges;
drivers/power/ab8500_btemp.c:	struct delayed_work btemp_periodic_work;
drivers/power/ab8500_btemp.c-	struct workqueue_struct *btemp_wq;
drivers/power/ab8500_charger.c-
drivers/power/ab8500_charger.c-
drivers/power/ab8500_charger.c-
drivers/power/ab8500_charger.c-
drivers/power/ab8500_charger.c-
drivers/power/ab8500_charger.c-
drivers/power/ab8500_charger.c-
drivers/power/ab8500_charger.c-
drivers/power/ab8500_charger.c-
drivers/power/ab8500_charger.c-
drivers/power/ab8500_charger.c-
drivers/power/ab8500_charger.c-
drivers/power/ab8500_charger.c-
drivers/power/ab8500_charger.c-
drivers/power/ab8500_charger.c-
drivers/power/ab8500_charger.c-
drivers/power/ab8500_charger.c-}
drivers/power/ab8500_charger.c-}
drivers/power/ab8500_charger.c-	}
drivers/power/ab8500_charger.c-	}
drivers/power/ab8500_charger.c-	}
drivers/power/ab8500_charger.c-		}
drivers/power/ab8500_charger.c-			 */
drivers/power/ab8500_charger.c-	/* Cancel any pending HW failure check */
drivers/power/ab8500_charger.c-		/* Cancel any pending Vbat check work */
drivers/power/ab8500_charger.c:		cancel_delayed_work(&di->check_hw_failure_work);
drivers/power/ab8500_charger.c:			cancel_delayed_work(&di->check_vbat_work);
drivers/power/ab8500_charger.c-		/* Check again in 1sec */
drivers/power/ab8500_charger.c-	dev_dbg(di->dev, "Not allowed USB charger detected\n");
drivers/power/ab8500_charger.c-			dev_err(di->dev, "failed to enable LED\n");
drivers/power/ab8500_charger.c-			&di->check_hw_failure_work, 0);
drivers/power/ab8500_charger.c-			&di->check_hw_failure_work, round_jiffies(HZ));
drivers/power/ab8500_charger.c-			&di->check_usbchgnotok_work, HZ);
drivers/power/ab8500_charger.c-		di->flags.usbchargernotok = true;
drivers/power/ab8500_charger.c-					&di->kick_wd_work,
drivers/power/ab8500_charger.c-			&di->kick_wd_work)) {
drivers/power/ab8500_charger.c-		&di->kick_wd_work, round_jiffies(WD_KICK_INTERVAL));
drivers/power/ab8500_charger.c-		di->usb.charger_online = 1;
drivers/power/ab8500_charger.c-	} else {
drivers/power/ab8500_charger.c:		if (!delayed_work_pending(
drivers/power/ab8500_charger.c:	if (delayed_work_pending(&di->check_hw_failure_work))
drivers/power/ab8500_charger.c:		if (delayed_work_pending(&di->check_vbat_work))
drivers/power/ab8500_charger.c-			if (di->ac_conn) {
drivers/power/ab8500_charger.c-	if (di->flags.mainextchnotok || di->flags.vbus_ovv) {
drivers/power/ab8500_charger.c-	if (di->flags.mainextchnotok || di->flags.vbus_ovv) {
drivers/power/ab8500_charger.c-		/* If not already pending start a new timer */
drivers/power/ab8500_charger.c-	/* If we still have a failure, schedule a new check */
drivers/power/ab8500_charger.c-	/* If we still have a HW failure, schedule a new check */
drivers/power/ab8500_charger.c:	queue_delayed_work(di->charger_wq,
drivers/power/ab8500_charger.c:		queue_delayed_work(di->charger_wq,
drivers/power/ab8500_charger.c:		queue_delayed_work(di->charger_wq,
drivers/power/ab8500_charger.c:		queue_delayed_work(di->charger_wq,
drivers/power/ab8500_charger.c:				queue_delayed_work(di->charger_wq,
drivers/power/ab8500_charger.c:	queue_delayed_work(di->charger_wq, &di->check_hw_failure_work, 0);
drivers/power/ab8500_charger.c:	queue_delayed_work(di->charger_wq, &di->check_hw_failure_work, 0);
drivers/power/ab8500_charger.c:	queue_delayed_work(di->charger_wq, &di->check_usbchgnotok_work, 0);
drivers/power/ab8500_charger.c:		queue_delayed_work(di->charger_wq, &di->check_vbat_work, HZ);
drivers/power/ab8500_charger.c:	queue_delayed_work(di->charger_wq, &di->check_vbat_work, t * HZ);
drivers/power/ab8500_charger.c:			queue_delayed_work(di->charger_wq, &di->kick_wd_work,
drivers/power/ab8500_charger.c-	return 0;
drivers/power/ab8500_charger.c-	return IRQ_HANDLED;
drivers/power/ab8500_charger.c-	return IRQ_HANDLED;
drivers/power/ab8500_charger.c-	return IRQ_HANDLED;
drivers/power/ab8500_charger.c-				round_jiffies(WD_KICK_INTERVAL));
drivers/power/ab8500_charger.c-					round_jiffies(WD_KICK_INTERVAL));
drivers/power/ab8500_charger.c-	/* Schedule a new HW failure check */
drivers/power/ab8500_charger.c-	/* Schedule a new HW failure check */
drivers/power/ab8500_charger.c-	/* Schedule a new watchdog kick */
drivers/power/ab8500_charger.c:	struct delayed_work check_hw_failure_work;
drivers/power/ab8500_charger.c:	struct delayed_work check_usbchgnotok_work;
drivers/power/ab8500_charger.c:	struct delayed_work check_vbat_work;
drivers/power/ab8500_charger.c:	struct delayed_work kick_wd_work;
drivers/power/ab8500_charger.c-	struct regulator *regu;
drivers/power/ab8500_charger.c-	struct workqueue_struct *charger_wq;
drivers/power/ab8500_charger.c-	struct work_struct ac_work;
drivers/power/ab8500_charger.c-	struct work_struct detect_usb_type_work;
drivers/power/ab8500_charger.c-			t = 1;
drivers/power/ab8500_fg.c-
drivers/power/ab8500_fg.c-
drivers/power/ab8500_fg.c-
drivers/power/ab8500_fg.c-
drivers/power/ab8500_fg.c-
drivers/power/ab8500_fg.c-
drivers/power/ab8500_fg.c-
drivers/power/ab8500_fg.c-
drivers/power/ab8500_fg.c-
drivers/power/ab8500_fg.c-
drivers/power/ab8500_fg.c-
drivers/power/ab8500_fg.c-
drivers/power/ab8500_fg.c-
drivers/power/ab8500_fg.c-}
drivers/power/ab8500_fg.c-}
drivers/power/ab8500_fg.c-}
drivers/power/ab8500_fg.c-	/*
drivers/power/ab8500_fg.c-	}
drivers/power/ab8500_fg.c-	}
drivers/power/ab8500_fg.c-	}
drivers/power/ab8500_fg.c-	}
drivers/power/ab8500_fg.c-		}
drivers/power/ab8500_fg.c-		 */
drivers/power/ab8500_fg.c-		 */
drivers/power/ab8500_fg.c-		ab8500_fg_algorithm(di);
drivers/power/ab8500_fg.c-		ab8500_fg_charge_state_to(di, AB8500_FG_CHARGE_INIT);
drivers/power/ab8500_fg.c-					AB8500_FG_DISCHARGE_RECOVERY);
drivers/power/ab8500_fg.c-		ab8500_fg_discharge_state_to(di, AB8500_FG_DISCHARGE_INIT);
drivers/power/ab8500_fg.c-		break;
drivers/power/ab8500_fg.c-	case AB8500_FG_CALIB_WAIT:
drivers/power/ab8500_fg.c-		dev_dbg(di->dev, "Calibration done...\n");
drivers/power/ab8500_fg.c-	di->calib_state = AB8500_FG_CALIB_END;
drivers/power/ab8500_fg.c-	di->calib_state = AB8500_FG_CALIB_INIT;
drivers/power/ab8500_fg.c-					&di->fg_periodic_work,
drivers/power/ab8500_fg.c-					&di->fg_periodic_work, 0);
drivers/power/ab8500_fg.c-		di->flags.calibrate = false;
drivers/power/ab8500_fg.c-	di->flags.calibrate = false;
drivers/power/ab8500_fg.c-		di->flags.user_cap = false;
drivers/power/ab8500_fg.c-		di->flags.user_cap = true;
drivers/power/ab8500_fg.c-		di->init_capacity = false;
drivers/power/ab8500_fg.c-				di->recovery_needed = false;
drivers/power/ab8500_fg.c-	} else
drivers/power/ab8500_fg.c-	} else {
drivers/power/ab8500_fg.c-	} else {
drivers/power/ab8500_fg.c-			} else {
drivers/power/ab8500_fg.c-	} else if (di->flags.user_cap) {
drivers/power/ab8500_fg.c:	flush_delayed_work(&di->fg_periodic_work);
drivers/power/ab8500_fg.c-		if (check_sysfs_capacity(di)) {
drivers/power/ab8500_fg.c-	if (di != NULL)
drivers/power/ab8500_fg.c-		 * if the voltage increases again during charging
drivers/power/ab8500_fg.c-	list_add_tail(&di->node, &ab8500_fg_list);
drivers/power/ab8500_fg.c-		/* Not yet recovered from ovv, reschedule this test */
drivers/power/ab8500_fg.c:				queue_delayed_work(di->fg_wq,
drivers/power/ab8500_fg.c:				queue_delayed_work(di->fg_wq,
drivers/power/ab8500_fg.c:		queue_delayed_work(di->fg_wq, &di->fg_check_hw_failure_work,
drivers/power/ab8500_fg.c:	queue_delayed_work(di->fg_wq, &di->fg_check_hw_failure_work, 0);
drivers/power/ab8500_fg.c:		queue_delayed_work(di->fg_wq, &di->fg_low_bat_work,
drivers/power/ab8500_fg.c:		queue_delayed_work(di->fg_wq, &di->fg_low_bat_work,
drivers/power/ab8500_fg.c:		queue_delayed_work(di->fg_wq, &di->fg_periodic_work, 0);
drivers/power/ab8500_fg.c:		queue_delayed_work(di->fg_wq, &di->fg_periodic_work, 0);
drivers/power/ab8500_fg.c:		queue_delayed_work(di->fg_wq, &di->fg_periodic_work, 0);
drivers/power/ab8500_fg.c:		queue_delayed_work(di->fg_wq, &di->fg_periodic_work, 0);
drivers/power/ab8500_fg.c:		queue_delayed_work(di->fg_wq, &di->fg_periodic_work, 0);
drivers/power/ab8500_fg.c:	queue_delayed_work(di->fg_wq, &di->fg_periodic_work, 0);
drivers/power/ab8500_fg.c:	queue_delayed_work(di->fg_wq, &di->fg_periodic_work, 0);
drivers/power/ab8500_fg.c:	queue_delayed_work(di->fg_wq, &di->fg_periodic_work, 0);
drivers/power/ab8500_fg.c:		queue_delayed_work(di->fg_wq, &di->fg_reinit_work,
drivers/power/ab8500_fg.c:		queue_delayed_work(di->fg_wq, &di->fg_reinit_work, 0);
drivers/power/ab8500_fg.c-		ret = count;
drivers/power/ab8500_fg.c-			"retrying..\n");
drivers/power/ab8500_fg.c-	return IRQ_HANDLED;
drivers/power/ab8500_fg.c-	return IRQ_HANDLED;
drivers/power/ab8500_fg.c-	return ret;
drivers/power/ab8500_fg.c-			round_jiffies(1));
drivers/power/ab8500_fg.c-				   round_jiffies(HZ));
drivers/power/ab8500_fg.c-			round_jiffies(LOW_BAT_CHECK_INTERVAL));
drivers/power/ab8500_fg.c-			round_jiffies(LOW_BAT_CHECK_INTERVAL));
drivers/power/ab8500_fg.c-	/* Run the FG algorithm */
drivers/power/ab8500_fg.c-	/* Schedule a new HW failure check */
drivers/power/ab8500_fg.c-					sleep_time * HZ);
drivers/power/ab8500_fg.c-	struct ab8500_fg *di = _di;
drivers/power/ab8500_fg.c-	struct ab8500_fg *di = platform_get_drvdata(pdev);
drivers/power/ab8500_fg.c:	struct delayed_work fg_check_hw_failure_work;
drivers/power/ab8500_fg.c:	struct delayed_work fg_low_bat_work;
drivers/power/ab8500_fg.c:	struct delayed_work fg_periodic_work;
drivers/power/ab8500_fg.c:	struct delayed_work fg_reinit_work;
drivers/power/ab8500_fg.c-	struct kobject fg_kobject;
drivers/power/ab8500_fg.c-	struct mutex cc_lock;
drivers/power/ab8500_fg.c-	struct power_supply fg_psy;
drivers/power/ab8500_fg.c-	struct workqueue_struct *fg_wq;
drivers/power/ab8500_fg.c-	struct work_struct fg_acc_cur_work;
drivers/power/ab8500_fg.c-	struct work_struct fg_work;
drivers/power/ab8500_fg.c-		 * This is done to avoid shutdown on single voltage dips
drivers/power/ab8500_fg.c-	/* User won't be notified if a null pointer returned. */
drivers/power/ab8500_fg.c-		/* Wait one second until next try*/
drivers/power/abx500_chargalg.c-
drivers/power/abx500_chargalg.c-
drivers/power/abx500_chargalg.c-
drivers/power/abx500_chargalg.c-
drivers/power/abx500_chargalg.c-
drivers/power/abx500_chargalg.c-
drivers/power/abx500_chargalg.c-
drivers/power/abx500_chargalg.c-
drivers/power/abx500_chargalg.c-}
drivers/power/abx500_chargalg.c-}
drivers/power/abx500_chargalg.c-}
drivers/power/abx500_chargalg.c-	/*
drivers/power/abx500_chargalg.c-	 */
drivers/power/abx500_chargalg.c-	 */
drivers/power/abx500_chargalg.c-				}
drivers/power/abx500_chargalg.c-				}
drivers/power/abx500_chargalg.c:	cancel_delayed_work(&di->chargalg_wd_work);
drivers/power/abx500_chargalg.c:	cancel_delayed_work(&di->chargalg_wd_work);
drivers/power/abx500_chargalg.c:	cancel_delayed_work_sync(&di->chargalg_periodic_work);
drivers/power/abx500_chargalg.c:		cancel_delayed_work_sync(&di->chargalg_wd_work);
drivers/power/abx500_chargalg.c-		dev_err(di->dev, "failed to kick watchdog\n");
drivers/power/abx500_chargalg.c-	dev_info(di->dev, "probe success\n");
drivers/power/abx500_chargalg.c-			di->bat->interval_charging * HZ);
drivers/power/abx500_chargalg.c-			di->bat->interval_not_charging * HZ);
drivers/power/abx500_chargalg.c-			&di->chargalg_periodic_work,
drivers/power/abx500_chargalg.c-			&di->chargalg_periodic_work,
drivers/power/abx500_chargalg.c-						&di->chargalg_wd_work, 0);
drivers/power/abx500_chargalg.c-						&di->chargalg_wd_work, 0);
drivers/power/abx500_chargalg.c-		&di->chargalg_wd_work, CHG_WD_INTERVAL);
drivers/power/abx500_chargalg.c-	di->charge_status = POWER_SUPPLY_STATUS_CHARGING;
drivers/power/abx500_chargalg.c-	di->charge_status = POWER_SUPPLY_STATUS_NOT_CHARGING;
drivers/power/abx500_chargalg.c-						di->chg_info.online_chg;
drivers/power/abx500_chargalg.c-						di->chg_info.online_chg;
drivers/power/abx500_chargalg.c-					di->chg_info.online_chg |= AC_CHG;
drivers/power/abx500_chargalg.c-					di->chg_info.online_chg |= USB_CHG;
drivers/power/abx500_chargalg.c-	di->maintenance_chg = false;
drivers/power/abx500_chargalg.c-	di->maintenance_chg = false;
drivers/power/abx500_chargalg.c-	 * do it too seldom
drivers/power/abx500_chargalg.c-	else
drivers/power/abx500_chargalg.c-	if (di->chg_info.conn_chg)
drivers/power/abx500_chargalg.c-	if (di->chg_info.online_chg)
drivers/power/abx500_chargalg.c-	if (di->chg_info.online_chg)
drivers/power/abx500_chargalg.c-	/* Kick charger watchdog if charging (any charger online) */
drivers/power/abx500_chargalg.c-	power_supply_changed(&di->chargalg_psy);
drivers/power/abx500_chargalg.c-	power_supply_changed(&di->chargalg_psy);
drivers/power/abx500_chargalg.c:	queue_delayed_work(di->chargalg_wq,
drivers/power/abx500_chargalg.c:		queue_delayed_work(di->chargalg_wq,
drivers/power/abx500_chargalg.c:		queue_delayed_work(di->chargalg_wq,
drivers/power/abx500_chargalg.c:					queue_delayed_work(di->chargalg_wq,
drivers/power/abx500_chargalg.c:					queue_delayed_work(di->chargalg_wq,
drivers/power/abx500_chargalg.c:	queue_delayed_work(di->chargalg_wq, &di->chargalg_periodic_work, 0);
drivers/power/abx500_chargalg.c:	queue_delayed_work(di->chargalg_wq, &di->chargalg_periodic_work, 0);
drivers/power/abx500_chargalg.c:		queue_delayed_work(di->chargalg_wq, &di->chargalg_wd_work, 0);
drivers/power/abx500_chargalg.c-	return 0;
drivers/power/abx500_chargalg.c-	return 0;
drivers/power/abx500_chargalg.c-	/* Run the charging algorithm */
drivers/power/abx500_chargalg.c-	struct abx500_chargalg_events events;
drivers/power/abx500_chargalg.c:	struct delayed_work chargalg_periodic_work;
drivers/power/abx500_chargalg.c:	struct delayed_work chargalg_wd_work;
drivers/power/abx500_chargalg.c-	struct timer_list safety_timer;
drivers/power/abx500_chargalg.c-	struct workqueue_struct *chargalg_wq;
drivers/power/abx500_chargalg.c-	struct work_struct chargalg_work;
drivers/power/battery_current_limit.c-
drivers/power/battery_current_limit.c-};
drivers/power/battery_current_limit.c-	}
drivers/power/battery_current_limit.c-		}
drivers/power/battery_current_limit.c-				(bcl->bcl_poll_interval_msec)));
drivers/power/battery_current_limit.c-		bcl_calculate_imax_trigger();
drivers/power/battery_current_limit.c-	/* BCL period poll delay work structure  */
drivers/power/battery_current_limit.c:		cancel_delayed_work_sync(&(gbcl->bcl_imax_work));
drivers/power/battery_current_limit.c:			cancel_delayed_work_sync(&(gbcl->bcl_imax_work));
drivers/power/battery_current_limit.c-		gbcl->bcl_mode = BCL_DEVICE_DISABLED;
drivers/power/battery_current_limit.c-			gbcl->bcl_mode = mode;
drivers/power/battery_current_limit.c-	int bcl_rbat;
drivers/power/battery_current_limit.c-			&& mode == BCL_DEVICE_DISABLED) {
drivers/power/battery_current_limit.c-		mode == BCL_DEVICE_DISABLED;
drivers/power/battery_current_limit.c-		/* restart the delay work for caculating imax */
drivers/power/battery_current_limit.c-		return;
drivers/power/battery_current_limit.c-			return;
drivers/power/battery_current_limit.c-			round_jiffies_relative(msecs_to_jiffies
drivers/power/battery_current_limit.c:		schedule_delayed_work(&bcl->bcl_imax_work,
drivers/power/battery_current_limit.c:	struct delayed_work     bcl_imax_work;
drivers/power/battery_temp_ctrl.c-
drivers/power/battery_temp_ctrl.c-
drivers/power/battery_temp_ctrl.c-
drivers/power/battery_temp_ctrl.c-
drivers/power/battery_temp_ctrl.c-{
drivers/power/battery_temp_ctrl.c-}
drivers/power/battery_temp_ctrl.c-};
drivers/power/battery_temp_ctrl.c-				 (30000)));
drivers/power/battery_temp_ctrl.c-					batt_temp_monitor_work);
drivers/power/battery_temp_ctrl.c:	cancel_delayed_work_sync(&chip->monitor_work);
drivers/power/battery_temp_ctrl.c-	INIT_DELAYED_WORK(&chip->monitor_work,
drivers/power/battery_temp_ctrl.c-						(pdata->update_time)));
drivers/power/battery_temp_ctrl.c-	power_supply_changed(psy);
drivers/power/battery_temp_ctrl.c-	return 0;
drivers/power/battery_temp_ctrl.c-			  round_jiffies_relative(msecs_to_jiffies
drivers/power/battery_temp_ctrl.c-				  round_jiffies_relative(msecs_to_jiffies
drivers/power/battery_temp_ctrl.c-			round_jiffies_relative(msecs_to_jiffies(pdata->update_time)));
drivers/power/battery_temp_ctrl.c:	schedule_delayed_work(&chip->monitor_work,
drivers/power/battery_temp_ctrl.c:	schedule_delayed_work(&chip->monitor_work,
drivers/power/battery_temp_ctrl.c:	schedule_delayed_work(&chip->monitor_work,
drivers/power/battery_temp_ctrl.c-static void batt_temp_monitor_work(struct work_struct *work)
drivers/power/battery_temp_ctrl.c-struct batt_temp_chip {
drivers/power/battery_temp_ctrl.c-	struct batt_temp_chip *chip = container_of(dwork,
drivers/power/battery_temp_ctrl.c-	struct batt_temp_chip *chip = dev_get_drvdata(dev);
drivers/power/battery_temp_ctrl.c-	struct batt_temp_chip *chip = dev_get_drvdata(dev);
drivers/power/battery_temp_ctrl.c-					struct batt_temp_chip, monitor_work);
drivers/power/battery_temp_ctrl.c-	struct batt_temp_pdata *pdata;
drivers/power/battery_temp_ctrl.c:	struct delayed_work *dwork = to_delayed_work(work);
drivers/power/battery_temp_ctrl.c:	struct delayed_work monitor_work;
drivers/power/battery_temp_ctrl.c-	temp_old_state=temp_state;
drivers/power/bq27520_fuelgauger.c-
drivers/power/bq27520_fuelgauger.c-
drivers/power/bq27520_fuelgauger.c-
drivers/power/bq27520_fuelgauger.c-
drivers/power/bq27520_fuelgauger.c-
drivers/power/bq27520_fuelgauger.c-
drivers/power/bq27520_fuelgauger.c-
drivers/power/bq27520_fuelgauger.c-
drivers/power/bq27520_fuelgauger.c-}
drivers/power/bq27520_fuelgauger.c-}
drivers/power/bq27520_fuelgauger.c-};
drivers/power/bq27520_fuelgauger.c-};
drivers/power/bq27520_fuelgauger.c-	}
drivers/power/bq27520_fuelgauger.c-	 */
drivers/power/bq27520_fuelgauger.c-	 */
drivers/power/bq27520_fuelgauger.c-		add_timer(&timer);
drivers/power/bq27520_fuelgauger.c-	 * and before any successful I2C transaction
drivers/power/bq27520_fuelgauger.c-			battery_status_poller);
drivers/power/bq27520_fuelgauger.c-	bq27520_cntl_cmd(di, BQ27520_SUBCMD_DISABLE_IT);
drivers/power/bq27520_fuelgauger.c-	bq27520_dev_setup(false, di);
drivers/power/bq27520_fuelgauger.c-				BQ27520_POLLING_STATUS);
drivers/power/bq27520_fuelgauger.c-				BQ27520_POLLING_STATUS);
drivers/power/bq27520_fuelgauger.c-				BQ27520_POLLING_STATUS);
drivers/power/bq27520_fuelgauger.c:	cancel_delayed_work_sync(&current_battery_status.poller);
drivers/power/bq27520_fuelgauger.c:	cancel_delayed_work_sync(&current_battery_status.poller);
drivers/power/bq27520_fuelgauger.c:	cancel_delayed_work_sync(&di->hw_config);
drivers/power/bq27520_fuelgauger.c-	INIT_DELAYED_WORK(&di->hw_config, bq27520_hw_config);
drivers/power/bq27520_fuelgauger.c-	int			status[NUM_OF_STATUS];
drivers/power/bq27520_fuelgauger.c-		msm_charger_notify_event(NULL, CHG_BATT_STATUS_CHANGE);
drivers/power/bq27520_fuelgauger.c-	 * notify msm_charger
drivers/power/bq27520_fuelgauger.c-	return 0;
drivers/power/bq27520_fuelgauger.c-	return 0;
drivers/power/bq27520_fuelgauger.c-	return 0;
drivers/power/bq27520_fuelgauger.c:	schedule_delayed_work(&current_battery_status.poller,
drivers/power/bq27520_fuelgauger.c:	schedule_delayed_work(&current_battery_status.poller,
drivers/power/bq27520_fuelgauger.c:	schedule_delayed_work(&current_battery_status.poller,
drivers/power/bq27520_fuelgauger.c:	schedule_delayed_work(&di->hw_config, BQ27520_INIT_DELAY);
drivers/power/bq27520_fuelgauger.c-	spinlock_t		lock;
drivers/power/bq27520_fuelgauger.c:	struct  delayed_work			hw_config;
drivers/power/bq27520_fuelgauger.c:	struct delayed_work	poller;
drivers/power/bq27520_fuelgauger.c-	uint32_t				irq;
drivers/power/bq27541_fuelgauger.c-
drivers/power/bq27541_fuelgauger.c-
drivers/power/bq27541_fuelgauger.c-
drivers/power/bq27541_fuelgauger.c-};
drivers/power/bq27541_fuelgauger.c-	 */
drivers/power/bq27541_fuelgauger.c-	 * and before any successful I2C transaction
drivers/power/bq27541_fuelgauger.c-	bq27541_cntl_cmd(di, BQ27541_SUBCMD_DISABLE_IT);
drivers/power/bq27541_fuelgauger.c:	cancel_delayed_work_sync(&di->hw_config);
drivers/power/bq27541_fuelgauger.c-	INIT_DELAYED_WORK(&di->hw_config, bq27541_hw_config);
drivers/power/bq27541_fuelgauger.c-	INIT_WORK(&di->counter, bq27541_coulomb_counter_work);
drivers/power/bq27541_fuelgauger.c-	kfree(di->bus);
drivers/power/bq27541_fuelgauger.c-	return 0;
drivers/power/bq27541_fuelgauger.c:	schedule_delayed_work(&di->hw_config, BQ27541_INIT_DELAY);
drivers/power/bq27541_fuelgauger.c:	struct  delayed_work		hw_config;
drivers/power/bq27541_fuelgauger.c-	udelay(66);
drivers/power/bq27x00_battery.c-
drivers/power/bq27x00_battery.c-
drivers/power/bq27x00_battery.c-
drivers/power/bq27x00_battery.c-
drivers/power/bq27x00_battery.c-
drivers/power/bq27x00_battery.c-
drivers/power/bq27x00_battery.c-}
drivers/power/bq27x00_battery.c-}
drivers/power/bq27x00_battery.c-	}
drivers/power/bq27x00_battery.c-	}
drivers/power/bq27x00_battery.c-	 */
drivers/power/bq27x00_battery.c-		bq27x00_battery_poll(&di->work.work);
drivers/power/bq27x00_battery.c-	 * call bq27x00_battery_poll.
drivers/power/bq27x00_battery.c:	cancel_delayed_work_sync(&di->work);
drivers/power/bq27x00_battery.c:	cancel_delayed_work_sync(&di->work);
drivers/power/bq27x00_battery.c:		cancel_delayed_work_sync(&di->work);
drivers/power/bq27x00_battery.c-	if (time_is_before_jiffies(di->last_update + 5 * HZ)) {
drivers/power/bq27x00_battery.c-	 * Make sure that bq27x00_battery_poll will not call
drivers/power/bq27x00_battery.c-	mutex_lock(&di->lock);
drivers/power/bq27x00_battery.c-	poll_interval = 0;
drivers/power/bq27x00_battery.c-	power_supply_unregister(&di->bat);
drivers/power/bq27x00_battery.c:	 * schedule_delayed_work again after unregister (which cause OOPS).
drivers/power/bq27x00_battery.c:	schedule_delayed_work(&di->work, 0);
drivers/power/bq27x00_battery.c:		schedule_delayed_work(&di->work, poll_interval * HZ);
drivers/power/bq27x00_battery.c-		set_timer_slack(&di->work.timer, poll_interval * HZ / 4);
drivers/power/bq27x00_battery.c-	struct bq27x00_device_info *di = to_bq27x00_device_info(psy);
drivers/power/bq27x00_battery.c:	struct delayed_work work;
drivers/power/bq27x00_battery.c-	struct power_supply	bat;
drivers/power/bq27x00_battery.c-		/* The timer does not have to be accurate. */
drivers/power/bq27x00_battery.c-	unsigned long last_update;
drivers/power/charger-manager.c-
drivers/power/charger-manager.c-
drivers/power/charger-manager.c-
drivers/power/charger-manager.c-
drivers/power/charger-manager.c-
drivers/power/charger-manager.c-
drivers/power/charger-manager.c-
drivers/power/charger-manager.c-
drivers/power/charger-manager.c-{
drivers/power/charger-manager.c-	}
drivers/power/charger-manager.c-	}
drivers/power/charger-manager.c-	}
drivers/power/charger-manager.c-		}
drivers/power/charger-manager.c:		cancel_delayed_work(&cm->fullbatt_vchk_work);
drivers/power/charger-manager.c:		cancel_delayed_work(&cm->fullbatt_vchk_work);
drivers/power/charger-manager.c:		cancel_delayed_work_sync(&cm_monitor_work);
drivers/power/charger-manager.c:		cancel_delayed_work_sync(&cm_monitor_work);
drivers/power/charger-manager.c-		cancel_work_sync(&setup_polling);
drivers/power/charger-manager.c-	cm->fullbatt_vchk_jiffies_at = jiffies + msecs_to_jiffies(
drivers/power/charger-manager.c-	cm->status_save_batt = is_batt_present(cm);
drivers/power/charger-manager.c-	cm->status_save_ext_pwr_inserted = is_ext_pwr_online(cm);
drivers/power/charger-manager.c:	    (delayed_work_pending(&cm_monitor_work) &&
drivers/power/charger-manager.c-		device_set_wakeup_capable(cm->dev, true);
drivers/power/charger-manager.c-		device_set_wakeup_capable(cm->dev, true);
drivers/power/charger-manager.c-/* Global charger-manager description */
drivers/power/charger-manager.c:	if (delayed_work_pending(&cm->fullbatt_vchk_work))
drivers/power/charger-manager.c:	if (delayed_work_pending(&cm->fullbatt_vchk_work))
drivers/power/charger-manager.c:	if (delayed_work_pending(&cm_monitor_work))
drivers/power/charger-manager.c:	if (!delayed_work_pending(&cm_monitor_work) ||
drivers/power/charger-manager.c:	if (!delayed_work_pending(&cm_monitor_work) &&
drivers/power/charger-manager.c-	if (work_pending(&setup_polling))
drivers/power/charger-manager.c-	    is_polling_required(cm) && cm->desc->polling_interval_ms)
drivers/power/charger-manager.c-				   msecs_to_jiffies(delay));
drivers/power/charger-manager.c-			   msecs_to_jiffies(desc->fullbatt_vchkdrop_ms));
drivers/power/charger-manager.c-		next_polling = jiffies + polling_jiffy;
drivers/power/charger-manager.c-	_next_polling = jiffies + polling_jiffy;
drivers/power/charger-manager.c:		queue_delayed_work(cm_wq, &cm->fullbatt_vchk_work,
drivers/power/charger-manager.c:	queue_delayed_work(cm_wq, &cm->fullbatt_vchk_work,
drivers/power/charger-manager.c:		queue_delayed_work(cm_wq, &cm_monitor_work, polling_jiffy);
drivers/power/charger-manager.c-	regulator_bulk_free(desc->num_charger_regulators,
drivers/power/charger-manager.c-		schedule_work(&setup_polling);
drivers/power/charger-manager.c:static struct delayed_work cm_monitor_work; /* init at driver add */
drivers/power/charger-manager.c-static struct workqueue_struct *cm_wq; /* init at driver add */
drivers/power/charger-manager.c-static unsigned long next_polling; /* Next appointed polling time */
drivers/power/charger-manager.c-static void fullbatt_vchk(struct work_struct *work)
drivers/power/charger-manager.c-	struct charger_manager *cm = container_of(dwork,
drivers/power/charger-manager.c-			struct charger_manager, fullbatt_vchk_work);
drivers/power/charger-manager.c:	struct delayed_work *dwork = to_delayed_work(work);
drivers/power/charger-manager.c-	     time_after(next_polling, _next_polling))) {
drivers/power/da9030_battery.c-
drivers/power/da9030_battery.c-
drivers/power/da9030_battery.c-
drivers/power/da9030_battery.c-
drivers/power/da9030_battery.c-
drivers/power/da9030_battery.c-
drivers/power/da9030_battery.c-
drivers/power/da9030_battery.c-}
drivers/power/da9030_battery.c-		break;
drivers/power/da9030_battery.c:	cancel_delayed_work(&charger->work);
drivers/power/da9030_battery.c:	cancel_delayed_work_sync(&charger->work);
drivers/power/da9030_battery.c:		cancel_delayed_work_sync(&charger->work);
drivers/power/da9030_battery.c-	case DA9030_EVENT_CHDET:
drivers/power/da9030_battery.c-	charger->nb.notifier_call = da9030_battery_event;
drivers/power/da9030_battery.c-				   DA9030_EVENT_CHDET | DA9030_EVENT_VBATMON |
drivers/power/da9030_battery.c-				   DA9030_EVENT_CHIOVER | DA9030_EVENT_TBAT);
drivers/power/da9030_battery.c-				   DA9030_EVENT_CHIOVER | DA9030_EVENT_TBAT);
drivers/power/da9030_battery.c-	da9030_set_charge(charger, 0);
drivers/power/da9030_battery.c-err_charger_init:
drivers/power/da9030_battery.c-err_notifier:
drivers/power/da9030_battery.c-	INIT_DELAYED_WORK(&charger->work, da9030_charging_monitor);
drivers/power/da9030_battery.c-	power_supply_unregister(&charger->psy);
drivers/power/da9030_battery.c-	/* reschedule for the next time */
drivers/power/da9030_battery.c:	schedule_delayed_work(&charger->work, charger->interval);
drivers/power/da9030_battery.c:	schedule_delayed_work(&charger->work, charger->interval);
drivers/power/da9030_battery.c-		schedule_work(&charger->work.work);
drivers/power/da9030_battery.c-	struct da9030_adc_res adc;
drivers/power/da9030_battery.c:	struct delayed_work work;
drivers/power/da9030_battery.c-	switch (event) {
drivers/power/da9030_battery.c-	unsigned int interval;
drivers/power/ds2760_battery.c-
drivers/power/ds2760_battery.c-
drivers/power/ds2760_battery.c-
drivers/power/ds2760_battery.c-
drivers/power/ds2760_battery.c-
drivers/power/ds2760_battery.c-
drivers/power/ds2760_battery.c-
drivers/power/ds2760_battery.c-
drivers/power/ds2760_battery.c-
drivers/power/ds2760_battery.c-
drivers/power/ds2760_battery.c-}
drivers/power/ds2760_battery.c-}
drivers/power/ds2760_battery.c-}
drivers/power/ds2760_battery.c-};
drivers/power/ds2760_battery.c-	}
drivers/power/ds2760_battery.c:	cancel_delayed_work_sync(&di->monitor_work);
drivers/power/ds2760_battery.c:	cancel_delayed_work_sync(&di->set_charged_work);
drivers/power/ds2760_battery.c-	destroy_workqueue(di->monitor_wqueue);
drivers/power/ds2760_battery.c-	dev_dbg(di->dev, "%s\n", __func__);
drivers/power/ds2760_battery.c-	ds2760_battery_update_status(di);
drivers/power/ds2760_battery.c-	goto success;
drivers/power/ds2760_battery.c-		goto workqueue_failed;
drivers/power/ds2760_battery.c:	mod_delayed_work(di->monitor_wqueue, &di->monitor_work, HZ);
drivers/power/ds2760_battery.c:	mod_delayed_work(di->monitor_wqueue, &di->monitor_work, HZ/10);
drivers/power/ds2760_battery.c:	mod_delayed_work(di->monitor_wqueue, &di->set_charged_work, HZ * 20);
drivers/power/ds2760_battery.c-	/* postpone the actual work by 20 secs. This is for debouncing GPIO
drivers/power/ds2760_battery.c-	power_supply_changed(&di->bat);
drivers/power/ds2760_battery.c-	power_supply_unregister(&di->bat);
drivers/power/ds2760_battery.c:	queue_delayed_work(di->monitor_wqueue, &di->monitor_work, HZ * 1);
drivers/power/ds2760_battery.c:	queue_delayed_work(di->monitor_wqueue, &di->monitor_work, interval);
drivers/power/ds2760_battery.c-	return 0;
drivers/power/ds2760_battery.c-	 * signals and to let the current value settle. See AN4188. */
drivers/power/ds2760_battery.c:	struct delayed_work monitor_work;
drivers/power/ds2760_battery.c:	struct delayed_work set_charged_work;
drivers/power/ds2760_battery.c-	struct device *w1_dev;
drivers/power/ds2760_battery.c-	struct ds2760_device_info *di = platform_get_drvdata(pdev);
drivers/power/ds2760_battery.c-	struct workqueue_struct *monitor_wqueue;
drivers/power/generic-adc-battery.c-
drivers/power/generic-adc-battery.c-
drivers/power/generic-adc-battery.c-
drivers/power/generic-adc-battery.c-
drivers/power/generic-adc-battery.c-
drivers/power/generic-adc-battery.c-
drivers/power/generic-adc-battery.c-
drivers/power/generic-adc-battery.c-
drivers/power/generic-adc-battery.c-}
drivers/power/generic-adc-battery.c-}
drivers/power/generic-adc-battery.c:	adc_bat = container_of(delayed_work, struct gab, bat_work);
drivers/power/generic-adc-battery.c-	adc_bat->status = POWER_SUPPLY_STATUS_UNKNOWN;
drivers/power/generic-adc-battery.c-	bool is_plugged;
drivers/power/generic-adc-battery.c:	cancel_delayed_work(&adc_bat->bat_work);
drivers/power/generic-adc-battery.c:	cancel_delayed_work_sync(&adc_bat->bat_work);
drivers/power/generic-adc-battery.c:	delayed_work = container_of(work, struct delayed_work, work);
drivers/power/generic-adc-battery.c-	delay = pdata->jitter_delay ? pdata->jitter_delay : JITTER_DEFAULT;
drivers/power/generic-adc-battery.c-	int	level;
drivers/power/generic-adc-battery.c-	int status;
drivers/power/generic-adc-battery.c-	int	status;
drivers/power/generic-adc-battery.c-	kfree(adc_bat->psy.properties);
drivers/power/generic-adc-battery.c-			msecs_to_jiffies(0));
drivers/power/generic-adc-battery.c-			msecs_to_jiffies(delay));
drivers/power/generic-adc-battery.c-			msecs_to_jiffies(delay));
drivers/power/generic-adc-battery.c-	pdata = adc_bat->pdata;
drivers/power/generic-adc-battery.c-	return 0;
drivers/power/generic-adc-battery.c-	return 0;
drivers/power/generic-adc-battery.c-	return 0;
drivers/power/generic-adc-battery.c-	return 0;
drivers/power/generic-adc-battery.c-	return IRQ_HANDLED;
drivers/power/generic-adc-battery.c:	schedule_delayed_work(&adc_bat->bat_work,
drivers/power/generic-adc-battery.c:	schedule_delayed_work(&adc_bat->bat_work,
drivers/power/generic-adc-battery.c:	schedule_delayed_work(&adc_bat->bat_work,
drivers/power/generic-adc-battery.c:	schedule_delayed_work(&adc_bat->bat_work, msecs_to_jiffies(0));
drivers/power/generic-adc-battery.c-	/* Schedule timer to check current status */
drivers/power/generic-adc-battery.c-	/* Schedule timer to check current status */
drivers/power/generic-adc-battery.c-	status = adc_bat->status;
drivers/power/generic-adc-battery.c:	struct delayed_work bat_work;
drivers/power/generic-adc-battery.c:	struct delayed_work *delayed_work;
drivers/power/generic-adc-battery.c-	struct gab *adc_bat;
drivers/power/generic-adc-battery.c-	struct gab *adc_bat = dev_get_drvdata(dev);
drivers/power/generic-adc-battery.c-	struct gab *adc_bat = to_generic_bat(psy);
drivers/power/generic-adc-battery.c-	struct gab_platform_data *pdata;
drivers/power/generic-adc-battery.c-	struct gab_platform_data	*pdata;
drivers/power/generic-adc-battery.c-	struct iio_channel	*channel[GAB_MAX_CHAN_TYPE];
drivers/power/intel_mid_battery.c-
drivers/power/intel_mid_battery.c-
drivers/power/intel_mid_battery.c-
drivers/power/intel_mid_battery.c-
drivers/power/intel_mid_battery.c-
drivers/power/intel_mid_battery.c-}
drivers/power/intel_mid_battery.c-};
drivers/power/intel_mid_battery.c:	cancel_delayed_work_sync(&pbi->monitor_battery);
drivers/power/intel_mid_battery.c:	cancel_delayed_work_sync(&pbi->monitor_battery);
drivers/power/intel_mid_battery.c-	destroy_workqueue(pbi->monitor_wqueue);
drivers/power/intel_mid_battery.c-	destroy_workqueue(pbi->monitor_wqueue);
drivers/power/intel_mid_battery.c-	free_irq(pbi->irq, pbi);
drivers/power/intel_mid_battery.c-		__func__);
drivers/power/intel_mid_battery.c-	int irq;				/* GPE_ID or IRQ# */
drivers/power/intel_mid_battery.c-	pmic_battery_read_status(pbi);
drivers/power/intel_mid_battery.c-power_reg_failed:
drivers/power/intel_mid_battery.c-	power_supply_unregister(&pbi->batt);
drivers/power/intel_mid_battery.c:	queue_delayed_work(pbi->monitor_wqueue, &pbi->monitor_battery, HZ * 1);
drivers/power/intel_mid_battery.c:	queue_delayed_work(pbi->monitor_wqueue, &pbi->monitor_battery, HZ * 10);
drivers/power/intel_mid_battery.c-	/* register pmic-usb with power supply subsystem */
drivers/power/intel_mid_battery.c-requestirq_failed:
drivers/power/intel_mid_battery.c:	struct delayed_work monitor_battery;
drivers/power/intel_mid_battery.c-	struct workqueue_struct *monitor_wqueue;
drivers/power/intel_mid_battery.c-	struct work_struct handler;
drivers/power/intel_mid_battery.c-	/* update pmic_power_module_info members */
drivers/power/isl9519q.c-
drivers/power/isl9519q.c-
drivers/power/isl9519q.c-
drivers/power/isl9519q.c-}
drivers/power/isl9519q.c-	 */
drivers/power/isl9519q.c-	 */
drivers/power/isl9519q.c:	cancel_delayed_work_sync(&isl_chg->charge_work);
drivers/power/isl9519q.c-	free_irq(client->irq, client);
drivers/power/isl9519q.c-	gpio_free(pdata->valid_n_gpio);
drivers/power/isl9519q.c-	if (isl_chg->notify_by_pmic) {
drivers/power/isl9519q.c-	int				batt_present;
drivers/power/isl9519q.c-	int				present;
drivers/power/isl9519q.c-			      (ISL9519_CHG_PERIOD_SEC * HZ));
drivers/power/isl9519q.c-		isl_adapter_check_ichg(isl_chg);
drivers/power/isl9519q.c-	isl_chg->charging = true;
drivers/power/isl9519q.c-		power_supply_unregister(&isl_chg->dc_psy);
drivers/power/isl9519q.c-	return 0;
drivers/power/isl9519q.c:	schedule_delayed_work(&isl_chg->charge_work,
drivers/power/isl9519q.c:	schedule_delayed_work(&isl_chg->charge_work, 1);
drivers/power/isl9519q.c:	schedule_delayed_work(&isl_chg->charge_work, 1);
drivers/power/isl9519q.c:	struct delayed_work		charge_work;
drivers/power/isl9519q.c-	struct i2c_client		*client;
drivers/power/isl9519q.c-struct isl9519q_struct {
drivers/power/isl9519q.c-	 * This API might be called from interrupt context.
drivers/power/isl9519q.c-	 * This API might be called from interrupt context.
drivers/power/jz4740-battery.c-
drivers/power/jz4740-battery.c-
drivers/power/jz4740-battery.c-
drivers/power/jz4740-battery.c-
drivers/power/jz4740-battery.c-
drivers/power/jz4740-battery.c-
drivers/power/jz4740-battery.c-
drivers/power/jz4740-battery.c-
drivers/power/jz4740-battery.c-
drivers/power/jz4740-battery.c-
drivers/power/jz4740-battery.c-
drivers/power/jz4740-battery.c-
drivers/power/jz4740-battery.c-
drivers/power/jz4740-battery.c-
drivers/power/jz4740-battery.c-
drivers/power/jz4740-battery.c-
drivers/power/jz4740-battery.c-}
drivers/power/jz4740-battery.c-}
drivers/power/jz4740-battery.c:	cancel_delayed_work_sync(&jz_battery->work);
drivers/power/jz4740-battery.c:	cancel_delayed_work_sync(&jz_battery->work);
drivers/power/jz4740-battery.c-	if (gpio_is_valid(jz_battery->pdata->gpio_charge)) {
drivers/power/jz4740-battery.c-	jz_battery->status = POWER_SUPPLY_STATUS_UNKNOWN;
drivers/power/jz4740-battery.c-	jz_battery_update(jz_battery);
drivers/power/jz4740-battery.c:	mod_delayed_work(system_wq, &jz_battery->work, 0);
drivers/power/jz4740-battery.c:	mod_delayed_work(system_wq, &jz_battery->work, 0);
drivers/power/jz4740-battery.c-	platform_set_drvdata(pdev, jz_battery);
drivers/power/jz4740-battery.c-	return 0;
drivers/power/jz4740-battery.c-	return 0;
drivers/power/jz4740-battery.c-	return IRQ_HANDLED;
drivers/power/jz4740-battery.c:	schedule_delayed_work(&jz_battery->work, 0);
drivers/power/jz4740-battery.c:	schedule_delayed_work(&jz_battery->work, 0);
drivers/power/jz4740-battery.c:	schedule_delayed_work(&jz_battery->work, interval);
drivers/power/jz4740-battery.c:	struct delayed_work work;
drivers/power/jz4740-battery.c-	struct jz_battery *jz_battery = data;
drivers/power/jz4740-battery.c-	struct jz_battery *jz_battery = dev_get_drvdata(dev);
drivers/power/jz4740-battery.c-	struct jz_battery *jz_battery = dev_get_drvdata(dev);
drivers/power/jz4740-battery.c-	struct jz_battery *jz_battery = platform_get_drvdata(pdev);
drivers/power/jz4740-battery.c-	struct jz_battery *jz_battery = psy_to_jz_battery(psy);
drivers/power/jz4740-battery.c-	struct mutex lock;
drivers/power/jz4740-battery.c-	struct power_supply battery;
drivers/power/lp8727_charger.c-
drivers/power/lp8727_charger.c-
drivers/power/lp8727_charger.c:	queue_delayed_work(pchg->irqthread, &pchg->work, delay);
drivers/power/lp8727_charger.c-	return IRQ_HANDLED;
drivers/power/lp8727_charger.c:	struct delayed_work work;
drivers/power/lp8727_charger.c-	struct i2c_client *client;
drivers/power/lp8727_charger.c-	struct lp8727_platform_data *pdata;
drivers/power/lp8727_charger.c-	struct mutex xfer_lock;
drivers/power/lp8727_charger.c-	struct workqueue_struct *irqthread;
drivers/power/lp8727_charger.c-	unsigned long delay = msecs_to_jiffies(DEBOUNCE_MSEC);
drivers/power/max17040_battery.c-
drivers/power/max17040_battery.c-
drivers/power/max17040_battery.c-
drivers/power/max17040_battery.c-
drivers/power/max17040_battery.c-
drivers/power/max17040_battery.c-
drivers/power/max17040_battery.c-}
drivers/power/max17040_battery.c-}
drivers/power/max17040_battery.c-}
drivers/power/max17040_battery.c:	cancel_delayed_work(&chip->work);
drivers/power/max17040_battery.c:	cancel_delayed_work(&chip->work);
drivers/power/max17040_battery.c-#endif
drivers/power/max17040_battery.c-	INIT_DEFERRABLE_WORK(&chip->work, max17040_work);
drivers/power/max17040_battery.c-	kfree(chip);
drivers/power/max17040_battery.c-	mutex_destroy(&chip->mutex);
drivers/power/max17040_battery.c-	power_supply_unregister(&chip->battery);
drivers/power/max17040_battery.c-	return 0;
drivers/power/max17040_battery.c-	return 0;
drivers/power/max17040_battery.c-	return 0;
drivers/power/max17040_battery.c:	schedule_delayed_work(&chip->work, 0);
drivers/power/max17040_battery.c:	schedule_delayed_work(&chip->work, 0);
drivers/power/max17040_battery.c:	schedule_delayed_work(&chip->work, msecs_to_jiffies(chip->fg_interval));
drivers/power/max17040_battery.c:	struct delayed_work		work;
drivers/power/max17040_battery.c-	struct i2c_client		*client;
drivers/power/max17040_battery.c-struct max17040_chip {
drivers/power/max17040_battery.c-	struct max17040_chip *chip = i2c_get_clientdata(client);
drivers/power/max17040_battery.c-	struct max17040_platform_data	*pdata;
drivers/power/max17040_battery.c-	struct power_supply		battery;
drivers/power/max17040_battery.c-	wake_lock_destroy(&chip->lowbat_wake_lock);
drivers/power/max17040_battery.c-		wake_unlock(&chip->lowbat_wake_lock);
drivers/power/msm_charger.c-
drivers/power/msm_charger.c-
drivers/power/msm_charger.c-
drivers/power/msm_charger.c-
drivers/power/msm_charger.c-}
drivers/power/msm_charger.c-}
drivers/power/msm_charger.c-	}
drivers/power/msm_charger.c-	}
drivers/power/msm_charger.c-	}
drivers/power/msm_charger.c:		cancel_delayed_work(&msm_chg.teoc_work);
drivers/power/msm_charger.c:		cancel_delayed_work(&msm_chg.teoc_work);
drivers/power/msm_charger.c:		cancel_delayed_work(&msm_chg.teoc_work);
drivers/power/msm_charger.c:	cancel_delayed_work(&msm_chg.update_heartbeat_work);
drivers/power/msm_charger.c-	dev_dbg(msm_chg.dev, "%s suspended\n", __func__);
drivers/power/msm_charger.c-				dev_info(msm_chg.dev,
drivers/power/msm_charger.c-		dev_info(msm_chg.dev, "%s: starting safety timer work\n",
drivers/power/msm_charger.c-		dev_info(msm_chg.dev, "%s: stopping safety timer work\n",
drivers/power/msm_charger.c-		dev_info(msm_chg.dev, "%s: stopping safety timer work\n",
drivers/power/msm_charger.c-		dev_info(msm_chg.dev, "%s: stopping safety timer work\n",
drivers/power/msm_charger.c-				__func__);
drivers/power/msm_charger.c-				__func__);
drivers/power/msm_charger.c-				__func__);
drivers/power/msm_charger.c-				__func__);
drivers/power/msm_charger.c-	handle_battery_removed();
drivers/power/msm_charger.c-		if (msm_batt_gauge && msm_batt_gauge->monitor_for_recharging)
drivers/power/msm_charger.c-	int stop_update;
drivers/power/msm_charger.c-	 * milliseconds */
drivers/power/msm_charger.c-	 * milliseconds */
drivers/power/msm_charger.c-	msm_chg.stop_update = 1;
drivers/power/msm_charger.c-					&msm_chg.teoc_work,
drivers/power/msm_charger.c-							&msm_chg.teoc_work,
drivers/power/msm_charger.c-				&msm_chg.update_heartbeat_work,
drivers/power/msm_charger.c-				&msm_chg.update_heartbeat_work,
drivers/power/msm_charger.c-				&msm_chg.update_heartbeat_work,
drivers/power/msm_charger.c-	mutex_lock(&msm_chg.status_lock);
drivers/power/msm_charger.c:	queue_delayed_work(msm_chg.event_wq_thread,
drivers/power/msm_charger.c:	queue_delayed_work(msm_chg.event_wq_thread,
drivers/power/msm_charger.c:	queue_delayed_work(msm_chg.event_wq_thread,
drivers/power/msm_charger.c:		queue_delayed_work(msm_chg.event_wq_thread,
drivers/power/msm_charger.c:				queue_delayed_work(msm_chg.event_wq_thread,
drivers/power/msm_charger.c-		return;
drivers/power/msm_charger.c-						      round_jiffies_relative
drivers/power/msm_charger.c-			      round_jiffies_relative(msecs_to_jiffies
drivers/power/msm_charger.c-			      round_jiffies_relative(msecs_to_jiffies
drivers/power/msm_charger.c-			      round_jiffies_relative(msecs_to_jiffies
drivers/power/msm_charger.c-				      round_jiffies_relative(msecs_to_jiffies
drivers/power/msm_charger.c-				       "%s: starting safety timer\n", __func__);
drivers/power/msm_charger.c-	/* start updaing the battery powersupply every msm_chg.update_time
drivers/power/msm_charger.c-	/* start updaing the battery powersupply every msm_chg.update_time
drivers/power/msm_charger.c:	struct delayed_work teoc_work;
drivers/power/msm_charger.c:	struct delayed_work update_heartbeat_work;
drivers/power/msm_charger.c-	struct mutex status_lock;
drivers/power/msm_charger.c-	unsigned int safety_time;
drivers/power/msm_charger.c-	unsigned int update_time;
drivers/power/pm8921-bms.c-
drivers/power/pm8921-bms.c-
drivers/power/pm8921-bms.c-
drivers/power/pm8921-bms.c-
drivers/power/pm8921-bms.c-
drivers/power/pm8921-bms.c-
drivers/power/pm8921-bms.c-
drivers/power/pm8921-bms.c-
drivers/power/pm8921-bms.c-
drivers/power/pm8921-bms.c-
drivers/power/pm8921-bms.c-
drivers/power/pm8921-bms.c-{
drivers/power/pm8921-bms.c-}
drivers/power/pm8921-bms.c-}
drivers/power/pm8921-bms.c-	}
drivers/power/pm8921-bms.c-	calculated_soc = 0;
drivers/power/pm8921-bms.c:				calculate_soc_delayed_work);
drivers/power/pm8921-bms.c-			calculate_soc_work);
drivers/power/pm8921-bms.c:	calculate_soc_work(&(chip->calculate_soc_delayed_work.work));
drivers/power/pm8921-bms.c:	cancel_delayed_work_sync(&chip->calculate_soc_delayed_work);
drivers/power/pm8921-bms.c:	cancel_delayed_work_sync(&the_chip->calculate_soc_delayed_work);
drivers/power/pm8921-bms.c-	chip->first_report_after_suspend = true;
drivers/power/pm8921-bms.c-	chip->last_soc_at_suspend = last_soc;
drivers/power/pm8921-bms.c-			(chip->soc_calc_period)));
drivers/power/pm8921-bms.c-	chip->soc_calc_period = time_ms;
drivers/power/pm8921-bms.c-EXPORT_SYMBOL(pm8921_bms_battery_inserted);
drivers/power/pm8921-bms.c:	if (!cancel_delayed_work_sync(&chip->calculate_soc_delayed_work))
drivers/power/pm8921-bms.c-	/* if work was pending and was cancelled, calculate SOC immediately */
drivers/power/pm8921-bms.c:	INIT_DELAYED_WORK(&chip->calculate_soc_delayed_work,
drivers/power/pm8921-bms.c-	INIT_WORK(&chip->calib_hkadc_work, calibrate_hkadc_work);
drivers/power/pm8921-bms.c-	int			shutdown_iavg_ua;
drivers/power/pm8921-bms.c-	int			shutdown_soc;
drivers/power/pm8921-bms.c-				msecs_to_jiffies(chip->soc_calc_period));
drivers/power/pm8921-bms.c-						msecs_to_jiffies(ms));
drivers/power/pm8921-bms.c-		ms = time_ms;
drivers/power/pm8921-bms.c-	pr_info("Battery Inserted\n");
drivers/power/pm8921-bms.c-	pr_info("Battery Removed Cleaning up\n");
drivers/power/pm8921-bms.c-	rc = get_battery_uvolts(chip, &vbatt);
drivers/power/pm8921-bms.c-	recalculate_soc(chip);
drivers/power/pm8921-bms.c-			round_jiffies_relative(msecs_to_jiffies
drivers/power/pm8921-bms.c:	schedule_delayed_work(&chip->calculate_soc_delayed_work,
drivers/power/pm8921-bms.c:	schedule_delayed_work(&chip->calculate_soc_delayed_work,
drivers/power/pm8921-bms.c:	schedule_delayed_work(&chip->calculate_soc_delayed_work,
drivers/power/pm8921-bms.c:	schedule_delayed_work(&the_chip->calculate_soc_delayed_work, 0);
drivers/power/pm8921-bms.c-static void calculate_soc_work(struct work_struct *work)
drivers/power/pm8921-bms.c:	struct delayed_work	calculate_soc_delayed_work;
drivers/power/pm8921-bms.c:	struct delayed_work *dwork = to_delayed_work(work);
drivers/power/pm8921-bms.c-				struct pm8921_bms_chip,
drivers/power/pm8921-bms.c-	struct pm8921_bms_chip *chip = container_of(dwork,
drivers/power/pm8921-bms.c-	struct pm8921_bms_chip *chip = dev_get_drvdata(dev);
drivers/power/pm8921-bms.c-	struct timespec		t_soc_queried;
drivers/power/pm8921-bms.c-	the_chip->last_ocv_uv = estimate_ocv(the_chip);
drivers/power/pm8921-bms.c-	the_chip->start_percent = -EINVAL;
drivers/power/pm8921-bms.c-	unsigned long		last_recalc_time;
drivers/power/pm8921-bms.c-	update_power_supply(chip);
drivers/power/pm8921-charger.c-
drivers/power/pm8921-charger.c-
drivers/power/pm8921-charger.c-
drivers/power/pm8921-charger.c-
drivers/power/pm8921-charger.c-
drivers/power/pm8921-charger.c-
drivers/power/pm8921-charger.c-
drivers/power/pm8921-charger.c-
drivers/power/pm8921-charger.c-
drivers/power/pm8921-charger.c-
drivers/power/pm8921-charger.c-
drivers/power/pm8921-charger.c-{
drivers/power/pm8921-charger.c-{
drivers/power/pm8921-charger.c-{
drivers/power/pm8921-charger.c-{
drivers/power/pm8921-charger.c-{
drivers/power/pm8921-charger.c-}
drivers/power/pm8921-charger.c-	}
drivers/power/pm8921-charger.c-			adjust_vdd_max_for_fastchg(chip, vbat_batt_terminal_uv);
drivers/power/pm8921-charger.c:		cancel_delayed_work_sync(&chip->btc_override_work);
drivers/power/pm8921-charger.c:	cancel_delayed_work_sync(&chip->update_heartbeat_work);
drivers/power/pm8921-charger.c-	changelock(0);
drivers/power/pm8921-charger.c-		changelock(1);
drivers/power/pm8921-charger.c-					(chip->btc_delay_ms)));
drivers/power/pm8921-charger.c-					(chip->btc_delay_ms)));
drivers/power/pm8921-charger.c-						(chip->btc_delay_ms)));
drivers/power/pm8921-charger.c-						(chip->btc_delay_ms)));
drivers/power/pm8921-charger.c-						(chip->btc_delay_ms)));
drivers/power/pm8921-charger.c-		&& chip->btc_override
drivers/power/pm8921-charger.c-						     (chip->update_time)));
drivers/power/pm8921-charger.c-							(chip->update_time)));
drivers/power/pm8921-charger.c:		&& !delayed_work_pending(&chip->btc_override_work)) {
drivers/power/pm8921-charger.c-	else
drivers/power/pm8921-charger.c-	else
drivers/power/pm8921-charger.c-	else
drivers/power/pm8921-charger.c-	} else {
drivers/power/pm8921-charger.c-	enum pm8921_chg_cold_thr	cold_thr;
drivers/power/pm8921-charger.c-						     (EOC_CHECK_PERIOD_MS)));
drivers/power/pm8921-charger.c-						     (EOC_CHECK_PERIOD_MS)));
drivers/power/pm8921-charger.c-	/* for battery health when charger is not connected */
drivers/power/pm8921-charger.c-		&& get_prop_batt_status(chip) != POWER_SUPPLY_STATUS_FULL) {
drivers/power/pm8921-charger.c-	high_transition = pm_chg_get_rt_status(chip, FASTCHG_IRQ);
drivers/power/pm8921-charger.c-		if (chip->btc_override)
drivers/power/pm8921-charger.c-	if (chip->btc_override)
drivers/power/pm8921-charger.c-	if (chip->btc_override)
drivers/power/pm8921-charger.c-	if (chip->btc_override && !chg_present)
drivers/power/pm8921-charger.c-	if (chip->btc_override && (is_dc_chg_plugged_in(the_chip) ||
drivers/power/pm8921-charger.c-	if (chip->recent_reported_soc <= 20)
drivers/power/pm8921-charger.c-	if (chip->update_time)
drivers/power/pm8921-charger.c-	if (chip->usb_present || chip->dc_present) {
drivers/power/pm8921-charger.c-		if (dc_present)
drivers/power/pm8921-charger.c:		if (!delayed_work_pending(&chip->unplug_check_work))
drivers/power/pm8921-charger.c-		if (end != CHG_NOT_IN_PROGRESS)
drivers/power/pm8921-charger.c-	if (high_transition
drivers/power/pm8921-charger.c:	if (high_transition && !delayed_work_pending(&chip->eoc_work)) {
drivers/power/pm8921-charger.c-	if ((is_dc_chg_plugged_in(the_chip) || is_usb_chg_plugged_in(the_chip))
drivers/power/pm8921-charger.c-	if (is_usb_chg_plugged_in(chip)) {
drivers/power/pm8921-charger.c-	if (ramp)
drivers/power/pm8921-charger.c-	if (usb_present) {
drivers/power/pm8921-charger.c-	if (usb_target_ma)
drivers/power/pm8921-charger.c-	int rc = 0;
drivers/power/pm8921-charger.c-	int temp;
drivers/power/pm8921-charger.c-	int				thermal_levels;
drivers/power/pm8921-charger.c-					is_usb_chg_plugged_in(the_chip)))
drivers/power/pm8921-charger.c-						     (LOW_SOC_HEARTBEAT_MS)));
drivers/power/pm8921-charger.c-				      msecs_to_jiffies
drivers/power/pm8921-charger.c-			msecs_to_jiffies(UNPLUG_CHECK_RAMP_MS));
drivers/power/pm8921-charger.c-			msecs_to_jiffies(UNPLUG_CHECK_RAMP_MS));
drivers/power/pm8921-charger.c-			msecs_to_jiffies(UNPLUG_CHECK_RAMP_MS));
drivers/power/pm8921-charger.c-			msecs_to_jiffies(UNPLUG_CHECK_WAIT_PERIOD_MS));
drivers/power/pm8921-charger.c-			msecs_to_jiffies(UNPLUG_CHECK_WAIT_PERIOD_MS));
drivers/power/pm8921-charger.c-				msecs_to_jiffies(UNPLUG_CHECK_WAIT_PERIOD_MS));
drivers/power/pm8921-charger.c-			      msecs_to_jiffies(VIN_MIN_COLLAPSE_CHECK_MS));
drivers/power/pm8921-charger.c-	notify_usb_of_the_plugin_event(chip->usb_present);
drivers/power/pm8921-charger.c-		pm8921_chg_enable_irq(chip, CHG_GONE_IRQ);
drivers/power/pm8921-charger.c-		pm8921_chg_enable_irq(chip, CHG_GONE_IRQ);
drivers/power/pm8921-charger.c-	pm8921_disable_source_current(true);
drivers/power/pm8921-charger.c-	power_supply_changed(&chip->batt_psy);
drivers/power/pm8921-charger.c-		pr_debug("usb_now=%d, usb_target = %d\n",
drivers/power/pm8921-charger.c-	return 0;
drivers/power/pm8921-charger.c-			round_jiffies_relative(msecs_to_jiffies
drivers/power/pm8921-charger.c-			      round_jiffies_relative(msecs_to_jiffies
drivers/power/pm8921-charger.c-			      round_jiffies_relative(msecs_to_jiffies
drivers/power/pm8921-charger.c-			      round_jiffies_relative(msecs_to_jiffies
drivers/power/pm8921-charger.c-				round_jiffies_relative(msecs_to_jiffies
drivers/power/pm8921-charger.c-				      round_jiffies_relative(msecs_to_jiffies
drivers/power/pm8921-charger.c-				      round_jiffies_relative(msecs_to_jiffies
drivers/power/pm8921-charger.c-					round_jiffies_relative(msecs_to_jiffies
drivers/power/pm8921-charger.c-					round_jiffies_relative(msecs_to_jiffies
drivers/power/pm8921-charger.c-					round_jiffies_relative(msecs_to_jiffies
drivers/power/pm8921-charger.c:		schedule_delayed_work(&chip->btc_override_work,
drivers/power/pm8921-charger.c:		schedule_delayed_work(&chip->btc_override_work,
drivers/power/pm8921-charger.c:		schedule_delayed_work(&chip->btc_override_work,
drivers/power/pm8921-charger.c:		schedule_delayed_work(&chip->btc_override_work,
drivers/power/pm8921-charger.c:			schedule_delayed_work(&chip->btc_override_work,
drivers/power/pm8921-charger.c:		schedule_delayed_work(&chip->btc_override_work, 0);
drivers/power/pm8921-charger.c:		schedule_delayed_work(&chip->eoc_work,
drivers/power/pm8921-charger.c:		schedule_delayed_work(&chip->eoc_work,
drivers/power/pm8921-charger.c:	schedule_delayed_work(&chip->eoc_work, delay);
drivers/power/pm8921-charger.c:	schedule_delayed_work(&chip->unplug_check_work,
drivers/power/pm8921-charger.c:		schedule_delayed_work(&chip->unplug_check_work,
drivers/power/pm8921-charger.c:		schedule_delayed_work(&chip->unplug_check_work,
drivers/power/pm8921-charger.c:		schedule_delayed_work(&chip->unplug_check_work,
drivers/power/pm8921-charger.c:		schedule_delayed_work(&chip->unplug_check_work,
drivers/power/pm8921-charger.c:			schedule_delayed_work(&chip->unplug_check_work,
drivers/power/pm8921-charger.c:			schedule_delayed_work(&chip->unplug_check_work,
drivers/power/pm8921-charger.c:		schedule_delayed_work(&chip->update_heartbeat_work,
drivers/power/pm8921-charger.c:		schedule_delayed_work(&chip->update_heartbeat_work,
drivers/power/pm8921-charger.c:		schedule_delayed_work(&chip->update_heartbeat_work,
drivers/power/pm8921-charger.c:	schedule_delayed_work(&chip->update_heartbeat_work, 0);
drivers/power/pm8921-charger.c:		schedule_delayed_work(&the_chip->vin_collapse_check_work,
drivers/power/pm8921-charger.c-	/* schedule to check again later */
drivers/power/pm8921-charger.c-static void eoc_worker(struct work_struct *work)
drivers/power/pm8921-charger.c-static void unplug_check_worker(struct work_struct *work)
drivers/power/pm8921-charger.c-static void update_heartbeat(struct work_struct *work)
drivers/power/pm8921-charger.c-static void vin_collapse_check_worker(struct work_struct *work)
drivers/power/pm8921-charger.c:	struct delayed_work		btc_override_work;
drivers/power/pm8921-charger.c:	struct delayed_work *dwork = to_delayed_work(work);
drivers/power/pm8921-charger.c:	struct delayed_work *dwork = to_delayed_work(work);
drivers/power/pm8921-charger.c:	struct delayed_work *dwork = to_delayed_work(work);
drivers/power/pm8921-charger.c:	struct delayed_work *dwork = to_delayed_work(work);
drivers/power/pm8921-charger.c:	struct delayed_work *dwork = to_delayed_work(work);
drivers/power/pm8921-charger.c:	struct delayed_work		eoc_work;
drivers/power/pm8921-charger.c:	struct delayed_work		unplug_check_work;
drivers/power/pm8921-charger.c:	struct delayed_work		update_heartbeat_work;
drivers/power/pm8921-charger.c:	struct delayed_work		vin_collapse_check_work;
drivers/power/pm8921-charger.c-				struct pm8921_chg_chip, btc_override_work);
drivers/power/pm8921-charger.c-	struct pm8921_chg_chip *chip = container_of(dwork,
drivers/power/pm8921-charger.c-	struct pm8921_chg_chip *chip = container_of(dwork,
drivers/power/pm8921-charger.c-	struct pm8921_chg_chip *chip = container_of(dwork,
drivers/power/pm8921-charger.c-	struct pm8921_chg_chip *chip = container_of(dwork,
drivers/power/pm8921-charger.c-	struct pm8921_chg_chip *chip = container_of(dwork,
drivers/power/pm8921-charger.c-	struct pm8921_chg_chip *chip = dev_get_drvdata(dev);
drivers/power/pm8921-charger.c-				struct pm8921_chg_chip, eoc_work);
drivers/power/pm8921-charger.c-				struct pm8921_chg_chip, unplug_check_work);
drivers/power/pm8921-charger.c-				struct pm8921_chg_chip, update_heartbeat_work);
drivers/power/pm8921-charger.c-			struct pm8921_chg_chip, vin_collapse_check_work);
drivers/power/pm8921-charger.c-	struct wake_lock		eoc_wake_lock;
drivers/power/pm8921-charger.c-						(UNPLUG_CHECK_WAIT_PERIOD_MS));
drivers/power/pm8921-charger.c-	unsigned int			*thermal_mitigation;
drivers/power/pm8921-charger.c-				USB_WALL_THRESHOLD_MA, usb_target_ma);
drivers/power/pm8921-charger.c-		wake_lock(&chip->eoc_wake_lock);
drivers/power/pm8921-sec-charger-8930.c-
drivers/power/pm8921-sec-charger-8930.c-
drivers/power/pm8921-sec-charger-8930.c-
drivers/power/pm8921-sec-charger-8930.c-
drivers/power/pm8921-sec-charger-8930.c-
drivers/power/pm8921-sec-charger-8930.c-
drivers/power/pm8921-sec-charger-8930.c-
drivers/power/pm8921-sec-charger-8930.c-
drivers/power/pm8921-sec-charger-8930.c-
drivers/power/pm8921-sec-charger-8930.c-
drivers/power/pm8921-sec-charger-8930.c-{
drivers/power/pm8921-sec-charger-8930.c-{
drivers/power/pm8921-sec-charger-8930.c-{
drivers/power/pm8921-sec-charger-8930.c-{
drivers/power/pm8921-sec-charger-8930.c-}
drivers/power/pm8921-sec-charger-8930.c-}
drivers/power/pm8921-sec-charger-8930.c-	}
drivers/power/pm8921-sec-charger-8930.c-	}
drivers/power/pm8921-sec-charger-8930.c-	}
drivers/power/pm8921-sec-charger-8930.c-		adjust_vdd_max_for_fastchg(chip, vbat_batt_terminal_uv);
drivers/power/pm8921-sec-charger-8930.c-	alarm_cancel(&chip->event_termination_alarm);
drivers/power/pm8921-sec-charger-8930.c-	alarm_cancel(&chip->update_alarm);
drivers/power/pm8921-sec-charger-8930.c-	bms_notify_check(chip);
drivers/power/pm8921-sec-charger-8930.c:	cancel_delayed_work_sync(&chip->update_heartbeat_work);
drivers/power/pm8921-sec-charger-8930.c-						     (chip->update_time)));
drivers/power/pm8921-sec-charger-8930.c-	else
drivers/power/pm8921-sec-charger-8930.c-#endif
drivers/power/pm8921-sec-charger-8930.c-	enum pm8921_chg_cold_thr	cold_thr;
drivers/power/pm8921-sec-charger-8930.c-						     (EOC_CHECK_PERIOD_MS)));
drivers/power/pm8921-sec-charger-8930.c-						     (EOC_CHECK_PERIOD_MS)));
drivers/power/pm8921-sec-charger-8930.c-	high_transition = pm_chg_get_rt_status(chip, FASTCHG_IRQ);
drivers/power/pm8921-sec-charger-8930.c-#if 0
drivers/power/pm8921-sec-charger-8930.c-#if 0
drivers/power/pm8921-sec-charger-8930.c-	if (!chip->is_in_sleep) {
drivers/power/pm8921-sec-charger-8930.c-	if (chip->recent_reported_soc <= chip->batt_pdata->poweroff_check_soc ||
drivers/power/pm8921-sec-charger-8930.c-	if (chip->usb_present) {
drivers/power/pm8921-sec-charger-8930.c:		if (!delayed_work_pending(&chip->unplug_check_work))
drivers/power/pm8921-sec-charger-8930.c:	if (high_transition && !delayed_work_pending(&chip->eoc_work)) {
drivers/power/pm8921-sec-charger-8930.c-	if (ramp)
drivers/power/pm8921-sec-charger-8930.c-	if (usb_present) {
drivers/power/pm8921-sec-charger-8930.c-	if (usb_target_ma)
drivers/power/pm8921-sec-charger-8930.c-	if (usb_target_ma)
drivers/power/pm8921-sec-charger-8930.c-				if (x != chip->siop_level) {
drivers/power/pm8921-sec-charger-8930.c-	int				thermal_levels;
drivers/power/pm8921-sec-charger-8930.c-				      msecs_to_jiffies
drivers/power/pm8921-sec-charger-8930.c-		msecs_to_jiffies(UNPLUG_CHECK_RAMP_MS));
drivers/power/pm8921-sec-charger-8930.c-			msecs_to_jiffies(UNPLUG_CHECK_RAMP_MS));
drivers/power/pm8921-sec-charger-8930.c-			msecs_to_jiffies(UNPLUG_CHECK_RAMP_MS));
drivers/power/pm8921-sec-charger-8930.c-			msecs_to_jiffies(UNPLUG_CHECK_WAIT_PERIOD_MS));
drivers/power/pm8921-sec-charger-8930.c-			msecs_to_jiffies(UNPLUG_CHECK_WAIT_PERIOD_MS));
drivers/power/pm8921-sec-charger-8930.c-		pm8921_chg_enable_irq(chip, CHG_GONE_IRQ);
drivers/power/pm8921-sec-charger-8930.c-		pm8921_chg_enable_irq(chip, CHG_GONE_IRQ);
drivers/power/pm8921-sec-charger-8930.c-	pm8921_chg_enable_irq(chip, CHG_GONE_IRQ);
drivers/power/pm8921-sec-charger-8930.c-	pm8921_disable_source_current(true); /* Force BATFET=ON */
drivers/power/pm8921-sec-charger-8930.c-	power_supply_changed(&chip->batt_psy);
drivers/power/pm8921-sec-charger-8930.c-	power_supply_changed(&chip->usb_psy);
drivers/power/pm8921-sec-charger-8930.c-		pr_debug("EOC count = %d\n", count);
drivers/power/pm8921-sec-charger-8930.c-	pr_debug("%s end\n", __func__);
drivers/power/pm8921-sec-charger-8930.c-		pr_debug("usb_now=%d, usb_target = %d\n",
drivers/power/pm8921-sec-charger-8930.c-			round_jiffies_relative(msecs_to_jiffies
drivers/power/pm8921-sec-charger-8930.c-			round_jiffies_relative(msecs_to_jiffies
drivers/power/pm8921-sec-charger-8930.c-			      round_jiffies_relative(msecs_to_jiffies
drivers/power/pm8921-sec-charger-8930.c-			      round_jiffies_relative(msecs_to_jiffies
drivers/power/pm8921-sec-charger-8930.c-				      round_jiffies_relative(msecs_to_jiffies
drivers/power/pm8921-sec-charger-8930.c-					round_jiffies_relative(msecs_to_jiffies
drivers/power/pm8921-sec-charger-8930.c:		schedule_delayed_work(
drivers/power/pm8921-sec-charger-8930.c:					schedule_delayed_work(
drivers/power/pm8921-sec-charger-8930.c:		schedule_delayed_work(&chip->eoc_work,
drivers/power/pm8921-sec-charger-8930.c:		schedule_delayed_work(&chip->eoc_work,
drivers/power/pm8921-sec-charger-8930.c:	schedule_delayed_work(&chip->eoc_work, delay);
drivers/power/pm8921-sec-charger-8930.c:	schedule_delayed_work(&chip->unplug_check_work,
drivers/power/pm8921-sec-charger-8930.c:		schedule_delayed_work(&chip->unplug_check_work,
drivers/power/pm8921-sec-charger-8930.c:		schedule_delayed_work(&chip->unplug_check_work,
drivers/power/pm8921-sec-charger-8930.c:		schedule_delayed_work(&chip->unplug_check_work,
drivers/power/pm8921-sec-charger-8930.c:		schedule_delayed_work(&chip->unplug_check_work,
drivers/power/pm8921-sec-charger-8930.c:			schedule_delayed_work(&chip->unplug_check_work,
drivers/power/pm8921-sec-charger-8930.c:	schedule_delayed_work(&chip->update_heartbeat_work,
drivers/power/pm8921-sec-charger-8930.c:		schedule_delayed_work(&chip->update_heartbeat_work, 0);
drivers/power/pm8921-sec-charger-8930.c:		schedule_delayed_work(&chip->update_heartbeat_work, 0);
drivers/power/pm8921-sec-charger-8930.c:	schedule_delayed_work(&chip->update_heartbeat_work, 0);
drivers/power/pm8921-sec-charger-8930.c:	schedule_delayed_work(&chip->update_heartbeat_work, 0);
drivers/power/pm8921-sec-charger-8930.c:		schedule_delayed_work(&the_chip->vin_collapse_check_work,
drivers/power/pm8921-sec-charger-8930.c-	/* schedule to check again later */
drivers/power/pm8921-sec-charger-8930.c-	/* Start BMS */
drivers/power/pm8921-sec-charger-8930.c-static void eoc_worker(struct work_struct *work)
drivers/power/pm8921-sec-charger-8930.c-static void unplug_check_worker(struct work_struct *work)
drivers/power/pm8921-sec-charger-8930.c-static void update_heartbeat(struct work_struct *work)
drivers/power/pm8921-sec-charger-8930.c-static void vin_collapse_check_worker(struct work_struct *work)
drivers/power/pm8921-sec-charger-8930.c:	struct delayed_work *dwork = to_delayed_work(work);
drivers/power/pm8921-sec-charger-8930.c:	struct delayed_work *dwork = to_delayed_work(work);
drivers/power/pm8921-sec-charger-8930.c:	struct delayed_work *dwork = to_delayed_work(work);
drivers/power/pm8921-sec-charger-8930.c:	struct delayed_work *dwork = to_delayed_work(work);
drivers/power/pm8921-sec-charger-8930.c:	struct delayed_work		eoc_work;
drivers/power/pm8921-sec-charger-8930.c:	struct delayed_work		unplug_check_work;
drivers/power/pm8921-sec-charger-8930.c:	struct delayed_work		update_heartbeat_work;
drivers/power/pm8921-sec-charger-8930.c:	struct delayed_work		vin_collapse_check_work;
drivers/power/pm8921-sec-charger-8930.c-	struct pm8921_chg_chip *chip = container_of(dwork,
drivers/power/pm8921-sec-charger-8930.c-	struct pm8921_chg_chip *chip = container_of(dwork,
drivers/power/pm8921-sec-charger-8930.c-	struct pm8921_chg_chip *chip = container_of(dwork,
drivers/power/pm8921-sec-charger-8930.c-	struct pm8921_chg_chip *chip = container_of(dwork,
drivers/power/pm8921-sec-charger-8930.c-				struct pm8921_chg_chip, eoc_work);
drivers/power/pm8921-sec-charger-8930.c-				struct pm8921_chg_chip, unplug_check_work);
drivers/power/pm8921-sec-charger-8930.c-				struct pm8921_chg_chip, update_heartbeat_work);
drivers/power/pm8921-sec-charger-8930.c-			struct pm8921_chg_chip, vin_collapse_check_work);
drivers/power/pm8921-sec-charger-8930.c-	struct wake_lock		eoc_wake_lock;
drivers/power/pm8921-sec-charger-8930.c-			&the_chip->vin_collapse_check_work,
drivers/power/pm8921-sec-charger-8930.c-					&the_chip->vin_collapse_check_work,
drivers/power/pm8921-sec-charger-8930.c-						(UNPLUG_CHECK_WAIT_PERIOD_MS));
drivers/power/pm8921-sec-charger-8930.c-	unsigned int			*thermal_mitigation;
drivers/power/pm8921-sec-charger-8930.c-	/* Update battery charging LEDs and user space battery info */
drivers/power/pm8921-sec-charger-8930.c-				usb_target_ma = charging_current;
drivers/power/pm8921-sec-charger-8930.c-				USB_WALL_THRESHOLD_MA, usb_target_ma);
drivers/power/pm8921-sec-charger-8930.c-			(VIN_MIN_COLLAPSE_CHECK_MS)));
drivers/power/pm8921-sec-charger-8930.c-	wake_lock(&chip->eoc_wake_lock);
drivers/power/pm8921-sec-charger-8930.c-		wake_lock(&chip->eoc_wake_lock);
drivers/power/pm8921-sec-charger-8930.c-	wake_lock(&chip->monitor_wake_lock);
drivers/power/pm8921-sec-charger-8930.c-	wake_lock(&chip->monitor_wake_lock);
drivers/power/pm8921-sec-charger-8930.c-		wake_lock(&chip->monitor_wake_lock);
drivers/power/pm8921-sec-charger-8930.c-		wake_unlock(&chip->monitor_wake_lock);
drivers/power/pm8921-sec-charger.c-
drivers/power/pm8921-sec-charger.c-
drivers/power/pm8921-sec-charger.c-
drivers/power/pm8921-sec-charger.c-
drivers/power/pm8921-sec-charger.c-
drivers/power/pm8921-sec-charger.c-
drivers/power/pm8921-sec-charger.c-
drivers/power/pm8921-sec-charger.c-
drivers/power/pm8921-sec-charger.c-
drivers/power/pm8921-sec-charger.c-
drivers/power/pm8921-sec-charger.c-{
drivers/power/pm8921-sec-charger.c-{
drivers/power/pm8921-sec-charger.c-{
drivers/power/pm8921-sec-charger.c-{
drivers/power/pm8921-sec-charger.c-{
drivers/power/pm8921-sec-charger.c-}
drivers/power/pm8921-sec-charger.c-	}
drivers/power/pm8921-sec-charger.c-	 */
drivers/power/pm8921-sec-charger.c-			adjust_vdd_max_for_fastchg(chip, vbat_batt_terminal_uv);
drivers/power/pm8921-sec-charger.c:		cancel_delayed_work_sync(&chip->btc_override_work);
drivers/power/pm8921-sec-charger.c:	cancel_delayed_work_sync(&chip->update_heartbeat_work);
drivers/power/pm8921-sec-charger.c-					(chip->btc_delay_ms)));
drivers/power/pm8921-sec-charger.c-					(chip->btc_delay_ms)));
drivers/power/pm8921-sec-charger.c-						(chip->btc_delay_ms)));
drivers/power/pm8921-sec-charger.c-						(chip->btc_delay_ms)));
drivers/power/pm8921-sec-charger.c-						(chip->btc_delay_ms)));
drivers/power/pm8921-sec-charger.c-		&& chip->btc_override
drivers/power/pm8921-sec-charger.c-						     (chip->update_time)));
drivers/power/pm8921-sec-charger.c-							(chip->update_time)));
drivers/power/pm8921-sec-charger.c:		&& !delayed_work_pending(&chip->btc_override_work)) {
drivers/power/pm8921-sec-charger.c-	else
drivers/power/pm8921-sec-charger.c-	else
drivers/power/pm8921-sec-charger.c-	else
drivers/power/pm8921-sec-charger.c-	} else {
drivers/power/pm8921-sec-charger.c-	enum pm8921_chg_cold_thr	cold_thr;
drivers/power/pm8921-sec-charger.c-						     (EOC_CHECK_PERIOD_MS)));
drivers/power/pm8921-sec-charger.c-						     (EOC_CHECK_PERIOD_MS)));
drivers/power/pm8921-sec-charger.c-	/* for battery health when charger is not connected */
drivers/power/pm8921-sec-charger.c-		&& get_prop_batt_status(chip) != POWER_SUPPLY_STATUS_FULL) {
drivers/power/pm8921-sec-charger.c-	high_transition = pm_chg_get_rt_status(chip, FASTCHG_IRQ);
drivers/power/pm8921-sec-charger.c-		if (chip->btc_override)
drivers/power/pm8921-sec-charger.c-	if (chip->btc_override)
drivers/power/pm8921-sec-charger.c-	if (chip->btc_override)
drivers/power/pm8921-sec-charger.c-	if (chip->btc_override && !chg_present)
drivers/power/pm8921-sec-charger.c-	if (chip->btc_override && (is_dc_chg_plugged_in(the_chip) ||
drivers/power/pm8921-sec-charger.c-	if (chip->recent_reported_soc <= 20)
drivers/power/pm8921-sec-charger.c-	if (chip->update_time)
drivers/power/pm8921-sec-charger.c-	if (chip->usb_present || chip->dc_present) {
drivers/power/pm8921-sec-charger.c-		if (dc_present)
drivers/power/pm8921-sec-charger.c:		if (!delayed_work_pending(&chip->unplug_check_work))
drivers/power/pm8921-sec-charger.c-	if (high_transition
drivers/power/pm8921-sec-charger.c:	if (high_transition && !delayed_work_pending(&chip->eoc_work)) {
drivers/power/pm8921-sec-charger.c-	if ((is_dc_chg_plugged_in(the_chip) || is_usb_chg_plugged_in(the_chip))
drivers/power/pm8921-sec-charger.c-	if (is_usb_chg_plugged_in(chip)) {
drivers/power/pm8921-sec-charger.c-	if (ramp)
drivers/power/pm8921-sec-charger.c-	if (usb_present) {
drivers/power/pm8921-sec-charger.c-	if (usb_target_ma)
drivers/power/pm8921-sec-charger.c-	int rc = 0;
drivers/power/pm8921-sec-charger.c-	int temp;
drivers/power/pm8921-sec-charger.c-	int				thermal_levels;
drivers/power/pm8921-sec-charger.c-					is_usb_chg_plugged_in(the_chip)))
drivers/power/pm8921-sec-charger.c-						     (LOW_SOC_HEARTBEAT_MS)));
drivers/power/pm8921-sec-charger.c-				      msecs_to_jiffies
drivers/power/pm8921-sec-charger.c-			msecs_to_jiffies(UNPLUG_CHECK_RAMP_MS));
drivers/power/pm8921-sec-charger.c-			msecs_to_jiffies(UNPLUG_CHECK_RAMP_MS));
drivers/power/pm8921-sec-charger.c-			msecs_to_jiffies(UNPLUG_CHECK_RAMP_MS));
drivers/power/pm8921-sec-charger.c-			msecs_to_jiffies(UNPLUG_CHECK_WAIT_PERIOD_MS));
drivers/power/pm8921-sec-charger.c-			msecs_to_jiffies(UNPLUG_CHECK_WAIT_PERIOD_MS));
drivers/power/pm8921-sec-charger.c-				msecs_to_jiffies(UNPLUG_CHECK_WAIT_PERIOD_MS));
drivers/power/pm8921-sec-charger.c-			      msecs_to_jiffies(VIN_MIN_COLLAPSE_CHECK_MS));
drivers/power/pm8921-sec-charger.c-	notify_usb_of_the_plugin_event(chip->usb_present);
drivers/power/pm8921-sec-charger.c-		pm8921_chg_enable_irq(chip, CHG_GONE_IRQ);
drivers/power/pm8921-sec-charger.c-		pm8921_chg_enable_irq(chip, CHG_GONE_IRQ);
drivers/power/pm8921-sec-charger.c-	pm8921_disable_source_current(true);
drivers/power/pm8921-sec-charger.c-	power_supply_changed(&chip->batt_psy);
drivers/power/pm8921-sec-charger.c-		power_supply_changed(&chip->dc_psy);
drivers/power/pm8921-sec-charger.c-		pr_debug("EOC count = %d\n", count);
drivers/power/pm8921-sec-charger.c-		pr_debug("usb_now=%d, usb_target = %d\n",
drivers/power/pm8921-sec-charger.c-	return 0;
drivers/power/pm8921-sec-charger.c-			round_jiffies_relative(msecs_to_jiffies
drivers/power/pm8921-sec-charger.c-			      round_jiffies_relative(msecs_to_jiffies
drivers/power/pm8921-sec-charger.c-			      round_jiffies_relative(msecs_to_jiffies
drivers/power/pm8921-sec-charger.c-			      round_jiffies_relative(msecs_to_jiffies
drivers/power/pm8921-sec-charger.c-				round_jiffies_relative(msecs_to_jiffies
drivers/power/pm8921-sec-charger.c-				      round_jiffies_relative(msecs_to_jiffies
drivers/power/pm8921-sec-charger.c-				      round_jiffies_relative(msecs_to_jiffies
drivers/power/pm8921-sec-charger.c-					round_jiffies_relative(msecs_to_jiffies
drivers/power/pm8921-sec-charger.c-					round_jiffies_relative(msecs_to_jiffies
drivers/power/pm8921-sec-charger.c-					round_jiffies_relative(msecs_to_jiffies
drivers/power/pm8921-sec-charger.c:		schedule_delayed_work(&chip->btc_override_work,
drivers/power/pm8921-sec-charger.c:		schedule_delayed_work(&chip->btc_override_work,
drivers/power/pm8921-sec-charger.c:		schedule_delayed_work(&chip->btc_override_work,
drivers/power/pm8921-sec-charger.c:		schedule_delayed_work(&chip->btc_override_work,
drivers/power/pm8921-sec-charger.c:			schedule_delayed_work(&chip->btc_override_work,
drivers/power/pm8921-sec-charger.c:		schedule_delayed_work(&chip->btc_override_work, 0);
drivers/power/pm8921-sec-charger.c:		schedule_delayed_work(&chip->eoc_work,
drivers/power/pm8921-sec-charger.c:		schedule_delayed_work(&chip->eoc_work,
drivers/power/pm8921-sec-charger.c:	schedule_delayed_work(&chip->eoc_work, delay);
drivers/power/pm8921-sec-charger.c:	schedule_delayed_work(&chip->unplug_check_work,
drivers/power/pm8921-sec-charger.c:		schedule_delayed_work(&chip->unplug_check_work,
drivers/power/pm8921-sec-charger.c:		schedule_delayed_work(&chip->unplug_check_work,
drivers/power/pm8921-sec-charger.c:		schedule_delayed_work(&chip->unplug_check_work,
drivers/power/pm8921-sec-charger.c:		schedule_delayed_work(&chip->unplug_check_work,
drivers/power/pm8921-sec-charger.c:			schedule_delayed_work(&chip->unplug_check_work,
drivers/power/pm8921-sec-charger.c:			schedule_delayed_work(&chip->unplug_check_work,
drivers/power/pm8921-sec-charger.c:		schedule_delayed_work(&chip->update_heartbeat_work,
drivers/power/pm8921-sec-charger.c:		schedule_delayed_work(&chip->update_heartbeat_work,
drivers/power/pm8921-sec-charger.c:		schedule_delayed_work(&chip->update_heartbeat_work,
drivers/power/pm8921-sec-charger.c:	schedule_delayed_work(&chip->update_heartbeat_work, 0);
drivers/power/pm8921-sec-charger.c:		schedule_delayed_work(&the_chip->vin_collapse_check_work,
drivers/power/pm8921-sec-charger.c-	/* schedule to check again later */
drivers/power/pm8921-sec-charger.c-static void eoc_worker(struct work_struct *work)
drivers/power/pm8921-sec-charger.c-static void unplug_check_worker(struct work_struct *work)
drivers/power/pm8921-sec-charger.c-static void update_heartbeat(struct work_struct *work)
drivers/power/pm8921-sec-charger.c-static void vin_collapse_check_worker(struct work_struct *work)
drivers/power/pm8921-sec-charger.c:	struct delayed_work		btc_override_work;
drivers/power/pm8921-sec-charger.c:	struct delayed_work *dwork = to_delayed_work(work);
drivers/power/pm8921-sec-charger.c:	struct delayed_work *dwork = to_delayed_work(work);
drivers/power/pm8921-sec-charger.c:	struct delayed_work *dwork = to_delayed_work(work);
drivers/power/pm8921-sec-charger.c:	struct delayed_work *dwork = to_delayed_work(work);
drivers/power/pm8921-sec-charger.c:	struct delayed_work *dwork = to_delayed_work(work);
drivers/power/pm8921-sec-charger.c:	struct delayed_work		eoc_work;
drivers/power/pm8921-sec-charger.c:	struct delayed_work		unplug_check_work;
drivers/power/pm8921-sec-charger.c:	struct delayed_work		update_heartbeat_work;
drivers/power/pm8921-sec-charger.c:	struct delayed_work		vin_collapse_check_work;
drivers/power/pm8921-sec-charger.c-				struct pm8921_chg_chip, btc_override_work);
drivers/power/pm8921-sec-charger.c-	struct pm8921_chg_chip *chip = container_of(dwork,
drivers/power/pm8921-sec-charger.c-	struct pm8921_chg_chip *chip = container_of(dwork,
drivers/power/pm8921-sec-charger.c-	struct pm8921_chg_chip *chip = container_of(dwork,
drivers/power/pm8921-sec-charger.c-	struct pm8921_chg_chip *chip = container_of(dwork,
drivers/power/pm8921-sec-charger.c-	struct pm8921_chg_chip *chip = container_of(dwork,
drivers/power/pm8921-sec-charger.c-	struct pm8921_chg_chip *chip = dev_get_drvdata(dev);
drivers/power/pm8921-sec-charger.c-				struct pm8921_chg_chip, eoc_work);
drivers/power/pm8921-sec-charger.c-				struct pm8921_chg_chip, unplug_check_work);
drivers/power/pm8921-sec-charger.c-				struct pm8921_chg_chip, update_heartbeat_work);
drivers/power/pm8921-sec-charger.c-			struct pm8921_chg_chip, vin_collapse_check_work);
drivers/power/pm8921-sec-charger.c-	struct wake_lock		eoc_wake_lock;
drivers/power/pm8921-sec-charger.c-						(UNPLUG_CHECK_WAIT_PERIOD_MS));
drivers/power/pm8921-sec-charger.c-	unsigned int			*thermal_mitigation;
drivers/power/pm8921-sec-charger.c-				USB_WALL_THRESHOLD_MA, usb_target_ma);
drivers/power/pm8921-sec-charger.c-	 * use eoc worker to detect end of charging
drivers/power/pm8921-sec-charger.c-	wake_lock(&chip->eoc_wake_lock);
drivers/power/pm8921-sec-charger.c-		wake_lock(&chip->eoc_wake_lock);
drivers/power/pm8xxx-ccadc.c-
drivers/power/pm8xxx-ccadc.c-
drivers/power/pm8xxx-ccadc.c-
drivers/power/pm8xxx-ccadc.c-
drivers/power/pm8xxx-ccadc.c-	bool			periodic_wakeup;
drivers/power/pm8xxx-ccadc.c:	cancel_delayed_work_sync(&chip->calib_ccadc_work);
drivers/power/pm8xxx-ccadc.c-			(chip->calib_delay_ms)));
drivers/power/pm8xxx-ccadc.c-	create_debugfs_entries(chip);
drivers/power/pm8xxx-ccadc.c-		} else {
drivers/power/pm8xxx-ccadc.c-	INIT_DELAYED_WORK(&chip->calib_ccadc_work, calibrate_ccadc_work);
drivers/power/pm8xxx-ccadc.c-	int			eoc_irq;
drivers/power/pm8xxx-ccadc.c-	int			r_sense_uohm;
drivers/power/pm8xxx-ccadc.c-				msecs_to_jiffies(the_chip->calib_delay_ms -
drivers/power/pm8xxx-ccadc.c-	pm8xxx_calib_ccadc();
drivers/power/pm8xxx-ccadc.c-	return 0;
drivers/power/pm8xxx-ccadc.c-			round_jiffies_relative(msecs_to_jiffies
drivers/power/pm8xxx-ccadc.c:	schedule_delayed_work(&chip->calib_ccadc_work,
drivers/power/pm8xxx-ccadc.c:	schedule_delayed_work(&chip->calib_ccadc_work, 0);
drivers/power/pm8xxx-ccadc.c:			schedule_delayed_work(&the_chip->calib_ccadc_work,
drivers/power/pm8xxx-ccadc.c:			schedule_delayed_work(&the_chip->calib_ccadc_work, 0);
drivers/power/pm8xxx-ccadc.c:	struct delayed_work	calib_ccadc_work;
drivers/power/pm8xxx-ccadc.c-	struct mutex		calib_mutex;
drivers/power/pm8xxx-ccadc.c-	struct pm8xxx_ccadc_chip *chip = dev_get_drvdata(dev);
drivers/power/pm8xxx-ccadc.c-	the_chip = chip;
drivers/power/pm8xxx-ccadc.c-			the_chip->last_calib_temp = batt_temp;
drivers/power/pm8xxx-ccadc.c-			the_chip->last_calib_time = current_time_sec;
drivers/power/pm8xxx-ccadc.c-					(time_since_last_calib * 1000)));
drivers/power/pmic8058-charger.c-
drivers/power/pmic8058-charger.c-
drivers/power/pmic8058-charger.c-
drivers/power/pmic8058-charger.c-
drivers/power/pmic8058-charger.c-
drivers/power/pmic8058-charger.c-
drivers/power/pmic8058-charger.c-
drivers/power/pmic8058-charger.c-
drivers/power/pmic8058-charger.c-	/*
drivers/power/pmic8058-charger.c-	 */
drivers/power/pmic8058-charger.c-		 */
drivers/power/pmic8058-charger.c-			/*
drivers/power/pmic8058-charger.c-			     (AUTO_CHARGING_DONE_CHECK_TIME_MS)));
drivers/power/pmic8058-charger.c-			     (AUTO_CHARGING_VBATDET_DEBOUNCE_TIME_MS)));
drivers/power/pmic8058-charger.c-				     (AUTO_CHARGING_VEOC_BEGIN_TIME_MS)));
drivers/power/pmic8058-charger.c-			     (AUTO_CHARGING_VEOC_VBAT_LOW_CHECK_TIME_MS)));
drivers/power/pmic8058-charger.c-				"begin veoc timer\n", __func__);
drivers/power/pmic8058-charger.c:			cancel_delayed_work_sync(
drivers/power/pmic8058-charger.c:	cancel_delayed_work_sync(&pm8058_chg.charging_check_work);
drivers/power/pmic8058-charger.c:	cancel_delayed_work_sync(&pm8058_chg.charging_check_work);
drivers/power/pmic8058-charger.c:	cancel_delayed_work_sync(&pm8058_chg.charging_check_work);
drivers/power/pmic8058-charger.c:	cancel_delayed_work_sync(&pm8058_chg.check_vbat_low_work);
drivers/power/pmic8058-charger.c:	cancel_delayed_work_sync(&pm8058_chg.check_vbat_low_work);
drivers/power/pmic8058-charger.c:	cancel_delayed_work_sync(&pm8058_chg.check_vbat_low_work);
drivers/power/pmic8058-charger.c:	cancel_delayed_work_sync(&pm8058_chg.chg_done_check_work);
drivers/power/pmic8058-charger.c:	cancel_delayed_work_sync(&pm8058_chg.veoc_begin_work);
drivers/power/pmic8058-charger.c:	cancel_delayed_work_sync(&pm8058_chg.veoc_begin_work);
drivers/power/pmic8058-charger.c:	cancel_delayed_work_sync(&pm8058_chg.veoc_begin_work);
drivers/power/pmic8058-charger.c-	DECLARE_BITMAP(enabled_irqs, PMIC_CHG_MAX_INTS);
drivers/power/pmic8058-charger.c-	 * delay.
drivers/power/pmic8058-charger.c:			&& !delayed_work_pending(&pm8058_chg.veoc_begin_work)) {
drivers/power/pmic8058-charger.c-		dev_info(pm8058_chg.dev, "%s begin veoc timer\n", __func__);
drivers/power/pmic8058-charger.c-			dev_info(pm8058_chg.dev, "%s entered constant voltage"
drivers/power/pmic8058-charger.c-		dev_info(pm8058_chg.dev, "%s monitoring vbat_low for a"
drivers/power/pmic8058-charger.c-	} else {
drivers/power/pmic8058-charger.c-	free_irqs();
drivers/power/pmic8058-charger.c:	if (!delayed_work_pending(&pm8058_chg.chg_done_check_work)) {
drivers/power/pmic8058-charger.c-		if (pm8058_chg.vbatdet == AUTO_CHARGING_VBATDET
drivers/power/pmic8058-charger.c-		if (pm8058_chg.vbatdet == AUTO_CHARGING_VEOC_VBATDET) {
drivers/power/pmic8058-charger.c-	if (ret) {
drivers/power/pmic8058-charger.c-	int ret = 0;
drivers/power/pmic8058-charger.c-	int waiting_for_topoff;
drivers/power/pmic8058-charger.c-	int waiting_for_veoc;
drivers/power/pmic8058-charger.c-			"minute\n", __func__);
drivers/power/pmic8058-charger.c-				      (msecs_to_jiffies
drivers/power/pmic8058-charger.c-	msm_charger_notify_event(&usb_hw_chg, CHG_REMOVED_EVENT);
drivers/power/pmic8058-charger.c-	msm_charger_unregister(&usb_hw_chg);
drivers/power/pmic8058-charger.c-				&pm8058_chg.check_vbat_low_work);
drivers/power/pmic8058-charger.c-	pm8058_chg_disable_irq(AUTO_CHGDONE_IRQ);
drivers/power/pmic8058-charger.c-	pm8058_chg_disable_irq(AUTO_CHGDONE_IRQ);
drivers/power/pmic8058-charger.c-	pm8058_chg_disable_irq(CHG_END_IRQ);
drivers/power/pmic8058-charger.c-	pm8058_chg_disable_irq(VBATDET_IRQ);
drivers/power/pmic8058-charger.c-	pm8058_chg_disable_irq(VBATDET_LOW_IRQ);
drivers/power/pmic8058-charger.c-	remove_debugfs_entries();
drivers/power/pmic8058-charger.c-	ret = pm_chg_get_rt_status(pm8058_chg.pmic_chg_irq[FASTCHG_IRQ]);
drivers/power/pmic8058-charger.c-				      round_jiffies_relative
drivers/power/pmic8058-charger.c-				      round_jiffies_relative(msecs_to_jiffies
drivers/power/pmic8058-charger.c-				      round_jiffies_relative(msecs_to_jiffies
drivers/power/pmic8058-charger.c-				      round_jiffies_relative(msecs_to_jiffies
drivers/power/pmic8058-charger.c-				      round_jiffies_relative(msecs_to_jiffies
drivers/power/pmic8058-charger.c:	schedule_delayed_work(&pm8058_chg.charging_check_work,
drivers/power/pmic8058-charger.c:		schedule_delayed_work(&pm8058_chg.check_vbat_low_work,
drivers/power/pmic8058-charger.c:		schedule_delayed_work(&pm8058_chg.chg_done_check_work,
drivers/power/pmic8058-charger.c:		schedule_delayed_work(&pm8058_chg.veoc_begin_work,
drivers/power/pmic8058-charger.c:			schedule_delayed_work(&pm8058_chg.veoc_begin_work,
drivers/power/pmic8058-charger.c:	struct delayed_work charging_check_work;
drivers/power/pmic8058-charger.c:	struct delayed_work check_vbat_low_work;
drivers/power/pmic8058-charger.c:	struct delayed_work chg_done_check_work;
drivers/power/pmic8058-charger.c:	struct delayed_work veoc_begin_work;
drivers/power/pmic8058-charger.c-			 * we are in constant voltage phase of charging
drivers/power/s3c_adc_battery.c-
drivers/power/s3c_adc_battery.c-
drivers/power/s3c_adc_battery.c-
drivers/power/s3c_adc_battery.c-
drivers/power/s3c_adc_battery.c-
drivers/power/s3c_adc_battery.c-
drivers/power/s3c_adc_battery.c-
drivers/power/s3c_adc_battery.c-
drivers/power/s3c_adc_battery.c-{
drivers/power/s3c_adc_battery.c-{
drivers/power/s3c_adc_battery.c-}
drivers/power/s3c_adc_battery.c-};
drivers/power/s3c_adc_battery.c-	}
drivers/power/s3c_adc_battery.c:	cancel_delayed_work(&bat_work);
drivers/power/s3c_adc_battery.c-	if (pdata->exit)
drivers/power/s3c_adc_battery.c-		msecs_to_jiffies(JITTER_DELAY));
drivers/power/s3c_adc_battery.c-		msecs_to_jiffies(JITTER_DELAY));
drivers/power/s3c_adc_battery.c-		msecs_to_jiffies(JITTER_DELAY));
drivers/power/s3c_adc_battery.c-		msecs_to_jiffies(JITTER_DELAY));
drivers/power/s3c_adc_battery.c-	return IRQ_HANDLED;
drivers/power/s3c_adc_battery.c:	schedule_delayed_work(&bat_work,
drivers/power/s3c_adc_battery.c:	schedule_delayed_work(&bat_work,
drivers/power/s3c_adc_battery.c:	schedule_delayed_work(&bat_work,
drivers/power/s3c_adc_battery.c:	schedule_delayed_work(&bat_work,
drivers/power/s3c_adc_battery.c-	/* Schedule timer to check current status */
drivers/power/s3c_adc_battery.c-	/* Schedule timer to check current status */
drivers/power/s3c_adc_battery.c-static irqreturn_t s3c_adc_bat_charged(int irq, void *dev_id)
drivers/power/s3c_adc_battery.c:static struct delayed_work bat_work;
drivers/power/s3c_adc_battery.c-static void s3c_adc_bat_ext_power_changed(struct power_supply *psy)
drivers/power/sbs-battery.c-
drivers/power/sbs-battery.c-
drivers/power/sbs-battery.c-
drivers/power/sbs-battery.c-
drivers/power/sbs-battery.c-
drivers/power/sbs-battery.c-
drivers/power/sbs-battery.c-
drivers/power/sbs-battery.c-
drivers/power/sbs-battery.c-
drivers/power/sbs-battery.c-{
drivers/power/sbs-battery.c-}
drivers/power/sbs-battery.c-};
drivers/power/sbs-battery.c-	}
drivers/power/sbs-battery.c:	cancel_delayed_work_sync(&chip->work);
drivers/power/sbs-battery.c:	cancel_delayed_work_sync(&chip->work);
drivers/power/sbs-battery.c:		cancel_delayed_work_sync(&chip->work);
drivers/power/sbs-battery.c:			cancel_delayed_work_sync(&chip->work);
drivers/power/sbs-battery.c-	/* cancel outstanding work */
drivers/power/sbs-battery.c-	chip->enable_detection = true;
drivers/power/sbs-battery.c-			chip->last_state = val->intval;
drivers/power/sbs-battery.c-		chip->poll_time--;
drivers/power/sbs-battery.c-			chip->poll_time = 0;
drivers/power/sbs-battery.c-	chip->poll_time = chip->pdata->poll_retry_count;
drivers/power/sbs-battery.c-		else if (chip->last_state != val->intval) {
drivers/power/sbs-battery.c-	if (chip->poll_time > 0)
drivers/power/sbs-battery.c-	if (chip->poll_time > 0) {
drivers/power/sbs-battery.c:	INIT_DELAYED_WORK(&chip->work, sbs_delayed_work);
drivers/power/sbs-battery.c-	int				ignore_changes;
drivers/power/sbs-battery.c-	int				last_state;
drivers/power/sbs-battery.c-	int				poll_time;
drivers/power/sbs-battery.c-	kfree(chip->power_supply.name);
drivers/power/sbs-battery.c-			power_supply_changed(&chip->power_supply);
drivers/power/sbs-battery.c-	power_supply_unregister(&chip->power_supply);
drivers/power/sbs-battery.c-		return;
drivers/power/sbs-battery.c-		"%s: battery gas gauge device registered\n", client->name);
drivers/power/sbs-battery.c:		schedule_delayed_work(&chip->work, HZ);
drivers/power/sbs-battery.c:	schedule_delayed_work(&chip->work, HZ);
drivers/power/sbs-battery.c:static void sbs_delayed_work(struct work_struct *work)
drivers/power/sbs-battery.c:	struct delayed_work		work;
drivers/power/sbs-battery.c-	struct sbs_info *chip;
drivers/power/sbs-battery.c-	/* write to manufacturer access with sleep command */
drivers/power/sec_battery.c-
drivers/power/sec_battery.c-
drivers/power/sec_battery.c-
drivers/power/sec_battery.c-
drivers/power/sec_battery.c-
drivers/power/sec_battery.c-
drivers/power/sec_battery.c-
drivers/power/sec_battery.c-
drivers/power/sec_battery.c-
drivers/power/sec_battery.c-	}
drivers/power/sec_battery.c-		}
drivers/power/sec_battery.c-		}
drivers/power/sec_battery.c-		}
drivers/power/sec_battery.c-		}
drivers/power/sec_battery.c-		}
drivers/power/sec_battery.c-		}
drivers/power/sec_battery.c-		}*/
drivers/power/sec_battery.c-			}
drivers/power/sec_battery.c-			}
drivers/power/sec_battery.c-							   0);
drivers/power/sec_battery.c-							   0);
drivers/power/sec_battery.c-							   0);
drivers/power/sec_battery.c-							   0);
drivers/power/sec_battery.c-						  5 * HZ);
drivers/power/sec_battery.c-	/*add alarm monitoring */
drivers/power/sec_battery.c-		break;
drivers/power/sec_battery.c-		break;
drivers/power/sec_battery.c:	cancel_delayed_work(&info->cable_work);
drivers/power/sec_battery.c:	cancel_delayed_work(&info->cable_work);
drivers/power/sec_battery.c:	cancel_delayed_work(&info->measure_work);
drivers/power/sec_battery.c:	cancel_delayed_work(&info->measure_work);
drivers/power/sec_battery.c:		cancel_delayed_work(&info->measure_work);
drivers/power/sec_battery.c:		cancel_delayed_work(&info->measure_work);
drivers/power/sec_battery.c:			cancel_delayed_work(&info->measure_work);
drivers/power/sec_battery.c:			cancel_delayed_work(&info->measure_work);
drivers/power/sec_battery.c:			cancel_delayed_work(&info->measure_work);
drivers/power/sec_battery.c:				cancel_delayed_work(&info->measure_work);
drivers/power/sec_battery.c:				cancel_delayed_work(&info->measure_work);
drivers/power/sec_battery.c:	cancel_delayed_work(&info->otg_work);
drivers/power/sec_battery.c:	cancel_delayed_work(&info->otg_work);
drivers/power/sec_battery.c-	cancel_work_sync(&info->monitor_work);
drivers/power/sec_battery.c-	case POWER_SUPPLY_PROP_OTG:
drivers/power/sec_battery.c-		container_of(alarm, struct sec_bat_info, alarm);
drivers/power/sec_battery.c-	default:
drivers/power/sec_battery.c-	destroy_workqueue(info->monitor_wqueue);
drivers/power/sec_battery.c-	} else {
drivers/power/sec_battery.c-		} else {
drivers/power/sec_battery.c-			} else {
drivers/power/sec_battery.c-	} else if (isFirstCheck) {
drivers/power/sec_battery.c-		} else if (val->intval == POWER_SUPPLY_STATUS_DISCHARGING) {
drivers/power/sec_battery.c-				__func__);
drivers/power/sec_battery.c-								__func__, ret);
drivers/power/sec_battery.c-				   HZ);
drivers/power/sec_battery.c-				   HZ);
drivers/power/sec_battery.c-				   HZ / 2);
drivers/power/sec_battery.c-				   HZ / 2);
drivers/power/sec_battery.c-#if defined(CONFIG_MACH_M2_REFRESHSPR)
drivers/power/sec_battery.c-	if (info->initial_check_count) {
drivers/power/sec_battery.c-		if (info->prev_cable != info->cable_type) {
drivers/power/sec_battery.c-		info->batt_full_status = BATT_NOT_FULL;
drivers/power/sec_battery.c-				(info->batt_health
drivers/power/sec_battery.c-					info->cable_type = CABLE_TYPE_NONE;
drivers/power/sec_battery.c-					info->cable_type = CABLE_TYPE_NONE;
drivers/power/sec_battery.c-					info->cable_type = CABLE_TYPE_UNKNOWN;
drivers/power/sec_battery.c-					info->cable_type = CABLE_TYPE_UNKNOWN;
drivers/power/sec_battery.c-					&info->cable_work,
drivers/power/sec_battery.c-							   &info->cable_work,
drivers/power/sec_battery.c-							   &info->cable_work,
drivers/power/sec_battery.c-							   &info->cable_work,
drivers/power/sec_battery.c-							   &info->cable_work,
drivers/power/sec_battery.c-					   &info->cable_work, 0);
drivers/power/sec_battery.c-				&info->cable_work, 0);
drivers/power/sec_battery.c-				&info->cable_work, 0);
drivers/power/sec_battery.c-					   &info->cable_work, HZ);
drivers/power/sec_battery.c-		info->charging_status = POWER_SUPPLY_STATUS_CHARGING;
drivers/power/sec_battery.c-	info->cur_monitor_time = alarm_get_elapsed_realtime();
drivers/power/sec_battery.c-			info->dcin_intr_triggered = false;
drivers/power/sec_battery.c-			info->dcin_intr_triggered = true;
drivers/power/sec_battery.c-		info->initial_check_count--;
drivers/power/sec_battery.c-				info->measure_interval = MEASURE_CHG_INTERVAL;
drivers/power/sec_battery.c-		info->measure_interval = MEASURE_CHG_INTERVAL;
drivers/power/sec_battery.c-				info->measure_interval = MEASURE_DSG_INTERVAL;
drivers/power/sec_battery.c-		info->measure_interval = MEASURE_DSG_INTERVAL;
drivers/power/sec_battery.c-						   &info->measure_work, 0);
drivers/power/sec_battery.c-						   &info->measure_work, 0);
drivers/power/sec_battery.c-					   &info->measure_work, HZ);
drivers/power/sec_battery.c-					   &info->measure_work, HZ);
drivers/power/sec_battery.c-					   &info->measure_work, HZ);
drivers/power/sec_battery.c-		info->otg_state = val->intval;
drivers/power/sec_battery.c-		info->recharging_status = false;
drivers/power/sec_battery.c-		info->slow_polling = 0;
drivers/power/sec_battery.c-				info->test_info.test_esuspend = 1;
drivers/power/sec_battery.c-					is_charging_disabled = 0;
drivers/power/sec_battery.c-					is_charging_disabled = 0;
drivers/power/sec_battery.c-					is_charging_disabled = 1;
drivers/power/sec_battery.c-					is_charging_disabled = 1;
drivers/power/sec_battery.c-			local_irq_restore(flags);
drivers/power/sec_battery.c-					msecs_to_jiffies(500));
drivers/power/sec_battery.c-				   msecs_to_jiffies(info->measure_interval));
drivers/power/sec_battery.c-	pdata->get_cable_type();
drivers/power/sec_battery.c-					== POWER_SUPPLY_HEALTH_GOOD)) {
drivers/power/sec_battery.c-	power_supply_unregister(&info->psy_bat);
drivers/power/sec_battery.c-	pr_info("[BATT] battery suspend!##\n");
drivers/power/sec_battery.c-			pr_info("%s: charger inserted!!\n", __func__);
drivers/power/sec_battery.c-			pr_info("%s: charger removed!!\n", __func__);
drivers/power/sec_battery.c-			pr_info("%s : default charger state, set again\n",
drivers/power/sec_battery.c:			queue_delayed_work(info->monitor_wqueue,
drivers/power/sec_battery.c:			queue_delayed_work(info->monitor_wqueue,
drivers/power/sec_battery.c:			queue_delayed_work(info->monitor_wqueue,
drivers/power/sec_battery.c:			queue_delayed_work(info->monitor_wqueue,
drivers/power/sec_battery.c:			queue_delayed_work(info->monitor_wqueue,
drivers/power/sec_battery.c:			queue_delayed_work(info->monitor_wqueue,
drivers/power/sec_battery.c:			queue_delayed_work(info->monitor_wqueue,
drivers/power/sec_battery.c:				queue_delayed_work(info->monitor_wqueue,
drivers/power/sec_battery.c:				queue_delayed_work(info->monitor_wqueue,
drivers/power/sec_battery.c:				queue_delayed_work(info->monitor_wqueue,
drivers/power/sec_battery.c:					queue_delayed_work(info->monitor_wqueue,
drivers/power/sec_battery.c:					queue_delayed_work(info->monitor_wqueue,
drivers/power/sec_battery.c:					queue_delayed_work(info->monitor_wqueue,
drivers/power/sec_battery.c:					queue_delayed_work(info->monitor_wqueue,
drivers/power/sec_battery.c:		queue_delayed_work(info->monitor_wqueue, &info->measure_work,
drivers/power/sec_battery.c:		queue_delayed_work(info->monitor_wqueue, &info->measure_work,
drivers/power/sec_battery.c:		queue_delayed_work(info->monitor_wqueue, &info->measure_work,
drivers/power/sec_battery.c:		queue_delayed_work(info->monitor_wqueue, &info->measure_work,
drivers/power/sec_battery.c:		queue_delayed_work(info->monitor_wqueue, &info->measure_work,
drivers/power/sec_battery.c:	queue_delayed_work(info->monitor_wqueue, &info->measure_work, 0);
drivers/power/sec_battery.c:	queue_delayed_work(info->monitor_wqueue, &info->measure_work, 0);
drivers/power/sec_battery.c:	queue_delayed_work(info->monitor_wqueue, &info->measure_work, 0);
drivers/power/sec_battery.c:		queue_delayed_work(info->monitor_wqueue, &info->otg_work, 0);
drivers/power/sec_battery.c-		queue_work(info->monitor_wqueue, &info->monitor_work);
drivers/power/sec_battery.c-	queue_work(info->monitor_wqueue, &info->monitor_work);
drivers/power/sec_battery.c-	queue_work(info->monitor_wqueue, &info->monitor_work);
drivers/power/sec_battery.c-	queue_work(info->monitor_wqueue, &info->monitor_work);
drivers/power/sec_battery.c-				return -EINVAL;
drivers/power/sec_battery.c-		sec_bat_enable_charging(info, false);
drivers/power/sec_battery.c-		sec_bat_enable_charging(info, true);
drivers/power/sec_battery.c:	struct delayed_work cable_work;
drivers/power/sec_battery.c:	struct delayed_work measure_work;
drivers/power/sec_battery.c:	struct delayed_work otg_work;
drivers/power/sec_battery.c-	struct power_suspend bat_power_suspend;
drivers/power/sec_battery.c-	struct sec_temperature_spec tspec;
drivers/power/sec_battery.c-	struct workqueue_struct *monitor_wqueue;
drivers/power/sec_battery.c-	struct work_struct monitor_work;
drivers/power/sec_battery.c-				wake_lock(&info->test_wake_lock);
drivers/power/sec_battery.c-				wake_lock_timeout(&info->cable_wake_lock, 2*HZ);
drivers/power/sec_battery.c-			wake_lock_timeout(&info->cable_wake_lock, 2*HZ);
drivers/power/sec_battery.c-				wake_lock_timeout(&info->test_wake_lock,
drivers/power/sec_battery.c-		wake_lock_timeout(&info->vbus_wake_lock, 5 * HZ);
drivers/power/sec_battery.c-		wake_lock_timeout(&info->vbus_wake_lock, 5 * HZ);
drivers/power/smb137b.c-
drivers/power/smb137b.c-
drivers/power/smb137b.c-
drivers/power/smb137b.c-
drivers/power/smb137b.c-}
drivers/power/smb137b.c-	}
drivers/power/smb137b.c-	bool charging;
drivers/power/smb137b.c:	cancel_delayed_work_sync(&smb137b_chg->charge_work);
drivers/power/smb137b.c-	free_irq(client->irq, client);
drivers/power/smb137b.c-	gpio_free(pdata->valid_n_gpio);
drivers/power/smb137b.c-	msm_charger_notify_event(&smb137b_chg->adapter_hw_chg,
drivers/power/smb137b.c-out:
drivers/power/smb137b.c-out:
drivers/power/smb137b.c-	/*schedule charge_work to keep track of battery charging state*/
drivers/power/smb137b.c:	schedule_delayed_work(&smb137b_chg->charge_work,
drivers/power/smb137b.c:	schedule_delayed_work(&smb137b_chg->charge_work, SMB137B_CHG_PERIOD);
drivers/power/smb137b.c-					SMB137B_CHG_PERIOD);
drivers/power/smb137b.c:	struct delayed_work charge_work;
drivers/power/smb137b.c-	struct i2c_client *client;
drivers/power/smb137b.c-struct smb137b_data {
drivers/regulator/core.c-
drivers/regulator/core.c-	if (ret < 0)
drivers/regulator/core.c-				    msecs_to_jiffies(ms));
drivers/regulator/core.c-	mutex_unlock(&rdev->mutex);
drivers/regulator/core.c:	ret = schedule_delayed_work(&rdev->disable_work,
drivers/rtc/rtc-88pm860x.c-
drivers/rtc/rtc-88pm860x.c-
drivers/rtc/rtc-88pm860x.c-	/* calibrate VRTC */
drivers/rtc/rtc-88pm860x.c-	dev_dbg(info->dev, "set 0x%x to RTC_MISC1\n", data);
drivers/rtc/rtc-88pm860x.c-#endif	/* VRTC_CALIBRATION */
drivers/rtc/rtc-88pm860x.c-	INIT_DELAYED_WORK(&info->calib_work, calibrate_vrtc_work);
drivers/rtc/rtc-88pm860x.c-	int			irq;
drivers/rtc/rtc-88pm860x.c-out:
drivers/rtc/rtc-88pm860x.c-	return;
drivers/rtc/rtc-88pm860x.c:	schedule_delayed_work(&info->calib_work, VRTC_CALIB_INTERVAL);
drivers/rtc/rtc-88pm860x.c:	schedule_delayed_work(&info->calib_work, VRTC_CALIB_INTERVAL);
drivers/rtc/rtc-88pm860x.c:	struct delayed_work	calib_work;
drivers/rtc/rtc-88pm860x.c-	struct device		*dev;
drivers/rtc/rtc-88pm860x.c-	struct rtc_device	*rtc_dev;
drivers/rtc/rtc-88pm860x.c-	/* trigger next calibration since VRTC is updated */
drivers/s390/block/dasd_alias.c-}
drivers/s390/block/dasd_alias.c-			    " alias data in lcu (rc = %d), retry later", rc);
drivers/s390/block/dasd_alias.c:		cancel_delayed_work_sync(&lcu->ruac_data.dwork);
drivers/s390/block/dasd_alias.c-		DBF_DEV_EVENT(DBF_WARNING, device, "could not update"
drivers/s390/block/dasd_alias.c-	} else {
drivers/s390/block/dasd_alias.c-		if (device == lcu->ruac_data.device)
drivers/s390/block/dasd_alias.c-		lcu->ruac_data.device = NULL;
drivers/s390/block/dasd_alias.c-	lcu->ruac_data.device = usedev;
drivers/s390/block/dasd_alias.c-	return 0;
drivers/s390/block/dasd_alias.c-		return -EINVAL;
drivers/s390/block/dasd_alias.c:	schedule_delayed_work(&lcu->ruac_data.dwork, 0);
drivers/s390/block/dasd_alias.c:		schedule_delayed_work(&lcu->ruac_data.dwork, 30*HZ);
drivers/s390/block/dasd_alias.c-		spin_lock_irqsave(&lcu->lock, flags);
drivers/s390/block/dasd_alias.c-		spin_unlock_irqrestore(&lcu->lock, flags);
drivers/s390/block/dasd_alias.c-		was_pending = 1;
drivers/s390/char/tape_core.c-	}
drivers/s390/char/tape_core.c-			case -EBUSY:
drivers/s390/char/tape_core.c-			case -ENODEV:
drivers/s390/char/tape_core.c-			device->cdev_id, irb->scsw.cmd.cc, irb->scsw.cmd.fctl);
drivers/s390/char/tape_core.c-	} else {
drivers/s390/char/tape_core.c-		rc = 0;
drivers/s390/char/tape_core.c-				request->status	= TAPE_REQUEST_CANCEL;
drivers/s390/char/tape_core.c-		request->status = TAPE_REQUEST_QUEUED;
drivers/s390/char/tape_core.c-		request->status = TAPE_REQUEST_QUEUED;
drivers/s390/char/tape_core.c-		return;
drivers/s390/char/tape_core.c-				return 0;
drivers/s390/char/tape_core.c:				schedule_delayed_work(&device->tape_dnr, 0);
drivers/s390/char/tape_core.c:		schedule_delayed_work(&device->tape_dnr, 0);
drivers/s390/char/tape_core.c:		schedule_delayed_work(&device->tape_dnr, HZ);
drivers/s390/char/tape_core.c-		/* The common I/O subsystem is currently busy. Retry later. */
drivers/s390/net/qeth_core_main.c-
drivers/s390/net/qeth_core_main.c:	cancel_delayed_work_sync(&card->buffer_reclaim_work);
drivers/s390/net/qeth_core_main.c-					&card->buffer_reclaim_work,
drivers/s390/net/qeth_core_main.c-				card->reclaim_index = index;
drivers/s390/net/qeth_core_main.c-		dev_kfree_skb_any(card->qdio.in_q->bufs[j].rx_skb);
drivers/s390/net/qeth_core_main.c-	for (j = 0; j < QDIO_MAX_BUFFERS_PER_Q; ++j)
drivers/s390/net/qeth_core_main.c-				QETH_CARD_TEXT(card, 2, "qsarbw");
drivers/s390/net/qeth_core_main.c-	qeth_free_cq(card);
drivers/s390/net/qeth_core_main.c-					QETH_RECLAIM_WORK_TIME);
drivers/s390/net/qeth_core_main.c:				schedule_delayed_work(
drivers/s390/scsi/zfcp_fc.c-
drivers/s390/scsi/zfcp_fc.c-{
drivers/s390/scsi/zfcp_fc.c-{
drivers/s390/scsi/zfcp_fc.c-}
drivers/s390/scsi/zfcp_fc.c:	cancel_delayed_work_sync(&wka->work);
drivers/s390/scsi/zfcp_fc.c-			container_of(dw, struct zfcp_fc_wka_port, work);
drivers/s390/scsi/zfcp_fc.c-	mutex_lock(&wka->mutex);
drivers/s390/scsi/zfcp_fc.c-		return;
drivers/s390/scsi/zfcp_fc.c:	schedule_delayed_work(&wka_port->work, HZ / 100);
drivers/s390/scsi/zfcp_fc.c-static void zfcp_fc_wka_port_force_offline(struct zfcp_fc_wka_port *wka)
drivers/s390/scsi/zfcp_fc.c-static void zfcp_fc_wka_port_offline(struct work_struct *work)
drivers/s390/scsi/zfcp_fc.c:	struct delayed_work *dw = to_delayed_work(work);
drivers/s390/scsi/zfcp_fc.c-	struct zfcp_fc_wka_port *wka_port =
drivers/s390/scsi/zfcp_fc.c-	/* wait 10 milliseconds, other reqs might pop in */
drivers/s390/scsi/zfcp_fc.c-	wka->status = ZFCP_FC_WKA_PORT_OFFLINE;
drivers/scsi/bnx2fc/bnx2fc_io.c-
drivers/scsi/bnx2fc/bnx2fc_io.c-
drivers/scsi/bnx2fc/bnx2fc_io.c-	 */
drivers/scsi/bnx2fc/bnx2fc_io.c-				"already in abts processing\n", io_req->xid);
drivers/scsi/bnx2fc/bnx2fc_io.c-						 bnx2fc_cmd_release);
drivers/scsi/bnx2fc/bnx2fc_io.c-			 bnx2fc_cmd_release); /* drop timer hold */
drivers/scsi/bnx2fc/bnx2fc_io.c-				 bnx2fc_cmd_release); /* drop timer hold */
drivers/scsi/bnx2fc/bnx2fc_io.c-				 bnx2fc_cmd_release); /* drop timer hold */
drivers/scsi/bnx2fc/bnx2fc_io.c-				 bnx2fc_cmd_release); /* drop timer hold */
drivers/scsi/bnx2fc/bnx2fc_io.c-					 bnx2fc_cmd_release); /* timer hold */
drivers/scsi/bnx2fc/bnx2fc_io.c-		/* Cancel the current timer running on this io_req */
drivers/scsi/bnx2fc/bnx2fc_io.c-			/* cancel the IO timeout */
drivers/scsi/bnx2fc/bnx2fc_io.c-				/* cancel the IO timeout */
drivers/scsi/bnx2fc/bnx2fc_io.c-	/* Cancel the timeout_work, as we received IO completion */
drivers/scsi/bnx2fc/bnx2fc_io.c-					      &cmd->req_flags)) {
drivers/scsi/bnx2fc/bnx2fc_io.c-							&cmd->req_flags)) {
drivers/scsi/bnx2fc/bnx2fc_io.c:				if (cancel_delayed_work(&io_req->timeout_work))
drivers/scsi/bnx2fc/bnx2fc_io.c:			if (cancel_delayed_work(&io_req->timeout_work))
drivers/scsi/bnx2fc/bnx2fc_io.c:		if (cancel_delayed_work(&io_req->timeout_work))
drivers/scsi/bnx2fc/bnx2fc_io.c:		if (cancel_delayed_work(&io_req->timeout_work))
drivers/scsi/bnx2fc/bnx2fc_io.c:		if (cancel_delayed_work(&io_req->timeout_work))
drivers/scsi/bnx2fc/bnx2fc_io.c:	if (cancel_delayed_work(&io_req->timeout_work))
drivers/scsi/bnx2fc/bnx2fc_io.c:	if (queue_delayed_work(interface->timer_work_queue,
drivers/scsi/bnx2fc/bnx2fc_io.c-	if (!test_and_set_bit(BNX2FC_FLAG_ISSUE_ABTS, &io_req->req_flags)) {
drivers/scsi/bnx2fc/bnx2fc_io.c-	if (test_bit(BNX2FC_FLAG_ISSUE_ABTS, &io_req->req_flags))
drivers/scsi/bnx2fc/bnx2fc_io.c-			       &io_req->timeout_work,
drivers/scsi/bnx2fc/bnx2fc_io.c-		kref_put(&io_req->refcount,
drivers/scsi/bnx2fc/bnx2fc_io.c-			kref_put(&io_req->refcount,
drivers/scsi/bnx2fc/bnx2fc_io.c-			kref_put(&io_req->refcount,
drivers/scsi/bnx2fc/bnx2fc_io.c-			kref_put(&io_req->refcount,
drivers/scsi/bnx2fc/bnx2fc_io.c-				kref_put(&io_req->refcount,
drivers/scsi/bnx2fc/bnx2fc_io.c-					kref_put(&io_req->refcount,
drivers/scsi/bnx2fc/bnx2fc_io.c-			       msecs_to_jiffies(timer_msec)))
drivers/scsi/bnx2fc/bnx2fc_io.c-		printk(KERN_ERR PFX "eh_abort: io_req (xid = 0x%x) "
drivers/scsi/bnx2fc/bnx2fc_io.c-	struct bnx2fc_interface *interface = io_req->port->priv;
drivers/scsi/fcoe/fcoe_sysfs.c-
drivers/scsi/fcoe/fcoe_sysfs.c-
drivers/scsi/fcoe/fcoe_sysfs.c-
drivers/scsi/fcoe/fcoe_sysfs.c-
drivers/scsi/fcoe/fcoe_sysfs.c-
drivers/scsi/fcoe/fcoe_sysfs.c-{
drivers/scsi/fcoe/fcoe_sysfs.c-}
drivers/scsi/fcoe/fcoe_sysfs.c- */
drivers/scsi/fcoe/fcoe_sysfs.c-	}
drivers/scsi/fcoe/fcoe_sysfs.c-	 */
drivers/scsi/fcoe/fcoe_sysfs.c-			fcf->state = FCOE_FCF_STATE_CONNECTED;
drivers/scsi/fcoe/fcoe_sysfs.c-		fcoe_ctlr_device_flush_devloss(ctlr);
drivers/scsi/fcoe/fcoe_sysfs.c-				fcoe_ctlr_device_flush_devloss(ctlr);
drivers/scsi/fcoe/fcoe_sysfs.c:			if (!cancel_delayed_work(&fcf->dev_loss_work))
drivers/scsi/fcoe/fcoe_sysfs.c:	if (!cancel_delayed_work(&fcf->dev_loss_work))
drivers/scsi/fcoe/fcoe_sysfs.c-	 * immediate termination of the rports
drivers/scsi/fcoe/fcoe_sysfs.c-int fcoe_ctlr_device_queue_devloss_work(struct fcoe_ctlr_device *ctlr,
drivers/scsi/fcoe/fcoe_sysfs.c:	return queue_delayed_work(fcoe_ctlr_devloss_work_q(ctlr), work, delay);
drivers/scsi/fcoe/fcoe_sysfs.c:				       struct delayed_work *work,
drivers/scsi/fcoe/fcoe_sysfs.c-				       unsigned long delay)
drivers/scsi/imm.c-
drivers/scsi/imm.c-
drivers/scsi/imm.c-
drivers/scsi/imm.c-	}
drivers/scsi/imm.c-	cmd->SCp.phase = 0;	/* bus free */
drivers/scsi/imm.c-	if (imm_engine(dev, cmd)) {
drivers/scsi/imm.c-	imm_pb_claim(dev);
drivers/scsi/imm.c-	int mode;		/* Transfer mode                */
drivers/scsi/imm.c-		return;
drivers/scsi/imm.c:	schedule_delayed_work(&dev->imm_tq, 0);
drivers/scsi/imm.c:		schedule_delayed_work(&dev->imm_tq, 1);
drivers/scsi/imm.c:	struct delayed_work imm_tq;	/* Polling interrupt stuff       */
drivers/scsi/imm.c-	struct scsi_cmnd *cur_cmd;	/* Current queued command       */
drivers/scsi/imm.c-	unsigned failed:1;	/* Failure flag                 */
drivers/scsi/imm.c-	unsigned long jstart;	/* Jiffies at start             */
drivers/scsi/libfc/fc_disc.c-
drivers/scsi/libfc/fc_disc.c-}
drivers/scsi/libfc/fc_disc.c-			}
drivers/scsi/libfc/fc_disc.c:		cancel_delayed_work_sync(&disc->disc_work);
drivers/scsi/libfc/fc_disc.c-			disc->retry_count++;
drivers/scsi/libfc/fc_disc.c-		} else
drivers/scsi/libfc/fc_disc.c-			fc_disc_done(disc, DISC_EV_FAILED);
drivers/scsi/libfc/fc_disc.c-	fc_disc_stop_rports(disc);
drivers/scsi/libfc/fc_disc.c-	if (disc->pending)
drivers/scsi/libfc/fc_disc.c:			schedule_delayed_work(&disc->disc_work, delay);
drivers/scsi/libfc/fc_exch.c-
drivers/scsi/libfc/fc_exch.c-
drivers/scsi/libfc/fc_exch.c-
drivers/scsi/libfc/fc_exch.c-	}
drivers/scsi/libfc/fc_exch.c-	}
drivers/scsi/libfc/fc_exch.c-			atomic_dec(&ep->ex_refcnt); /* drop hold for timer */
drivers/scsi/libfc/fc_exch.c-		atomic_dec(&ep->ex_refcnt);	/* drop hold for timer */
drivers/scsi/libfc/fc_exch.c-			atomic_dec(&ep->ex_refcnt);	/* drop timer hold */
drivers/scsi/libfc/fc_exch.c-		ep->state |= FC_EX_DONE;
drivers/scsi/libfc/fc_exch.c-	ep->state |= FC_EX_RST_CLEANUP;
drivers/scsi/libfc/fc_exch.c-	fc_exch_abort_locked(ep, 0);
drivers/scsi/libfc/fc_exch.c-	FC_EXCH_DBG(ep, "Exchange timer armed\n");
drivers/scsi/libfc/fc_exch.c-		fc_exch_hold(ep);		/* hold for timer */
drivers/scsi/libfc/fc_exch.c-		    fc_exch_rctl_name(fh->fh_r_ctl));
drivers/scsi/libfc/fc_exch.c-		fc_exch_release(ep);	/* release from pending timer hold */
drivers/scsi/libfc/fc_exch.c:		if (cancel_delayed_work(&ep->timeout_work))
drivers/scsi/libfc/fc_exch.c:		if (cancel_delayed_work(&ep->timeout_work))
drivers/scsi/libfc/fc_exch.c:	if (cancel_delayed_work(&ep->timeout_work))
drivers/scsi/libfc/fc_exch.c:	if (cancel_delayed_work_sync(&ep->timeout_work))
drivers/scsi/libfc/fc_exch.c-	if (ep->esb_stat & ESB_ST_COMPLETE) {
drivers/scsi/libfc/fc_exch.c-	if (!(ep->esb_stat & ESB_ST_REC_QUAL)) {
drivers/scsi/libfc/fc_exch.c:	if (queue_delayed_work(fc_exch_workqueue, &ep->timeout_work,
drivers/scsi/libfc/fc_exch.c-			       msecs_to_jiffies(timer_msec)))
drivers/scsi/libfc/fc_exch.c-		rc = 0;
drivers/scsi/libfc/fc_exch.c-	resp = ep->resp;
drivers/scsi/libfc/fc_lport.c-
drivers/scsi/libfc/fc_lport.c-{
drivers/scsi/libfc/fc_lport.c-}
drivers/scsi/libfc/fc_lport.c:	cancel_delayed_work_sync(&lport->retry_work);
drivers/scsi/libfc/fc_lport.c:	cancel_delayed_work_sync(&lport->retry_work);
drivers/scsi/libfc/fc_lport.c-			delay =	msecs_to_jiffies(lport->e_d_tov);
drivers/scsi/libfc/fc_lport.c-	} else
drivers/scsi/libfc/fc_lport.c-	fc_lport_enter_logo(lport);
drivers/scsi/libfc/fc_lport.c-	fc_lport_enter_reset(lport);
drivers/scsi/libfc/fc_lport.c-		fc_lport_enter_reset(lport);
drivers/scsi/libfc/fc_lport.c-int fc_lport_reset(struct fc_lport *lport)
drivers/scsi/libfc/fc_lport.c-	mutex_lock(&lport->lp_mutex);
drivers/scsi/libfc/fc_lport.c-	mutex_unlock(&lport->lp_mutex);
drivers/scsi/libfc/fc_lport.c-	return 0;
drivers/scsi/libfc/fc_lport.c:		schedule_delayed_work(&lport->retry_work, delay);
drivers/scsi/libfc/fc_rport.c-
drivers/scsi/libfc/fc_rport.c-	}
drivers/scsi/libfc/fc_rport.c-		/*
drivers/scsi/libfc/fc_rport.c-		}
drivers/scsi/libfc/fc_rport.c:		cancel_delayed_work_sync(&rdata->retry_work);
drivers/scsi/libfc/fc_rport.c-			delay = 0;
drivers/scsi/libfc/fc_rport.c-		if (PTR_ERR(fp) == -FC_EX_TIMEOUT)
drivers/scsi/libfc/fc_rport.c-			rdata->lld_event_callback(lport, rdata, event);
drivers/scsi/libfc/fc_rport.c-		return;
drivers/scsi/libfc/fc_rport.c:		schedule_delayed_work(&rdata->retry_work, delay);
drivers/scsi/megaraid/megaraid_sas_base.c-	}
drivers/scsi/megaraid/megaraid_sas_base.c-	}
drivers/scsi/megaraid/megaraid_sas_base.c-	}
drivers/scsi/megaraid/megaraid_sas_base.c-		}
drivers/scsi/megaraid/megaraid_sas_base.c:		cancel_delayed_work_sync(
drivers/scsi/megaraid/megaraid_sas_base.c:		cancel_delayed_work_sync(
drivers/scsi/megaraid/megaraid_sas_base.c-	if (instance->ev != NULL) {
drivers/scsi/megaraid/megaraid_sas_base.c-	if (instance->ev != NULL) {
drivers/scsi/megaraid/megaraid_sas_base.c-			INIT_WORK(&ev->hotplug_work, megasas_aen_polling);
drivers/scsi/megaraid/megaraid_sas_base.c-			instance->ev = ev;
drivers/scsi/megaraid/megaraid_sas_base.c-		instance->ev = NULL;
drivers/scsi/megaraid/megaraid_sas_base.c-		instance->ev = NULL;
drivers/scsi/megaraid/megaraid_sas_base.c:			schedule_delayed_work(
drivers/scsi/megaraid/megaraid_sas_base.c:			(struct delayed_work *)&ev->hotplug_work);
drivers/scsi/megaraid/megaraid_sas_base.c:			(struct delayed_work *)&ev->hotplug_work);
drivers/scsi/megaraid/megaraid_sas_base.c:				(struct delayed_work *)&ev->hotplug_work, 0);
drivers/scsi/megaraid/megaraid_sas_base.c-		struct megasas_aen_event *ev = instance->ev;
drivers/scsi/megaraid/megaraid_sas_base.c-		struct megasas_aen_event *ev = instance->ev;
drivers/scsi/mpt2sas/mpt2sas_base.c-		destroy_workqueue(wq);
drivers/scsi/mpt2sas/mpt2sas_base.c-			flush_workqueue(wq);
drivers/scsi/mpt2sas/mpt2sas_base.c:		if (!cancel_delayed_work(&ioc->fault_reset_work))
drivers/scsi/mpt2sas/mpt2sas_base.c-	if (ioc->fault_reset_work_q)
drivers/scsi/mpt2sas/mpt2sas_base.c-	if (ioc->fault_reset_work_q)
drivers/scsi/mpt2sas/mpt2sas_base.c-	if (wq) {
drivers/scsi/mpt2sas/mpt2sas_base.c-		    &ioc->fault_reset_work,
drivers/scsi/mpt2sas/mpt2sas_base.c-		    &ioc->fault_reset_work,
drivers/scsi/mpt2sas/mpt2sas_base.c-		    msecs_to_jiffies(FAULT_POLLING_INTERVAL));
drivers/scsi/mpt2sas/mpt2sas_base.c-		    msecs_to_jiffies(FAULT_POLLING_INTERVAL));
drivers/scsi/mpt2sas/mpt2sas_base.c:		queue_delayed_work(ioc->fault_reset_work_q,
drivers/scsi/mpt2sas/mpt2sas_base.c:		queue_delayed_work(ioc->fault_reset_work_q,
drivers/scsi/mpt2sas/mpt2sas_base.c- rearm_timer:
drivers/scsi/mpt2sas/mpt2sas_base.c-	spin_lock_irqsave(&ioc->ioc_reset_in_progress_lock, flags);
drivers/scsi/mpt2sas/mpt2sas_base.c-	spin_unlock_irqrestore(&ioc->ioc_reset_in_progress_lock, flags);
drivers/scsi/mpt2sas/mpt2sas_scsih.c-
drivers/scsi/mpt2sas/mpt2sas_scsih.c-
drivers/scsi/mpt2sas/mpt2sas_scsih.c-{
drivers/scsi/mpt2sas/mpt2sas_scsih.c-}
drivers/scsi/mpt2sas/mpt2sas_scsih.c-			continue;
drivers/scsi/mpt2sas/mpt2sas_scsih.c:	    &fw_event->delayed_work, 0);
drivers/scsi/mpt2sas/mpt2sas_scsih.c:		if (cancel_delayed_work(&fw_event->delayed_work)) {
drivers/scsi/mpt2sas/mpt2sas_scsih.c:	INIT_DELAYED_WORK(&fw_event->delayed_work, _firmware_event_work);
drivers/scsi/mpt2sas/mpt2sas_scsih.c-	list_add_tail(&fw_event->list, &ioc->fw_event_list);
drivers/scsi/mpt2sas/mpt2sas_scsih.c-	list_for_each_entry_safe(fw_event, next, &ioc->fw_event_list, list) {
drivers/scsi/mpt2sas/mpt2sas_scsih.c:	queue_delayed_work(ioc->firmware_event_thread,
drivers/scsi/mpt2sas/mpt2sas_scsih.c-			_scsih_fw_event_free(ioc, fw_event);
drivers/scsi/mpt2sas/mpt2sas_scsih.c-	spin_lock_irqsave(&ioc->fw_event_lock, flags);
drivers/scsi/mpt2sas/mpt2sas_scsih.c-	spin_unlock_irqrestore(&ioc->fw_event_lock, flags);
drivers/scsi/mpt2sas/mpt2sas_scsih.c:	struct delayed_work	delayed_work;
drivers/scsi/mpt2sas/mpt2sas_scsih.c:	    struct fw_event_work, delayed_work.work);
drivers/scsi/mpt2sas/mpt2sas_scsih.c-	struct fw_event_work *fw_event = container_of(work,
drivers/scsi/mpt2sas/mpt2sas_scsih.c-	struct list_head 	list;
drivers/scsi/mpt2sas/mpt2sas_scsih.c-	struct MPT2SAS_ADAPTER *ioc;
drivers/scsi/mpt2sas/mpt2sas_scsih.c-	struct MPT2SAS_ADAPTER *ioc = fw_event->ioc;
drivers/scsi/mpt2sas/mpt2sas_scsih.c-	u16			device_handle;
drivers/scsi/mpt2sas/mpt2sas_scsih.c-	u8			cancel_pending_work;
drivers/scsi/mvsas/mv_sas.c-{
drivers/scsi/mvsas/mv_sas.c-	} else
drivers/scsi/mvsas/mv_sas.c-		list_add_tail(&mwq->entry, &mvi->wq_list);
drivers/scsi/mvsas/mv_sas.c-		MV_INIT_DELAYED_WORK(&mwq->work_q, mvs_work_queue, mwq);
drivers/scsi/mvsas/mv_sas.c-		ret = -ENOMEM;
drivers/scsi/mvsas/mv_sas.c:		schedule_delayed_work(&mwq->work_q, HZ * 2);
drivers/scsi/mvsas/mv_sas.c-static void mvs_work_queue(struct work_struct *work)
drivers/scsi/mvsas/mv_sas.c:	struct delayed_work *dw = container_of(work, struct delayed_work, work);
drivers/scsi/mvsas/mv_sas.c-	struct mvs_info *mvi = mwq->mvi;
drivers/scsi/mvsas/mv_sas.c-	struct mvs_wq *mwq = container_of(dw, struct mvs_wq, work_q);
drivers/scsi/NCR5380.c-
drivers/scsi/NCR5380.c-
drivers/scsi/NCR5380.c-
drivers/scsi/NCR5380.c-{
drivers/scsi/NCR5380.c-}
drivers/scsi/NCR5380.c-}
drivers/scsi/NCR5380.c-}
drivers/scsi/NCR5380.c:	cancel_delayed_work_sync(&hostdata->coroutine);
drivers/scsi/NCR5380.c-	hostdata->time_expires = jiffies + timeout;
drivers/scsi/NCR5380.c-		if(!done)
drivers/scsi/NCR5380.c-	/* Kick off command processing */
drivers/scsi/NCR5380.c-	return 0;
drivers/scsi/NCR5380.c-	return IRQ_HANDLED;
drivers/scsi/NCR5380.c-	/* Run the coroutine if it isn't already running. */
drivers/scsi/NCR5380.c:			schedule_delayed_work(&hostdata->coroutine, 0);
drivers/scsi/NCR5380.c:	schedule_delayed_work(&hostdata->coroutine, 0);
drivers/scsi/NCR5380.c:	schedule_delayed_work(&hostdata->coroutine, timeout);
drivers/scsi/NCR5380.c-		spin_unlock_irqrestore(instance->host_lock, flags);
drivers/scsi/NCR5380.c-	struct NCR5380_hostdata *hostdata = (struct NCR5380_hostdata *) instance->hostdata;
drivers/scsi/NCR5380.c-	} while (!done);
drivers/scsi/ppa.c-
drivers/scsi/ppa.c-
drivers/scsi/ppa.c-	}
drivers/scsi/ppa.c-	}
drivers/scsi/ppa.c-	cmd->SCp.phase = 0;	/* bus free */
drivers/scsi/ppa.c-	if (ppa_engine(dev, cmd)) {
drivers/scsi/ppa.c-	int mode;		/* Transfer mode                */
drivers/scsi/ppa.c-	ppa_pb_claim(dev);
drivers/scsi/ppa.c-		return;
drivers/scsi/ppa.c:	schedule_delayed_work(&dev->ppa_tq, 0);
drivers/scsi/ppa.c:		schedule_delayed_work(&dev->ppa_tq, 1);
drivers/scsi/ppa.c:	struct delayed_work ppa_tq;	/* Polling interrupt stuff       */
drivers/scsi/ppa.c-	struct scsi_cmnd *cur_cmd;	/* Current queued command       */
drivers/scsi/ppa.c-	unsigned long jstart;	/* Jiffies at start             */
drivers/scsi/ppa.c-	unsigned long recon_tmo;	/* How many usecs to wait for reconnection (6th bit) */
drivers/scsi/scsi_transport_fc.c-
drivers/scsi/scsi_transport_fc.c-
drivers/scsi/scsi_transport_fc.c-
drivers/scsi/scsi_transport_fc.c-
drivers/scsi/scsi_transport_fc.c-{
drivers/scsi/scsi_transport_fc.c-}
drivers/scsi/scsi_transport_fc.c- */
drivers/scsi/scsi_transport_fc.c-	}
drivers/scsi/scsi_transport_fc.c-		 */
drivers/scsi/scsi_transport_fc.c-				 */
drivers/scsi/scsi_transport_fc.c-				 * be checked and will NOOP the function.
drivers/scsi/scsi_transport_fc.c-			fc_flush_devloss(shost);
drivers/scsi/scsi_transport_fc.c-			fc_flush_devloss(shost);
drivers/scsi/scsi_transport_fc.c-			fc_flush_devloss(shost);
drivers/scsi/scsi_transport_fc.c-			fc_flush_devloss(shost);
drivers/scsi/scsi_transport_fc.c-					fc_flush_devloss(shost);
drivers/scsi/scsi_transport_fc.c-					fc_flush_devloss(shost);
drivers/scsi/scsi_transport_fc.c:fc_queue_devloss_work(struct Scsi_Host *shost, struct delayed_work *work,
drivers/scsi/scsi_transport_fc.c:				if (!cancel_delayed_work(&rport->dev_loss_work))
drivers/scsi/scsi_transport_fc.c:		if (!cancel_delayed_work(&rport->dev_loss_work))
drivers/scsi/scsi_transport_fc.c:		if (!cancel_delayed_work(&rport->dev_loss_work))
drivers/scsi/scsi_transport_fc.c:				if (!cancel_delayed_work(&rport->fail_io_work))
drivers/scsi/scsi_transport_fc.c:		if (!cancel_delayed_work(&rport->fail_io_work))
drivers/scsi/scsi_transport_fc.c:		if (!cancel_delayed_work(&rport->fail_io_work))
drivers/scsi/scsi_transport_fc.c-	if (rport->flags & FC_RPORT_DEVLOSS_PENDING) {
drivers/scsi/scsi_transport_fc.c:	return queue_delayed_work(fc_host_devloss_work_q(shost), work, delay);
drivers/scsi/scsi_transport_fc.c-		spin_lock_irqsave(shost->host_lock, flags);
drivers/scsi/scsi_transport_fc.c-		spin_unlock_irqrestore(shost->host_lock, flags);
drivers/scsi/scsi_transport_fc.c-static int
drivers/scsi/scsi_transport_fc.c-		 * transaction.
drivers/scsi/scsi_transport_fc.c-				unsigned long delay)
drivers/scsi/scsi_transport_iscsi.c-	/*
drivers/scsi/scsi_transport_iscsi.c-	 */
drivers/scsi/scsi_transport_iscsi.c:	cancel_delayed_work(&session->recovery_work);
drivers/scsi/scsi_transport_iscsi.c-	flush_workqueue(iscsi_eh_timer_workq);
drivers/scsi/scsi_transport_iscsi.c-		flush_workqueue(iscsi_eh_timer_workq);
drivers/scsi/scsi_transport_iscsi.c:	if (!cancel_delayed_work(&session->recovery_work))
drivers/scsi/scsi_transport_iscsi.c-	if (session->recovery_tmo >= 0)
drivers/scsi/scsi_transport_iscsi.c-	ISCSI_DBG_TRANS_SESSION(session, "Completed SCSI target blocking\n");
drivers/scsi/scsi_transport_iscsi.c-	/* make sure the timedout callout is not running */
drivers/scsi/scsi_transport_iscsi.c:		queue_delayed_work(iscsi_eh_timer_workq,
drivers/scsi/scsi_transport_iscsi.c-				   session->recovery_tmo * HZ);
drivers/scsi/scsi_transport_iscsi.c-				   &session->recovery_work,
drivers/scsi/scsi_transport_iscsi.c-	session->state = ISCSI_SESSION_LOGGED_IN;
drivers/scsi/scsi_transport_iscsi.c-	 * so try to cancel it if it was going to run after this unblock.
drivers/scsi/scsi_transport_iscsi.c-	spin_lock_irqsave(&session->lock, flags);
drivers/sensorhub/ssp_dev.c-
drivers/sensorhub/ssp_dev.c-{
drivers/sensorhub/ssp_dev.c-	}
drivers/sensorhub/ssp_dev.c:		cancel_delayed_work_sync(&data->work_firmware);
drivers/sensorhub/ssp_dev.c-		data->fw_dl_state < FW_DL_STATE_DONE) {
drivers/sensorhub/ssp_dev.c-		data->fw_dl_state = FW_DL_STATE_SCHEDULED;
drivers/sensorhub/ssp_dev.c-			__func__, data->fw_dl_state);
drivers/sensorhub/ssp_dev.c-	if (data->fw_dl_state == FW_DL_STATE_NEED_TO_SCHEDULE) {
drivers/sensorhub/ssp_dev.c-	if (data->fw_dl_state >= FW_DL_STATE_SCHEDULED &&
drivers/sensorhub/ssp_dev.c-	int iRet = 0;
drivers/sensorhub/ssp_dev.c-				msecs_to_jiffies(1000));
drivers/sensorhub/ssp_dev.c:		pr_debug("%s, cancel_delayed_work_sync state = %d\n",
drivers/sensorhub/ssp_dev.c-		pr_debug("[SSP]: Firmware update is scheduled\n");
drivers/sensorhub/ssp_dev.c:		schedule_delayed_work(&data->work_firmware,
drivers/sensorhub/ssp_dev.c-static void work_function_firmware_update(struct work_struct *work)
drivers/sensorhub/ssp_dev.c:	struct ssp_data *data = container_of((struct delayed_work *)work,
drivers/sensorhub/ssp_dev.c-	struct ssp_data, work_firmware);
drivers/sensors/asp01.c-
drivers/sensors/asp01.c-
drivers/sensors/asp01.c-
drivers/sensors/asp01.c-
drivers/sensors/asp01.c-
drivers/sensors/asp01.c-	atomic_t enable;
drivers/sensors/asp01.c:	cancel_delayed_work_sync(&data->d_work);
drivers/sensors/asp01.c:	cancel_delayed_work_sync(&data->d_work);
drivers/sensors/asp01.c:		cancel_delayed_work_sync(&data->d_work);
drivers/sensors/asp01.c:	cancel_delayed_work_sync(&data->d_work_initdev);
drivers/sensors/asp01.c:	cancel_delayed_work_sync(&data->d_work_initdev);
drivers/sensors/asp01.c-			data->init_touch_needed = true;
drivers/sensors/asp01.c-	data->shutdown = true;
drivers/sensors/asp01.c-		disable_irq(data->pdata->irq);
drivers/sensors/asp01.c-		disable_irq(data->pdata->irq);
drivers/sensors/asp01.c-		disable_irq(data->pdata->irq);
drivers/sensors/asp01.c-	} else if (!enable && atomic_read(&data->enable)) {
drivers/sensors/asp01.c-		enable_irq(data->pdata->irq);
drivers/sensors/asp01.c-		err = asp01_grip_disable(data);
drivers/sensors/asp01.c-	free_irq(data->pdata->irq, data);
drivers/sensors/asp01.c-	free_irq(data->pdata->irq, data);
drivers/sensors/asp01.c-	if (atomic_read(&data->enable))
drivers/sensors/asp01.c-	if (atomic_read(&data->enable))
drivers/sensors/asp01.c-		if (data->init_touch_needed)
drivers/sensors/asp01.c-		if (data->is_first_close == true)
drivers/sensors/asp01.c-	INIT_DELAYED_WORK(&data->d_work_initdev, asp01_initdev_work_func);
drivers/sensors/asp01.c-				msecs_to_jiffies(10));
drivers/sensors/asp01.c-				msecs_to_jiffies(700));
drivers/sensors/asp01.c-	pr_info("%s+\n", __func__);
drivers/sensors/asp01.c:			schedule_delayed_work(&data->d_work,
drivers/sensors/asp01.c:	schedule_delayed_work(&data->d_work_initdev,
drivers/sensors/asp01.c-	struct asp01_data *data = i2c_get_clientdata(client);
drivers/sensors/asp01.c:	struct delayed_work d_work;
drivers/sensors/asp01.c:	struct delayed_work d_work_initdev;
drivers/sensors/asp01.c-	struct input_dev *input;
drivers/sensors/asp01.c-	struct mutex data_mutex;
drivers/sensors/asp01.c-	struct work_struct work; /* for grip sensor */
drivers/sensors/asp01.c-	sysfs_remove_group(&data->input->dev.kobj,
drivers/sensors/asp01.c-	sysfs_remove_group(&data->input->dev.kobj,
drivers/sensors/geomagnetic/yas_mag_kernel_driver.c-{
drivers/sensors/geomagnetic/yas_mag_kernel_driver.c-{
drivers/sensors/geomagnetic/yas_mag_kernel_driver.c-{
drivers/sensors/geomagnetic/yas_mag_kernel_driver.c-}
drivers/sensors/geomagnetic/yas_mag_kernel_driver.c-
drivers/sensors/geomagnetic/yas_mag_kernel_driver.c-
drivers/sensors/geomagnetic/yas_mag_kernel_driver.c-
drivers/sensors/geomagnetic/yas_mag_kernel_driver.c-
drivers/sensors/geomagnetic/yas_mag_kernel_driver.c-
drivers/sensors/geomagnetic/yas_mag_kernel_driver.c-
drivers/sensors/geomagnetic/yas_mag_kernel_driver.c:		cancel_delayed_work_sync(&data->work);
drivers/sensors/geomagnetic/yas_mag_kernel_driver.c:		cancel_delayed_work_sync(&data->work);
drivers/sensors/geomagnetic/yas_mag_kernel_driver.c:		= container_of((struct delayed_work *)work,
drivers/sensors/geomagnetic/yas_mag_kernel_driver.c-	data->suspend = 1;
drivers/sensors/geomagnetic/yas_mag_kernel_driver.c-	delay = geomagnetic_work(&magdata);
drivers/sensors/geomagnetic/yas_mag_kernel_driver.c-	else
drivers/sensors/geomagnetic/yas_mag_kernel_driver.c-	if (!atomic_cmpxchg(&data->enable, 0, 1))
drivers/sensors/geomagnetic/yas_mag_kernel_driver.c-	if (atomic_cmpxchg(&data->enable, 1, 0))
drivers/sensors/geomagnetic/yas_mag_kernel_driver.c-	if (atomic_read(&data->enable))
drivers/sensors/geomagnetic/yas_mag_kernel_driver.c-	if (atomic_read(&data->enable))
drivers/sensors/geomagnetic/yas_mag_kernel_driver.c-#if DEBUG
drivers/sensors/geomagnetic/yas_mag_kernel_driver.c-#if DEBUG
drivers/sensors/geomagnetic/yas_mag_kernel_driver.c-	if (delay > 0)
drivers/sensors/geomagnetic/yas_mag_kernel_driver.c-	return 0;
drivers/sensors/geomagnetic/yas_mag_kernel_driver.c-	return 0;
drivers/sensors/geomagnetic/yas_mag_kernel_driver.c:		schedule_delayed_work(&data->work, 0);
drivers/sensors/geomagnetic/yas_mag_kernel_driver.c:		schedule_delayed_work(&data->work, 0);
drivers/sensors/geomagnetic/yas_mag_kernel_driver.c:		schedule_delayed_work(&data->work, 0);
drivers/sensors/geomagnetic/yas_mag_kernel_driver.c:		schedule_delayed_work(&data->work, msecs_to_jiffies(delay));
drivers/sensors/geomagnetic/yas_mag_kernel_driver.c:	struct delayed_work work;
drivers/sensors/geomagnetic/yas_mag_kernel_driver.c-	struct geomagnetic_data *data
drivers/sensors/geomagnetic/yas_mag_kernel_driver.c-			struct geomagnetic_data, work);
drivers/sensors/geomagnetic/yas_mag_kernel_driver.c-	struct input_dev *input_data;
drivers/sensors/geomagnetic/yas_mag_kernel_driver.c-	struct input_dev *input_raw;
drivers/sensors/geomagnetic/yas_mag_kernel_driver.c-	struct semaphore driver_lock;
drivers/sensors/geomagnetic/yas_mag_kernel_driver.c-	struct semaphore multi_lock;
drivers/sensors/geomagnetic/yas_mag_kernel_driver.c-	uint32_t delay;
drivers/sensors/k2dh.c-}
drivers/sensors/k2dh.c-		atomic_read(&g_k2dh->delay)));
drivers/sensors/k2dh.c-	atomic_t delay;
drivers/sensors/k2dh.c-	atomic_t enable;
drivers/sensors/k2dh.c:		cancel_delayed_work_sync(&data->work);
drivers/sensors/k2dh.c:		cancel_delayed_work_sync(&data->work);
drivers/sensors/k2dh.c:		cancel_delayed_work_sync(&data->work);
drivers/sensors/k2dh.c-	} else {
drivers/sensors/k2dh.c-#endif
drivers/sensors/k2dh.c-#endif
drivers/sensors/k2dh.c-#endif
drivers/sensors/k2dh.c-		err = k2dh_accel_disable(data);
drivers/sensors/k2dh.c-			goto done;
drivers/sensors/k2dh.c-		if (atomic_read(&data->enable))
drivers/sensors/k2dh.c-	if (atomic_read(&data->enable))
drivers/sensors/k2dh.c-	if (atomic_read(&data->enable))
drivers/sensors/k2dh.c-	if (atomic_read(&data->opened) > 0)
drivers/sensors/k2dh.c-#ifdef CONFIG_SENSOR_K2DH_INPUTDEV
drivers/sensors/k2dh.c-#ifdef CONFIG_SENSOR_K2DH_INPUTDEV
drivers/sensors/k2dh.c-#ifdef CONFIG_SENSOR_K2DH_INPUTDEV
drivers/sensors/k2dh.c-#ifdef CONFIG_SENSOR_K2DH_INPUTDEV
drivers/sensors/k2dh.c-		if (err < 0)
drivers/sensors/k2dh.c-		if (err < 0)
drivers/sensors/k2dh.c-	input_report_abs(g_k2dh->input, ABS_Z, g_k2dh->acc_xyz.z);
drivers/sensors/k2dh.c-	input_sync(g_k2dh->input);
drivers/sensors/k2dh.c-			msecs_to_jiffies(5));
drivers/sensors/k2dh.c-				msecs_to_jiffies(5));
drivers/sensors/k2dh.c-	res = i2c_smbus_write_byte_data(data->client,
drivers/sensors/k2dh.c:		schedule_delayed_work(&data->work,
drivers/sensors/k2dh.c:			schedule_delayed_work(&data->work,
drivers/sensors/k2dh.c:	schedule_delayed_work(&g_k2dh->work, msecs_to_jiffies(
drivers/sensors/k2dh.c:	struct delayed_work work;
drivers/sensors/k2dh.c-	struct input_dev *input;
drivers/sensors/optical/gp2ap020.c-{
drivers/sensors/optical/gp2ap020.c-}
drivers/sensors/optical/gp2ap020.c-
drivers/sensors/optical/gp2ap020.c-
drivers/sensors/optical/gp2ap020.c-
drivers/sensors/optical/gp2ap020.c-
drivers/sensors/optical/gp2ap020.c-
drivers/sensors/optical/gp2ap020.c-
drivers/sensors/optical/gp2ap020.c-
drivers/sensors/optical/gp2ap020.c-
drivers/sensors/optical/gp2ap020.c-
drivers/sensors/optical/gp2ap020.c-
drivers/sensors/optical/gp2ap020.c-
drivers/sensors/optical/gp2ap020.c-	}
drivers/sensors/optical/gp2ap020.c-	}
drivers/sensors/optical/gp2ap020.c-	}
drivers/sensors/optical/gp2ap020.c-	}
drivers/sensors/optical/gp2ap020.c-	}
drivers/sensors/optical/gp2ap020.c:		cancel_delayed_work_sync(&data->light_work);
drivers/sensors/optical/gp2ap020.c:		cancel_delayed_work_sync(&data->light_work);
drivers/sensors/optical/gp2ap020.c:	cancel_delayed_work_sync(&gp2a->light_work);
drivers/sensors/optical/gp2ap020.c:	cancel_delayed_work_sync(&gp2a->light_work);
drivers/sensors/optical/gp2ap020.c:		cancel_delayed_work_sync(&gp2a->light_work);
drivers/sensors/optical/gp2ap020.c:	flush_delayed_work(&gp2a->light_work);
drivers/sensors/optical/gp2ap020.c:	flush_delayed_work(&gp2a->light_work);
drivers/sensors/optical/gp2ap020.c-	if (data->light_enabled)
drivers/sensors/optical/gp2ap020.c-	if (data->light_enabled) {
drivers/sensors/optical/gp2ap020.c-	if (!data->light_enabled && value) {
drivers/sensors/optical/gp2ap020.c-	if (data->light_enabled && !value) {
drivers/sensors/optical/gp2ap020.c-	if (gp2a->light_enabled)
drivers/sensors/optical/gp2ap020.c-	if (gp2a->light_enabled)
drivers/sensors/optical/gp2ap020.c-	int adc;
drivers/sensors/optical/gp2ap020.c-		lightsensor_onoff(0, data);
drivers/sensors/optical/gp2ap020.c-		lightsensor_onoff(1, data);
drivers/sensors/optical/gp2ap020.c-			msecs_to_jiffies(data->light_delay));
drivers/sensors/optical/gp2ap020.c-			msecs_to_jiffies(delay));
drivers/sensors/optical/gp2ap020.c-	mutex_destroy(&gp2a->light_mutex);
drivers/sensors/optical/gp2ap020.c-	mutex_destroy(&gp2a->light_mutex);
drivers/sensors/optical/gp2ap020.c-	mutex_lock(&gp2a->light_mutex);
drivers/sensors/optical/gp2ap020.c-	mutex_unlock(&gp2a->light_mutex);
drivers/sensors/optical/gp2ap020.c-	mutex_unlock(&gp2a->light_mutex);
drivers/sensors/optical/gp2ap020.c:		schedule_delayed_work(&data->light_work,
drivers/sensors/optical/gp2ap020.c:		schedule_delayed_work(&data->light_work,
drivers/sensors/optical/gp2ap020.c:		schedule_delayed_work(&data->light_work, msecs_to_jiffies(100));
drivers/sensors/optical/gp2ap020.c:		schedule_delayed_work(&gp2a->light_work, msecs_to_jiffies(100));
drivers/sensors/optical/gp2ap020.c-static void gp2a_work_func_light(struct work_struct *work)
drivers/sensors/optical/gp2ap020.c:	struct delayed_work light_work;
drivers/sensors/optical/gp2ap020.c-	struct device *light_dev;
drivers/sensors/optical/gp2ap020.c-	struct device *proximity_dev;
drivers/sensors/optical/gp2ap020.c:	struct gp2a_data *data = container_of((struct delayed_work *)work,
drivers/sensors/optical/gp2ap020.c-						struct gp2a_data, light_work);
drivers/sensors/optical/gp2ap020.c-	struct mutex data_mutex;
drivers/sensors/optical/gp2ap020.c-	struct mutex light_mutex;
drivers/sensors/yas_acc_kernel_driver.c-
drivers/sensors/yas_acc_kernel_driver.c-
drivers/sensors/yas_acc_kernel_driver.c-
drivers/sensors/yas_acc_kernel_driver.c-
drivers/sensors/yas_acc_kernel_driver.c-{
drivers/sensors/yas_acc_kernel_driver.c-}
drivers/sensors/yas_acc_kernel_driver.c-		}
drivers/sensors/yas_acc_kernel_driver.c:		cancel_delayed_work_sync(&data->work);
drivers/sensors/yas_acc_kernel_driver.c:			cancel_delayed_work_sync(&data->work);
drivers/sensors/yas_acc_kernel_driver.c:		= container_of((struct delayed_work *)work,
drivers/sensors/yas_acc_kernel_driver.c-					      , delay_to_jiffies(delay) + 1);
drivers/sensors/yas_acc_kernel_driver.c-		driver->set_delay(actual_delay(delay));
drivers/sensors/yas_acc_kernel_driver.c-		driver->set_delay(actual_delay(delay));
drivers/sensors/yas_acc_kernel_driver.c-			driver->set_delay(actual_delay(delay));
drivers/sensors/yas_acc_kernel_driver.c-			driver->set_enable(enable);
drivers/sensors/yas_acc_kernel_driver.c-	} else {
drivers/sensors/yas_acc_kernel_driver.c-		} else {
drivers/sensors/yas_acc_kernel_driver.c-	if (yas_acc_get_enable(data->driver)) {
drivers/sensors/yas_acc_kernel_driver.c-	int suspend_enable;
drivers/sensors/yas_acc_kernel_driver.c-	mutex_unlock(&data->data_mutex);
drivers/sensors/yas_acc_kernel_driver.c:			schedule_delayed_work(&data->work
drivers/sensors/yas_acc_kernel_driver.c:	schedule_delayed_work(&data->work, delay);
drivers/sensors/yas_acc_kernel_driver.c:		schedule_delayed_work(&data->work, delay_to_jiffies(delay) + 1);
drivers/sensors/yas_acc_kernel_driver.c:	struct delayed_work work;
drivers/sensors/yas_acc_kernel_driver.c-	struct input_dev *input;
drivers/sensors/yas_acc_kernel_driver.c-	struct yas_acc_data last;
drivers/sensors/yas_acc_kernel_driver.c-	struct yas_acc_driver *driver;
drivers/sensors/yas_acc_kernel_driver.c-			       struct yas_acc_private_data,
drivers/sensors/yas_acc_kernel_driver.c-	struct yas_acc_private_data *data \
drivers/sensors/yas_acc_kernel_driver.c-			       work);
drivers/soc/qcom/bricked_hotplug.c-
drivers/soc/qcom/bricked_hotplug.c-
drivers/soc/qcom/bricked_hotplug.c-
drivers/soc/qcom/bricked_hotplug.c-
drivers/soc/qcom/bricked_hotplug.c-
drivers/soc/qcom/bricked_hotplug.c-
drivers/soc/qcom/bricked_hotplug.c-
drivers/soc/qcom/bricked_hotplug.c-
drivers/soc/qcom/bricked_hotplug.c-}
drivers/soc/qcom/bricked_hotplug.c-};
drivers/soc/qcom/bricked_hotplug.c-	}
drivers/soc/qcom/bricked_hotplug.c:		cancel_delayed_work_sync(&dl->lock_rem);
drivers/soc/qcom/bricked_hotplug.c:	cancel_delayed_work_sync(&hotplug_work);
drivers/soc/qcom/bricked_hotplug.c:	cancel_delayed_work_sync(&hotplug_work);
drivers/soc/qcom/bricked_hotplug.c-				cpu_online(0), cpu_online(1), cpu_online(2), cpu_online(3));
drivers/soc/qcom/bricked_hotplug.c-	dl->locked = 1;
drivers/soc/qcom/bricked_hotplug.c-		dl = &per_cpu(lock_info, cpu);
drivers/soc/qcom/bricked_hotplug.c-	for_each_possible_cpu(cpu) {
drivers/soc/qcom/bricked_hotplug.c-	for_each_possible_cpu(cpu) {
drivers/soc/qcom/bricked_hotplug.c-	if (hotplug.bricked_enabled)
drivers/soc/qcom/bricked_hotplug.c-	if (hotplug.bricked_enabled)
drivers/soc/qcom/bricked_hotplug.c-	if (required_reschedule) {
drivers/soc/qcom/bricked_hotplug.c-	/* main work thread can sleep now */
drivers/soc/qcom/bricked_hotplug.c-					msecs_to_jiffies(hotplug.delay));
drivers/soc/qcom/bricked_hotplug.c-			      msecs_to_jiffies(hotplug.down_lock_dur));
drivers/soc/qcom/bricked_hotplug.c-					msecs_to_jiffies(hotplug.startdelay));
drivers/soc/qcom/bricked_hotplug.c-	mutex_destroy(&hotplug.bricked_cpu_mutex);
drivers/soc/qcom/bricked_hotplug.c-	mutex_destroy(&hotplug.bricked_hotplug_mutex);
drivers/soc/qcom/bricked_hotplug.c-out:
drivers/soc/qcom/bricked_hotplug.c-		pr_info(MPDEC_TAG": Screen -> on. Activated bricked hotplug. | Mask=[%d%d%d%d]\n",
drivers/soc/qcom/bricked_hotplug.c:		queue_delayed_work(hotplug_wq, &hotplug_work,
drivers/soc/qcom/bricked_hotplug.c:		queue_delayed_work(hotplug_wq, &hotplug_work,
drivers/soc/qcom/bricked_hotplug.c:		queue_delayed_work(hotplug_wq, &hotplug_work, 0);
drivers/soc/qcom/bricked_hotplug.c:	queue_delayed_work_on(0, hotplug_wq, &dl->lock_rem,
drivers/soc/qcom/bricked_hotplug.c-	/* Resume hotplug workqueue if required */
drivers/soc/qcom/bricked_hotplug.c-	return;
drivers/soc/qcom/bricked_hotplug.c-static DEFINE_PER_CPU(struct down_lock, lock_info);
drivers/soc/qcom/bricked_hotplug.c:static struct delayed_work hotplug_work;
drivers/soc/qcom/bricked_hotplug.c-static struct notifier_block notif;
drivers/soc/qcom/bricked_hotplug.c-static struct workqueue_struct *hotplug_wq;
drivers/soc/qcom/bricked_hotplug.c:	struct delayed_work lock_rem;
drivers/soc/qcom/bricked_hotplug.c-struct down_lock {
drivers/soc/qcom/bricked_hotplug.c-	unsigned int locked;
drivers/staging/csr/oska/kernel-compat.h-
drivers/staging/csr/oska/kernel-compat.h-
drivers/staging/csr/oska/kernel-compat.h-
drivers/staging/csr/oska/kernel-compat.h-
drivers/staging/csr/oska/kernel-compat.h-
drivers/staging/csr/oska/kernel-compat.h-};
drivers/staging/csr/oska/kernel-compat.h:    cancel_delayed_work(&(dw)->work)
drivers/staging/csr/oska/kernel-compat.h:#define cancel_delayed_work(dw) \
drivers/staging/csr/oska/kernel-compat.h:#define queue_delayed_work(wq, dw, delay) \
drivers/staging/csr/oska/kernel-compat.h:#define schedule_delayed_work(dw, delay) \
drivers/staging/csr/oska/kernel-compat.h-#endif  /* Linux kernel < 2.6.20 */
drivers/staging/csr/oska/kernel-compat.h-    INIT_WORK(&(dw)->work, (fn))
drivers/staging/csr/oska/kernel-compat.h:    queue_delayed_work((wq), &(dw)->work, (delay))
drivers/staging/csr/oska/kernel-compat.h:    schedule_delayed_work(&(dw)->work, (delay))
drivers/staging/csr/oska/kernel-compat.h:struct delayed_work {
drivers/staging/csr/oska/kernel-compat.h-    struct work_struct n = __WORK_INITIALIZER((n), (f), &(n))
drivers/staging/csr/oska/kernel-compat.h-    struct work_struct work;
drivers/staging/iio/impedance-analyzer/ad5933.c-
drivers/staging/iio/impedance-analyzer/ad5933.c-
drivers/staging/iio/impedance-analyzer/ad5933.c-
drivers/staging/iio/impedance-analyzer/ad5933.c-}
drivers/staging/iio/impedance-analyzer/ad5933.c-	}
drivers/staging/iio/impedance-analyzer/ad5933.c-	 */
drivers/staging/iio/impedance-analyzer/ad5933.c-		ad5933_cmd(st, AD5933_CTRL_INC_FREQ);
drivers/staging/iio/impedance-analyzer/ad5933.c-		ad5933_cmd(st, AD5933_CTRL_START_SWEEP);
drivers/staging/iio/impedance-analyzer/ad5933.c:	cancel_delayed_work_sync(&st->work);
drivers/staging/iio/impedance-analyzer/ad5933.c-	} else {
drivers/staging/iio/impedance-analyzer/ad5933.c-			      msecs_to_jiffies(AD5933_INIT_EXCITATION_TIME_ms));
drivers/staging/iio/impedance-analyzer/ad5933.c-		mutex_unlock(&indio_dev->mlock);
drivers/staging/iio/impedance-analyzer/ad5933.c-		mutex_unlock(&indio_dev->mlock);
drivers/staging/iio/impedance-analyzer/ad5933.c-		/* no data available - try again later */
drivers/staging/iio/impedance-analyzer/ad5933.c-		return;
drivers/staging/iio/impedance-analyzer/ad5933.c-		return;
drivers/staging/iio/impedance-analyzer/ad5933.c-	return 0;
drivers/staging/iio/impedance-analyzer/ad5933.c-	return ad5933_cmd(st, AD5933_CTRL_POWER_DOWN);
drivers/staging/iio/impedance-analyzer/ad5933.c:	schedule_delayed_work(&st->work,
drivers/staging/iio/impedance-analyzer/ad5933.c:		schedule_delayed_work(&st->work, st->poll_time_jiffies);
drivers/staging/iio/impedance-analyzer/ad5933.c:		schedule_delayed_work(&st->work, st->poll_time_jiffies);
drivers/staging/iio/impedance-analyzer/ad5933.c:		schedule_delayed_work(&st->work, st->poll_time_jiffies);
drivers/staging/iio/impedance-analyzer/ad5933.c-	struct ad5933_platform_data	*pdata;
drivers/staging/iio/impedance-analyzer/ad5933.c-	struct ad5933_state *st = iio_priv(indio_dev);
drivers/staging/iio/impedance-analyzer/ad5933.c:	struct delayed_work		work;
drivers/staging/iio/impedance-analyzer/ad5933.c-	struct regulator		*reg;
drivers/staging/iio/impedance-analyzer/ad5933.c-		st->state = AD5933_CTRL_START_SWEEP;
drivers/staging/iio/impedance-analyzer/ad5933.c-	unsigned char			ctrl_hb;
drivers/staging/iio/impedance-analyzer/ad5933.c-	unsigned long			mclk_hz;
drivers/staging/iio/impedance-analyzer/ad5933.c-		/* we just received a valid datum, move on to the next */
drivers/staging/iio/light/tsl2563.c-
drivers/staging/iio/light/tsl2563.c-
drivers/staging/iio/light/tsl2563.c-
drivers/staging/iio/light/tsl2563.c-
drivers/staging/iio/light/tsl2563.c-
drivers/staging/iio/light/tsl2563.c-
drivers/staging/iio/light/tsl2563.c-
drivers/staging/iio/light/tsl2563.c-
drivers/staging/iio/light/tsl2563.c-	}
drivers/staging/iio/light/tsl2563.c:	cancel_delayed_work(&chip->poweroff_work);
drivers/staging/iio/light/tsl2563.c:		cancel_delayed_work(&chip->poweroff_work);
drivers/staging/iio/light/tsl2563.c:		cancel_delayed_work(&chip->poweroff_work);
drivers/staging/iio/light/tsl2563.c:		cancel_delayed_work(&chip->poweroff_work);
drivers/staging/iio/light/tsl2563.c-		chip->int_enabled = false;
drivers/staging/iio/light/tsl2563.c-		chip->intr |= 0x10;
drivers/staging/iio/light/tsl2563.c-	chip->intr |= ~0x30;
drivers/staging/iio/light/tsl2563.c-	/* Ensure that interrupts are disabled - then flush any bottom halves */
drivers/staging/iio/light/tsl2563.c-		/* ensure the chip is actually on */
drivers/staging/iio/light/tsl2563.c-	err = iio_device_register(indio_dev);
drivers/staging/iio/light/tsl2563.c-fail2:
drivers/staging/iio/light/tsl2563.c-fail3:
drivers/staging/iio/light/tsl2563.c-	flush_scheduled_work();
drivers/staging/iio/light/tsl2563.c-	if (!chip->int_enabled)
drivers/staging/iio/light/tsl2563.c-	if (!chip->int_enabled)
drivers/staging/iio/light/tsl2563.c-	if (!chip->int_enabled) {
drivers/staging/iio/light/tsl2563.c-		if (!tsl2563_get_power(chip)) {
drivers/staging/iio/light/tsl2563.c-		if (!tsl2563_get_power(chip)) {
drivers/staging/iio/light/tsl2563.c-	iio_device_unregister(indio_dev);
drivers/staging/iio/light/tsl2563.c-		/* now the interrupt is not enabled, we can go to sleep */
drivers/staging/iio/light/tsl2563.c-out:
drivers/staging/iio/light/tsl2563.c-	/* Remember state for suspend and resume functions */
drivers/staging/iio/light/tsl2563.c-	ret = 0;
drivers/staging/iio/light/tsl2563.c-			ret = tsl2563_set_power(chip, 1);
drivers/staging/iio/light/tsl2563.c:		schedule_delayed_work(&chip->poweroff_work, 5 * HZ);
drivers/staging/iio/light/tsl2563.c:		schedule_delayed_work(&chip->poweroff_work, 5 * HZ);
drivers/staging/iio/light/tsl2563.c:	schedule_delayed_work(&chip->poweroff_work, 5 * HZ);
drivers/staging/iio/light/tsl2563.c:	struct delayed_work	poweroff_work;
drivers/staging/iio/light/tsl2563.c-	struct i2c_client	*client;
drivers/staging/iio/light/tsl2563.c-	struct mutex		lock;
drivers/staging/iio/light/tsl2563.c-	/* The interrupt cannot yet be enabled so this is fine without lock */
drivers/staging/mei/interrupt.c-}
drivers/staging/mei/interrupt.c-	}
drivers/staging/mei/interrupt.c-	mutex_unlock(&dev->device_lock);
drivers/staging/mei/interrupt.c-out:
drivers/staging/mei/interrupt.c:	schedule_delayed_work(&dev->timer_work, 2 * HZ);
drivers/staging/mei/main.c-
drivers/staging/mei/main.c-
drivers/staging/mei/main.c-
drivers/staging/mei/main.c-
drivers/staging/mei/main.c-
drivers/staging/mei/main.c-	mutex_unlock(&mei_mutex);
drivers/staging/mei/main.c-	return err;
drivers/staging/mei/main.c:	schedule_delayed_work(&dev->timer_work, HZ);
drivers/staging/mei/main.c:	schedule_delayed_work(&dev->timer_work, HZ);
drivers/staging/mei/main.c-	/* Start timer if stopped in suspend */
drivers/staging/nvec/nvec_power.c-
drivers/staging/nvec/nvec_power.c-
drivers/staging/nvec/nvec_power.c-
drivers/staging/nvec/nvec_power.c-};
drivers/staging/nvec/nvec_power.c-		break;
drivers/staging/nvec/nvec_power.c-	case BAT:
drivers/staging/nvec/nvec_power.c-		INIT_DELAYED_WORK(&power->poller, nvec_power_poll);
drivers/staging/nvec/nvec_power.c-	int on;
drivers/staging/nvec/nvec_power.c-	nvec_write_async(power->nvec, buf, 2);
drivers/staging/nvec/nvec_power.c:		schedule_delayed_work(&power->poller, msecs_to_jiffies(5000));
drivers/staging/nvec/nvec_power.c:	schedule_delayed_work(to_delayed_work(work), msecs_to_jiffies(5000));
drivers/staging/nvec/nvec_power.c:	struct delayed_work poller;
drivers/staging/nvec/nvec_power.c-	struct notifier_block notifier;
drivers/staging/nvec/nvec_power.c-	struct nvec_chip *nvec;
drivers/staging/nvec/nvec_power.c-struct nvec_power {
drivers/staging/octeon/ethernet.c-
drivers/staging/octeon/ethernet.c-
drivers/staging/octeon/ethernet.c-
drivers/staging/octeon/ethernet.c-
drivers/staging/octeon/ethernet.c-
drivers/staging/octeon/ethernet.c-
drivers/staging/octeon/ethernet.c-
drivers/staging/octeon/ethernet.c-
drivers/staging/octeon/ethernet.c-}
drivers/staging/octeon/ethernet.c- }
drivers/staging/octeon/ethernet.c-			}
drivers/staging/octeon/ethernet.c-	atomic_inc_return(&cvm_oct_poll_queue_stopping);
drivers/staging/octeon/ethernet.c:	cancel_delayed_work_sync(&cvm_oct_rx_refill_work);
drivers/staging/octeon/ethernet.c:			cancel_delayed_work_sync(&priv->port_periodic_work);
drivers/staging/octeon/ethernet.c-				   &cvm_oct_rx_refill_work, HZ);
drivers/staging/octeon/ethernet.c-	cvm_oct_rx_shutdown();
drivers/staging/octeon/ethernet.c-	cvm_oct_tx_poll_interval = 150 * (octeon_get_clock_rate() / 1000000);
drivers/staging/octeon/ethernet.c-			cvm_oct_tx_shutdown_dev(dev);
drivers/staging/octeon/ethernet.c-				    cvmx_pko_get_num_queues(priv->port) *
drivers/staging/octeon/ethernet.c-	if (!atomic_read(&cvm_oct_poll_queue_stopping))
drivers/staging/octeon/ethernet.c-	if (!atomic_read(&cvm_oct_poll_queue_stopping))
drivers/staging/octeon/ethernet.c-						   &priv->port_periodic_work, HZ);
drivers/staging/octeon/ethernet.c:		queue_delayed_work(cvm_oct_poll_queue,
drivers/staging/octeon/ethernet.c:				queue_delayed_work(cvm_oct_poll_queue,
drivers/staging/octeon/ethernet.c:	queue_delayed_work(cvm_oct_poll_queue, &cvm_oct_rx_refill_work, HZ);
drivers/staging/octeon/ethernet.c:		queue_delayed_work(cvm_oct_poll_queue, &priv->port_periodic_work, HZ);
drivers/staging/octeon/ethernet.c-	return 0;
drivers/staging/octeon/ethernet.c-				    sizeof(uint32_t);
drivers/staging/octeon/ethernet.c-			struct net_device *dev = cvm_oct_device[port];
drivers/staging/octeon/ethernet.c-			struct octeon_ethernet *priv = netdev_priv(dev);
drivers/staging/rtl8187se/ieee80211/ieee80211_softmac.c-
drivers/staging/rtl8187se/ieee80211/ieee80211_softmac.c-
drivers/staging/rtl8187se/ieee80211/ieee80211_softmac.c-
drivers/staging/rtl8187se/ieee80211/ieee80211_softmac.c-
drivers/staging/rtl8187se/ieee80211/ieee80211_softmac.c-
drivers/staging/rtl8187se/ieee80211/ieee80211_softmac.c-
drivers/staging/rtl8187se/ieee80211/ieee80211_softmac.c-
drivers/staging/rtl8187se/ieee80211/ieee80211_softmac.c-
drivers/staging/rtl8187se/ieee80211/ieee80211_softmac.c-
drivers/staging/rtl8187se/ieee80211/ieee80211_softmac.c-
drivers/staging/rtl8187se/ieee80211/ieee80211_softmac.c-
drivers/staging/rtl8187se/ieee80211/ieee80211_softmac.c-{
drivers/staging/rtl8187se/ieee80211/ieee80211_softmac.c-{
drivers/staging/rtl8187se/ieee80211/ieee80211_softmac.c-{
drivers/staging/rtl8187se/ieee80211/ieee80211_softmac.c-{
drivers/staging/rtl8187se/ieee80211/ieee80211_softmac.c-}
drivers/staging/rtl8187se/ieee80211/ieee80211_softmac.c-	}
drivers/staging/rtl8187se/ieee80211/ieee80211_softmac.c-	}
drivers/staging/rtl8187se/ieee80211/ieee80211_softmac.c-		}
drivers/staging/rtl8187se/ieee80211/ieee80211_softmac.c-	//add for RF power on power of by lizhaoming 080512
drivers/staging/rtl8187se/ieee80211/ieee80211_softmac.c:	cancel_delayed_work(&ieee->associate_retry_wq);
drivers/staging/rtl8187se/ieee80211/ieee80211_softmac.c:	cancel_delayed_work(&ieee->associate_retry_wq);
drivers/staging/rtl8187se/ieee80211/ieee80211_softmac.c:	cancel_delayed_work(&ieee->GPIOChangeRFWorkItem);
drivers/staging/rtl8187se/ieee80211/ieee80211_softmac.c:		cancel_delayed_work(&ieee->softmac_scan_wq);
drivers/staging/rtl8187se/ieee80211/ieee80211_softmac.c:	cancel_delayed_work(&ieee->start_ibss_wq);
drivers/staging/rtl8187se/ieee80211/ieee80211_softmac.c-		//care this,1203,2007,by lawrence
drivers/staging/rtl8187se/ieee80211/ieee80211_softmac.c-	del_timer_sync(&ieee->associate_timer);
drivers/staging/rtl8187se/ieee80211/ieee80211_softmac.c-	del_timer_sync(&ieee->associate_timer);
drivers/staging/rtl8187se/ieee80211/ieee80211_softmac.c-		//del_timer_sync(&ieee->scan_timer);
drivers/staging/rtl8187se/ieee80211/ieee80211_softmac.c-	destroy_workqueue(ieee->wq);
drivers/staging/rtl8187se/ieee80211/ieee80211_softmac.c-#endif
drivers/staging/rtl8187se/ieee80211/ieee80211_softmac.c-		ieee80211_send_probe_requests(ieee);
drivers/staging/rtl8187se/ieee80211/ieee80211_softmac.c-	ieee80211_stop_scan(ieee);
drivers/staging/rtl8187se/ieee80211/ieee80211_softmac.c-		ieee->scanning = 0;
drivers/staging/rtl8187se/ieee80211/ieee80211_softmac.c-	ieee->state = IEEE80211_ASSOCIATING_RETRY;
drivers/staging/rtl8187se/ieee80211/ieee80211_softmac.c-#if 1
drivers/staging/rtl8187se/ieee80211/ieee80211_softmac.c-inline void ieee80211_start_ibss(struct ieee80211_device *ieee)
drivers/staging/rtl8187se/ieee80211/ieee80211_softmac.c:	queue_delayed_work(ieee->wq, &ieee->associate_retry_wq,IEEE80211_SOFTMAC_ASSOC_RETRY_TIME);
drivers/staging/rtl8187se/ieee80211/ieee80211_softmac.c:			queue_delayed_work(ieee->wq, &ieee->softmac_scan_wq,0);
drivers/staging/rtl8187se/ieee80211/ieee80211_softmac.c:	queue_delayed_work(ieee->wq, &ieee->softmac_scan_wq, IEEE80211_SOFTMAC_SCAN_TIME);
drivers/staging/rtl8187se/ieee80211/ieee80211_softmac.c:	queue_delayed_work(ieee->wq, &ieee->start_ibss_wq, 100);
drivers/staging/rtl8187se/ieee80211/ieee80211_softmac.c-	return;
drivers/staging/rtl8187se/ieee80211/ieee80211_softmac.c-	spin_unlock_irqrestore(&ieee->lock, flags);
drivers/staging/rtl8187se/ieee80211/ieee80211_softmac.c-	static short watchdog = 0;
drivers/staging/rtl8187se/ieee80211/ieee80211_softmac.c:	struct delayed_work *dwork = to_delayed_work(work);
drivers/staging/rtl8187se/ieee80211/ieee80211_softmac.c:	struct delayed_work *dwork = to_delayed_work(work);
drivers/staging/rtl8187se/ieee80211/ieee80211_softmac.c:	struct delayed_work *dwork = to_delayed_work(work);
drivers/staging/rtl8187se/ieee80211/ieee80211_softmac.c-	struct ieee80211_device *ieee = container_of(dwork, struct ieee80211_device, associate_retry_wq);
drivers/staging/rtl8187se/ieee80211/ieee80211_softmac.c-	struct ieee80211_device *ieee = container_of(dwork, struct ieee80211_device, softmac_scan_wq);
drivers/staging/rtl8187se/ieee80211/ieee80211_softmac.c-	struct ieee80211_device *ieee = container_of(dwork, struct ieee80211_device, start_ibss_wq);
drivers/staging/rtl8187se/ieee80211/ieee80211_softmac.c-	unsigned long flags;
drivers/staging/rtl8187se/ieee80211/ieee80211_softmac.c-	up(&ieee->scan_sem);
drivers/staging/rtl8187se/ieee80211/ieee80211_softmac.c-void ieee80211_associate_retry_wq(struct work_struct *work)
drivers/staging/rtl8187se/ieee80211/ieee80211_softmac.c-void ieee80211_softmac_scan_wq(struct work_struct *work)
drivers/staging/rtl8187se/ieee80211/ieee80211_softmac.c-void ieee80211_start_ibss_wq(struct work_struct *work)
drivers/staging/rtl8187se/r8180_core.c-{
drivers/staging/rtl8187se/r8180_core.c-{
drivers/staging/rtl8187se/r8180_core.c-{
drivers/staging/rtl8187se/r8180_core.c-	/*
drivers/staging/rtl8187se/r8180_core.c-	}
drivers/staging/rtl8187se/r8180_core.c-		/* as tl may be less than rb */
drivers/staging/rtl8187se/r8180_core.c:	cancel_delayed_work(&priv->ieee80211->hw_dig_wq);
drivers/staging/rtl8187se/r8180_core.c:	cancel_delayed_work(&priv->ieee80211->hw_dig_wq);
drivers/staging/rtl8187se/r8180_core.c:	cancel_delayed_work(&priv->ieee80211->hw_sleep_wq);
drivers/staging/rtl8187se/r8180_core.c:	cancel_delayed_work(&priv->ieee80211->hw_sleep_wq);
drivers/staging/rtl8187se/r8180_core.c:	cancel_delayed_work(&priv->ieee80211->hw_wakeup_wq);
drivers/staging/rtl8187se/r8180_core.c:	cancel_delayed_work(&priv->ieee80211->hw_wakeup_wq);
drivers/staging/rtl8187se/r8180_core.c:	cancel_delayed_work(&priv->ieee80211->rate_adapter_wq);
drivers/staging/rtl8187se/r8180_core.c:	cancel_delayed_work(&priv->ieee80211->rate_adapter_wq);
drivers/staging/rtl8187se/r8180_core.c:	cancel_delayed_work(&priv->ieee80211->tx_pw_wq);
drivers/staging/rtl8187se/r8180_core.c:	cancel_delayed_work(&priv->ieee80211->tx_pw_wq);
drivers/staging/rtl8187se/r8180_core.c-		container_of(dwork, struct ieee80211_device, watch_dog_wq);
drivers/staging/rtl8187se/r8180_core.c-	del_timer_sync(&priv->rateadapter_timer);
drivers/staging/rtl8187se/r8180_core.c-	del_timer_sync(&priv->rateadapter_timer);
drivers/staging/rtl8187se/r8180_core.c-	del_timer_sync(&priv->SwAntennaDiversityTimer);
drivers/staging/rtl8187se/r8180_core.c-	del_timer_sync(&priv->SwAntennaDiversityTimer);
drivers/staging/rtl8187se/r8180_core.c-	del_timer_sync(&priv->watch_dog_timer);
drivers/staging/rtl8187se/r8180_core.c-	del_timer_sync(&priv->watch_dog_timer);
drivers/staging/rtl8187se/r8180_core.c-	ieee80211_softmac_stop_protocol(priv->ieee80211);
drivers/staging/rtl8187se/r8180_core.c-		priv->DozePeriodInPast2Sec += jiffies_to_msecs(tmp);
drivers/staging/rtl8187se/r8180_core.c:		queue_delayed_work(priv->ieee80211->wq, &priv->ieee80211->hw_wakeup_wq, tmp);
drivers/staging/rtl8187se/r8180_core.c-	SetZebraRFPowerState8185(dev, eRfOff);
drivers/staging/rtl8187se/r8180_core.c:	struct delayed_work *dwork = to_delayed_work(work);
drivers/staging/rtl8187se/r8180_core.c:	struct delayed_work *dwork = to_delayed_work(work);
drivers/staging/rtl8187se/r8180_core.c:	struct delayed_work *dwork = to_delayed_work(work);
drivers/staging/rtl8187se/r8180_core.c-	struct ieee80211_device *ieee = container_of(dwork, struct ieee80211_device, hw_sleep_wq);
drivers/staging/rtl8187se/r8180_core.c-	struct ieee80211_device *ieee = container_of(dwork, struct ieee80211_device, hw_wakeup_wq);
drivers/staging/rtl8187se/r8180_core.c-	struct ieee80211_device * ieee = (struct ieee80211_device *)
drivers/staging/rtl8187se/r8180_core.c-	struct net_device *dev = ieee->dev;
drivers/staging/rtl8187se/r8180_core.c-	struct net_device *dev = ieee->dev;
drivers/staging/rtl8187se/r8180_core.c-void rtl8180_hw_sleep_wq(struct work_struct *work)
drivers/staging/rtl8187se/r8180_core.c-void rtl8180_hw_wakeup_wq(struct work_struct *work)
drivers/staging/rtl8187se/r8180_core.c-void rtl8180_tx_irq_wq(struct work_struct *work)
drivers/staging/rtl8192e/rtllib.h-
drivers/staging/rtl8192e/rtllib.h-
drivers/staging/rtl8192e/rtllib.h-
drivers/staging/rtl8192e/rtllib.h-
drivers/staging/rtl8192e/rtllib.h-
drivers/staging/rtl8192e/rtllib.h:	container_of(container_of(x, struct delayed_work, work), y, z)
drivers/staging/rtl8192e/rtllib.h-#define container_of_dwork_rsl(x, y, z)				\
drivers/staging/rtl8192e/rtllib.h-#define container_of_work_rsl(x, y, z) container_of(x, y, z)
drivers/staging/rtl8192e/rtllib.h-#define INIT_DELAYED_WORK_RSL(x, y, z) INIT_DELAYED_WORK(x, y)
drivers/staging/rtl8192e/rtllib.h-#define iwe_stream_add_event_rsl(info, start, stop, iwe, len)	\
drivers/staging/rtl8192e/rtllib.h:#define queue_delayed_work_rsl(x, y, z) queue_delayed_work(x, y, z)
drivers/staging/rtl8192e/rtllib.h:	struct delayed_work associate_procedure_wq;
drivers/staging/rtl8192e/rtllib.h:	struct delayed_work associate_retry_wq;
drivers/staging/rtl8192e/rtllib.h:	struct delayed_work hw_sleep_wq;
drivers/staging/rtl8192e/rtllib.h:	struct delayed_work hw_wakeup_wq;
drivers/staging/rtl8192e/rtllib.h:	struct delayed_work link_change_wq;
drivers/staging/rtl8192e/rtllib.h:	struct delayed_work softmac_hint11d_wq;
drivers/staging/rtl8192e/rtllib.h:	struct delayed_work softmac_scan_wq;
drivers/staging/rtl8192e/rtllib.h:	struct delayed_work start_ibss_wq;
drivers/staging/rtl8192e/rtllib.h-	struct work_struct associate_complete_wq;
drivers/staging/rtl8192e/rtllib.h-	struct work_struct ips_leave_wq;
drivers/staging/rtl8192e/rtllib.h-	struct work_struct wx_sync_scan_wq;
drivers/staging/rtl8192u/ieee80211/ieee80211_softmac.c-
drivers/staging/rtl8192u/ieee80211/ieee80211_softmac.c-
drivers/staging/rtl8192u/ieee80211/ieee80211_softmac.c-
drivers/staging/rtl8192u/ieee80211/ieee80211_softmac.c-
drivers/staging/rtl8192u/ieee80211/ieee80211_softmac.c-
drivers/staging/rtl8192u/ieee80211/ieee80211_softmac.c-
drivers/staging/rtl8192u/ieee80211/ieee80211_softmac.c-
drivers/staging/rtl8192u/ieee80211/ieee80211_softmac.c-
drivers/staging/rtl8192u/ieee80211/ieee80211_softmac.c-
drivers/staging/rtl8192u/ieee80211/ieee80211_softmac.c-
drivers/staging/rtl8192u/ieee80211/ieee80211_softmac.c-
drivers/staging/rtl8192u/ieee80211/ieee80211_softmac.c-
drivers/staging/rtl8192u/ieee80211/ieee80211_softmac.c-{
drivers/staging/rtl8192u/ieee80211/ieee80211_softmac.c-{
drivers/staging/rtl8192u/ieee80211/ieee80211_softmac.c-{
drivers/staging/rtl8192u/ieee80211/ieee80211_softmac.c-{
drivers/staging/rtl8192u/ieee80211/ieee80211_softmac.c-}
drivers/staging/rtl8192u/ieee80211/ieee80211_softmac.c-	}
drivers/staging/rtl8192u/ieee80211/ieee80211_softmac.c-		}
drivers/staging/rtl8192u/ieee80211/ieee80211_softmac.c:	cancel_delayed_work(&ieee->associate_retry_wq);
drivers/staging/rtl8192u/ieee80211/ieee80211_softmac.c:	cancel_delayed_work(&ieee->associate_retry_wq);
drivers/staging/rtl8192u/ieee80211/ieee80211_softmac.c:		cancel_delayed_work(&ieee->softmac_scan_wq);
drivers/staging/rtl8192u/ieee80211/ieee80211_softmac.c:	cancel_delayed_work(&ieee->start_ibss_wq);
drivers/staging/rtl8192u/ieee80211/ieee80211_softmac.c-	del_timer_sync(&ieee->associate_timer);
drivers/staging/rtl8192u/ieee80211/ieee80211_softmac.c-	del_timer_sync(&ieee->associate_timer);
drivers/staging/rtl8192u/ieee80211/ieee80211_softmac.c-	destroy_workqueue(ieee->wq);
drivers/staging/rtl8192u/ieee80211/ieee80211_softmac.c-	}else
drivers/staging/rtl8192u/ieee80211/ieee80211_softmac.c-			   IEEE80211_SOFTMAC_ASSOC_RETRY_TIME);
drivers/staging/rtl8192u/ieee80211/ieee80211_softmac.c-	ieee80211_stop_scan(ieee);
drivers/staging/rtl8192u/ieee80211/ieee80211_softmac.c-	ieee80211_stop_send_beacons(ieee);
drivers/staging/rtl8192u/ieee80211/ieee80211_softmac.c-		ieee->scanning = 0;
drivers/staging/rtl8192u/ieee80211/ieee80211_softmac.c-			ieee->scanning = 1;
drivers/staging/rtl8192u/ieee80211/ieee80211_softmac.c-	ieee->state = IEEE80211_ASSOCIATING_RETRY;
drivers/staging/rtl8192u/ieee80211/ieee80211_softmac.c-		if (ieee->scanning == 0){
drivers/staging/rtl8192u/ieee80211/ieee80211_softmac.c-inline void ieee80211_start_ibss(struct ieee80211_device *ieee)
drivers/staging/rtl8192u/ieee80211/ieee80211_softmac.c-	/* iwconfig mode ad-hoc will schedule this and return
drivers/staging/rtl8192u/ieee80211/ieee80211_softmac.c:	queue_delayed_work(ieee->wq, &ieee->associate_retry_wq, \
drivers/staging/rtl8192u/ieee80211/ieee80211_softmac.c:			queue_delayed_work(ieee->wq, &ieee->softmac_scan_wq, 0);
drivers/staging/rtl8192u/ieee80211/ieee80211_softmac.c:	queue_delayed_work(ieee->wq, &ieee->softmac_scan_wq, IEEE80211_SOFTMAC_SCAN_TIME);
drivers/staging/rtl8192u/ieee80211/ieee80211_softmac.c:	queue_delayed_work(ieee->wq, &ieee->start_ibss_wq, 150);
drivers/staging/rtl8192u/ieee80211/ieee80211_softmac.c-	static short watchdog = 0;
drivers/staging/rtl8192u/ieee80211/ieee80211_softmac.c:        struct delayed_work *dwork = container_of(work, struct delayed_work, work);
drivers/staging/rtl8192u/ieee80211/ieee80211_softmac.c:	struct delayed_work *dwork = container_of(work, struct delayed_work, work);
drivers/staging/rtl8192u/ieee80211/ieee80211_softmac.c:	struct delayed_work *dwork = container_of(work, struct delayed_work, work);
drivers/staging/rtl8192u/ieee80211/ieee80211_softmac.c-        struct ieee80211_device *ieee = container_of(dwork, struct ieee80211_device, associate_retry_wq);
drivers/staging/rtl8192u/ieee80211/ieee80211_softmac.c-	struct ieee80211_device *ieee = container_of(dwork, struct ieee80211_device, softmac_scan_wq);
drivers/staging/rtl8192u/ieee80211/ieee80211_softmac.c-	struct ieee80211_device *ieee = container_of(dwork, struct ieee80211_device, start_ibss_wq);
drivers/staging/rtl8192u/ieee80211/ieee80211_softmac.c-	unsigned long flags;
drivers/staging/rtl8192u/ieee80211/ieee80211_softmac.c-	up(&ieee->scan_sem);
drivers/staging/rtl8192u/ieee80211/ieee80211_softmac.c-void ieee80211_associate_retry_wq(struct work_struct *work)
drivers/staging/rtl8192u/ieee80211/ieee80211_softmac.c-void ieee80211_softmac_scan_wq(struct work_struct *work)
drivers/staging/rtl8192u/r8192U_core.c-
drivers/staging/rtl8192u/r8192U_core.c-
drivers/staging/rtl8192u/r8192U_core.c-
drivers/staging/rtl8192u/r8192U_core.c-
drivers/staging/rtl8192u/r8192U_core.c-
drivers/staging/rtl8192u/r8192U_core.c-{
drivers/staging/rtl8192u/r8192U_core.c-}
drivers/staging/rtl8192u/r8192U_core.c-	}
drivers/staging/rtl8192u/r8192U_core.c:	//as cancel_delayed_work will del work->timer, so if work is not definedas struct delayed_work, it will corrupt
drivers/staging/rtl8192u/r8192U_core.c:			cancel_delayed_work(&ieee->associate_retry_wq);
drivers/staging/rtl8192u/r8192U_core.c:	//cancel_delayed_work(&priv->SwChnlWorkItem);
drivers/staging/rtl8192u/r8192U_core.c:	cancel_delayed_work(&priv->update_beacon_wq);
drivers/staging/rtl8192u/r8192U_core.c:	cancel_delayed_work(&priv->watch_dog_wq);
drivers/staging/rtl8192u/r8192U_core.c-	cancel_work_sync(&priv->qos_activate);
drivers/staging/rtl8192u/r8192U_core.c-	cancel_work_sync(&priv->reset_wq);
drivers/staging/rtl8192u/r8192U_core.c-	//cancel_work_sync(&priv->SetBWModeWorkItem);
drivers/staging/rtl8192u/r8192U_core.c-			del_timer_sync(&ieee->associate_timer);
drivers/staging/rtl8192u/r8192U_core.c-	del_timer_sync(&priv->watch_dog_timer);
drivers/staging/rtl8192u/r8192U_core.c-extern	void	rtl819x_watchdog_wqcallback(struct work_struct *work)
drivers/staging/rtl8192u/r8192U_core.c-//	flush_scheduled_work();
drivers/staging/rtl8192u/r8192U_core.c-	ieee80211_softmac_stop_protocol(priv->ieee80211);
drivers/staging/rtl8192u/r8192U_core.c-			ieee80211_stop_scan(ieee);
drivers/staging/rtl8192u/r8192U_core.c-			ieee80211_stop_send_beacons(priv->ieee80211);
drivers/staging/rtl8192u/r8192U_core.c-	mod_timer(&priv->watch_dog_timer, jiffies + MSECS(IEEE80211_WATCH_DOG_TIME));
drivers/staging/rtl8192u/r8192U_core.c-			netif_carrier_off(dev);
drivers/staging/rtl8192u/r8192U_core.c-	//printk("===============>watch_dog  timer\n");
drivers/staging/rtl8192u/r8192U_core.c:	queue_delayed_work(priv->priv_wq, &priv->update_beacon_wq, 0);
drivers/staging/rtl8192u/r8192U_core.c:	queue_delayed_work(priv->priv_wq,&priv->watch_dog_wq, 0);
drivers/staging/rtl8192u/r8192U_core.c-	return 0;
drivers/staging/rtl8192u/r8192U_core.c-	rtl8192_cancel_deferred_work(priv);
drivers/staging/rtl8192u/r8192U_core.c-	rtl8192_cancel_deferred_work(priv);
drivers/staging/rtl8192u/r8192U_core.c-	rtl8192_qos_handle_probe_response(priv,1,network);
drivers/staging/rtl8192u/r8192U_core.c:	struct delayed_work *dwork = container_of(work,struct delayed_work,work);
drivers/staging/rtl8192u/r8192U_core.c-       struct net_device *dev = priv->ieee80211->dev;
drivers/staging/rtl8192u/r8192U_core.c-       struct r8192_priv *priv = container_of(dwork,struct r8192_priv,watch_dog_wq);
drivers/staging/rtl8192u/r8192U_core.c-	struct r8192_priv *priv = ieee80211_priv((struct net_device *) data);
drivers/staging/rtl8192u/r8192U_dm.c-
drivers/staging/rtl8192u/r8192U_dm.c-
drivers/staging/rtl8192u/r8192U_dm.c-{
drivers/staging/rtl8192u/r8192U_dm.c-{
drivers/staging/rtl8192u/r8192U_dm.c-{
drivers/staging/rtl8192u/r8192U_dm.c-{
drivers/staging/rtl8192u/r8192U_dm.c-	{
drivers/staging/rtl8192u/r8192U_dm.c-	}
drivers/staging/rtl8192u/r8192U_dm.c-		{
drivers/staging/rtl8192u/r8192U_dm.c-		}
drivers/staging/rtl8192u/r8192U_dm.c-		//DbgPrint("Schedule TxPowerTrackingWorkItem\n");
drivers/staging/rtl8192u/r8192U_dm.c-}	/* dm_CheckRxRFPath */
drivers/staging/rtl8192u/r8192U_dm.c-#endif
drivers/staging/rtl8192u/r8192U_dm.c-#endif
drivers/staging/rtl8192u/r8192U_dm.c-extern	void	dm_gpio_change_rf_callback(struct work_struct *work)
drivers/staging/rtl8192u/r8192U_dm.c-extern	void	dm_rf_pathcheck_workitemcallback(struct work_struct *work)
drivers/staging/rtl8192u/r8192U_dm.c-extern	void	dm_txpower_trackingcallback(struct work_struct *work)
drivers/staging/rtl8192u/r8192U_dm.c-#ifdef RTL8192E
drivers/staging/rtl8192u/r8192U_dm.c-		if((tx_power_track_counter % 30 == 0)&&(tx_power_track_counter != 0))
drivers/staging/rtl8192u/r8192U_dm.c:		queue_delayed_work(priv->priv_wq,&priv->gpio_change_rf_wq,0);
drivers/staging/rtl8192u/r8192U_dm.c:	queue_delayed_work(priv->priv_wq,&priv->rfpath_check_wq,0);
drivers/staging/rtl8192u/r8192U_dm.c:			queue_delayed_work(priv->priv_wq,&priv->txpower_tracking_wq,0);
drivers/staging/rtl8192u/r8192U_dm.c:				queue_delayed_work(priv->priv_wq,&priv->txpower_tracking_wq,0);
drivers/staging/rtl8192u/r8192U_dm.c:	struct delayed_work *dwork = container_of(work,struct delayed_work,work);
drivers/staging/rtl8192u/r8192U_dm.c:	struct delayed_work *dwork = container_of(work,struct delayed_work,work);
drivers/staging/rtl8192u/r8192U_dm.c:	struct delayed_work *dwork = container_of(work,struct delayed_work,work);
drivers/staging/rtl8192u/r8192U_dm.c-       struct net_device *dev =priv->ieee80211->dev;
drivers/staging/rtl8192u/r8192U_dm.c-       struct net_device *dev = priv->ieee80211->dev;
drivers/staging/rtl8192u/r8192U_dm.c-       struct net_device *dev = priv->ieee80211->dev;
drivers/staging/rtl8192u/r8192U_dm.c-       struct r8192_priv *priv = container_of(dwork,struct r8192_priv,gpio_change_rf_wq);
drivers/staging/rtl8192u/r8192U_dm.c-       struct r8192_priv *priv = container_of(dwork,struct r8192_priv,rfpath_check_wq);
drivers/staging/rtl8192u/r8192U_dm.c-       struct r8192_priv *priv = container_of(dwork,struct r8192_priv,txpower_tracking_wq);
drivers/staging/rtl8192u/r8192U_dm.c-	struct r8192_priv *priv = ieee80211_priv(dev);
drivers/staging/rtl8192u/r8192U_dm.c-		TM_Trigger = 0;
drivers/staging/rtl8192u/r8192U_dm.c-		tx_power_track_counter++;
drivers/staging/rtl8192u/r819xU_phy.c-{
drivers/staging/rtl8192u/r819xU_phy.c-}
drivers/staging/rtl8192u/r819xU_phy.c-	{
drivers/staging/rtl8192u/r819xU_phy.c-	}
drivers/staging/rtl8192u/r819xU_phy.c-extern void InitialGainOperateWorkItemCallBack(struct work_struct *work)
drivers/staging/rtl8192u/r819xU_phy.c-	if(priv->up)
drivers/staging/rtl8192u/r819xU_phy.c:		queue_delayed_work(priv->priv_wq,&priv->initialgain_operate_wq,0);
drivers/staging/rtl8192u/r819xU_phy.c:	struct delayed_work *dwork = container_of(work,struct delayed_work,work);
drivers/staging/rtl8192u/r819xU_phy.c-       struct net_device *dev = priv->ieee80211->dev;
drivers/staging/rtl8192u/r819xU_phy.c-       struct r8192_priv *priv = container_of(dwork,struct r8192_priv,initialgain_operate_wq);
drivers/staging/zcache/ramster/ramster.c-
drivers/staging/zcache/ramster/ramster.c-
drivers/staging/zcache/ramster/ramster.c-
drivers/staging/zcache/ramster/ramster.c-{
drivers/staging/zcache/ramster/ramster.c-}
drivers/staging/zcache/ramster/ramster.c-}
drivers/staging/zcache/ramster/ramster.c-	}
drivers/staging/zcache/ramster/ramster.c-	}
drivers/staging/zcache/ramster/ramster.c-		create_singlethread_workqueue("ramster_remotify");
drivers/staging/zcache/ramster/ramster.c-		frontswap_selfshrink();
drivers/staging/zcache/ramster/ramster.c-	if (frontswap_selfshrinking) {
drivers/staging/zcache/ramster/ramster.c-	if (frontswap_selfshrinking && frontswap_enabled) {
drivers/staging/zcache/ramster/ramster.c:	if (!queue_delayed_work(ramster_remotify_workqueue,
drivers/staging/zcache/ramster/ramster.c-		pr_err("ramster_remotify: bad workqueue\n");
drivers/staging/zcache/ramster/ramster.c-		pr_info("ramster: Initializing frontswap selfshrink driver.\n");
drivers/staging/zcache/ramster/ramster.c-		ramster_remotify_process);
drivers/staging/zcache/ramster/ramster.c:	ramster_remotify_queue_delayed_work(HZ);
drivers/staging/zcache/ramster/ramster.c:	ramster_remotify_queue_delayed_work(n * HZ);
drivers/staging/zcache/ramster/ramster.c-				&ramster_remotify_worker, delay))
drivers/staging/zcache/ramster/ramster.c-	ramster_remotify_workqueue =
drivers/staging/zcache/ramster/ramster.c-	remotify_in_progress = false;
drivers/staging/zcache/ramster/ramster.c-requeue:
drivers/staging/zcache/ramster/ramster.c:		schedule_delayed_work(&selfshrink_worker,
drivers/staging/zcache/ramster/ramster.c:		schedule_delayed_work(&selfshrink_worker,
drivers/staging/zcache/ramster/ramster.c-					selfshrink_interval * HZ);
drivers/staging/zcache/ramster/ramster.c-			selfshrink_interval * HZ);
drivers/staging/zcache/ramster/ramster.c:static void ramster_remotify_queue_delayed_work(unsigned long delay)
drivers/staging/zcache/ramster/tcp.c-
drivers/staging/zcache/ramster/tcp.c-
drivers/staging/zcache/ramster/tcp.c-
drivers/staging/zcache/ramster/tcp.c-
drivers/staging/zcache/ramster/tcp.c-
drivers/staging/zcache/ramster/tcp.c-{
drivers/staging/zcache/ramster/tcp.c-{
drivers/staging/zcache/ramster/tcp.c-{
drivers/staging/zcache/ramster/tcp.c-}
drivers/staging/zcache/ramster/tcp.c-}
drivers/staging/zcache/ramster/tcp.c-}
drivers/staging/zcache/ramster/tcp.c-	}
drivers/staging/zcache/ramster/tcp.c-	}
drivers/staging/zcache/ramster/tcp.c-	}
drivers/staging/zcache/ramster/tcp.c-		/*
drivers/staging/zcache/ramster/tcp.c-		 */
drivers/staging/zcache/ramster/tcp.c:		cancel_delayed_work(&nn->nn_connect_expired);
drivers/staging/zcache/ramster/tcp.c:		cancel_delayed_work(&nn->nn_connect_expired);
drivers/staging/zcache/ramster/tcp.c:		cancel_delayed_work(&nn->nn_connect_work);
drivers/staging/zcache/ramster/tcp.c:		cancel_delayed_work(&nn->nn_still_up);
drivers/staging/zcache/ramster/tcp.c-			delay = 0;
drivers/staging/zcache/ramster/tcp.c-		delay += msecs_to_jiffies(r2net_idle_timeout());
drivers/staging/zcache/ramster/tcp.c-		del_timer_sync(&sc->sc_idle_timeout);
drivers/staging/zcache/ramster/tcp.c-		flush_workqueue(r2net_wq);
drivers/staging/zcache/ramster/tcp.c:	if (cancel_delayed_work(work))
drivers/staging/zcache/ramster/tcp.c:	if (!queue_delayed_work(r2net_wq, work, delay))
drivers/staging/zcache/ramster/tcp.c-	if (r2net_wq) {
drivers/staging/zcache/ramster/tcp.c-	if (!was_err && nn->nn_persistent_error) {
drivers/staging/zcache/ramster/tcp.c-	if (!was_valid && valid) {
drivers/staging/zcache/ramster/tcp.c-					int delay)
drivers/staging/zcache/ramster/tcp.c-		kernel_sock_shutdown(sc->sc_sock, SHUT_RDWR);
drivers/staging/zcache/ramster/tcp.c-		mlog(ML_CONN, "queueing conn attempt in %lu jiffies\n", delay);
drivers/staging/zcache/ramster/tcp.c-		      msecs_to_jiffies(r2net_keepalive_delay()));
drivers/staging/zcache/ramster/tcp.c-				   msecs_to_jiffies(R2NET_QUORUM_DELAY_MS));
drivers/staging/zcache/ramster/tcp.c-		pr_notice("ramster: %s " SC_NODEF_FMT "\n",
drivers/staging/zcache/ramster/tcp.c:		queue_delayed_work(r2net_wq, &nn->nn_connect_expired, delay);
drivers/staging/zcache/ramster/tcp.c:		queue_delayed_work(r2net_wq, &nn->nn_connect_work, delay);
drivers/staging/zcache/ramster/tcp.c:		queue_delayed_work(r2net_wq, &nn->nn_still_up,
drivers/staging/zcache/ramster/tcp.c:		r2net_sc_cancel_delayed_work(sc, &sc->sc_keepalive_work);
drivers/staging/zcache/ramster/tcp.c:	r2net_sc_cancel_delayed_work(sc, &sc->sc_keepalive_work);
drivers/staging/zcache/ramster/tcp.c:	r2net_sc_queue_delayed_work(sc, &sc->sc_keepalive_work,
drivers/staging/zcache/ramster/tcp.c-	r2net_set_sock_timer(sc);
drivers/staging/zcache/ramster/tcp.c-		       r2nm_this_node() > sc->sc_node->nd_num ?
drivers/staging/zcache/ramster/tcp.c-		 * races with pending sc work structs are harmless */
drivers/staging/zcache/ramster/tcp.c-	sc_get(sc);
drivers/staging/zcache/ramster/tcp.c-		sc_put(sc);
drivers/staging/zcache/ramster/tcp.c-		sc_put(sc);
drivers/staging/zcache/ramster/tcp.c-		sc_put(sc);
drivers/staging/zcache/ramster/tcp.c-		sc_put(sc);
drivers/staging/zcache/ramster/tcp.c:static void r2net_sc_cancel_delayed_work(struct r2net_sock_container *sc,
drivers/staging/zcache/ramster/tcp.c:static void r2net_sc_queue_delayed_work(struct r2net_sock_container *sc,
drivers/staging/zcache/ramster/tcp.c-static void r2net_sc_reset_idle_timer(struct r2net_sock_container *sc)
drivers/staging/zcache/ramster/tcp.c:					 struct delayed_work *work)
drivers/staging/zcache/ramster/tcp.c:					struct delayed_work *work,
drivers/switch/hds_fsa8008.c-
drivers/switch/hds_fsa8008.c-
drivers/switch/hds_fsa8008.c-
drivers/switch/hds_fsa8008.c-
drivers/switch/hds_fsa8008.c-{
drivers/switch/hds_fsa8008.c-{
drivers/switch/hds_fsa8008.c-{
drivers/switch/hds_fsa8008.c-};
drivers/switch/hds_fsa8008.c-	}
drivers/switch/hds_fsa8008.c-			dwork, struct hsd_info, work_for_key_released);
drivers/switch/hds_fsa8008.c-#else
drivers/switch/hds_fsa8008.c-#else
drivers/switch/hds_fsa8008.c-#else
drivers/switch/hds_fsa8008.c-#else
drivers/switch/hds_fsa8008.c-	else
drivers/switch/hds_fsa8008.c-	else
drivers/switch/hds_fsa8008.c-#endif
drivers/switch/hds_fsa8008.c-#endif
drivers/switch/hds_fsa8008.c-#endif
drivers/switch/hds_fsa8008.c-#endif
drivers/switch/hds_fsa8008.c-				hi->latency_for_key );
drivers/switch/hds_fsa8008.c-				hi->latency_for_key );
drivers/switch/hds_fsa8008.c-				hi->latency_for_key );
drivers/switch/hds_fsa8008.c-				hi->latency_for_key );
drivers/switch/hds_fsa8008.c-			hi->latency_for_key );
drivers/switch/hds_fsa8008.c-				&(hi->work_for_key_pressed),
drivers/switch/hds_fsa8008.c-				&(hi->work_for_key_released),
drivers/switch/hds_fsa8008.c-			&(hi->work_for_key_released), hi->latency_for_key );
drivers/switch/hds_fsa8008.c-	if (atomic_read(&hi->btn_state))
drivers/switch/hds_fsa8008.c-#ifdef FSA8008_USE_WORK_QUEUE
drivers/switch/hds_fsa8008.c-#ifdef FSA8008_USE_WORK_QUEUE
drivers/switch/hds_fsa8008.c-#ifdef	FSA8008_USE_WORK_QUEUE
drivers/switch/hds_fsa8008.c-#ifdef	FSA8008_USE_WORK_QUEUE
drivers/switch/hds_fsa8008.c-	if (value)
drivers/switch/hds_fsa8008.c-	if (value)
drivers/switch/hds_fsa8008.c-	int saved_detect;
drivers/switch/hds_fsa8008.c-	int state;
drivers/switch/hds_fsa8008.c-			msecs_to_jiffies(FSA8008_DEBOUNCE_TIME));
drivers/switch/hds_fsa8008.c-			msecs_to_jiffies(FSA8008_DEBOUNCE_TIME));
drivers/switch/hds_fsa8008.c:	queue_delayed_work(local_fsa8008_workqueue,
drivers/switch/hds_fsa8008.c:		queue_delayed_work(local_fsa8008_workqueue,
drivers/switch/hds_fsa8008.c:		queue_delayed_work(local_fsa8008_workqueue,
drivers/switch/hds_fsa8008.c:	queue_delayed_work(local_fsa8008_workqueue, &(hi->work),
drivers/switch/hds_fsa8008.c:		queue_delayed_work(local_fsa8008_workqueue, &(hi->work), 0);
drivers/switch/hds_fsa8008.c:	schedule_delayed_work(&(hi->work),
drivers/switch/hds_fsa8008.c:		schedule_delayed_work(&(hi->work), 0);
drivers/switch/hds_fsa8008.c:		schedule_delayed_work(&(hi->work_for_key_pressed),
drivers/switch/hds_fsa8008.c:	schedule_delayed_work(&(hi->work_for_key_released),
drivers/switch/hds_fsa8008.c:		schedule_delayed_work(&(hi->work_for_key_released),
drivers/switch/hds_fsa8008.c-static void button_pressed(struct work_struct *work)
drivers/switch/hds_fsa8008.c-static void button_released(struct work_struct *work)
drivers/switch/hds_fsa8008.c:	struct delayed_work *dwork = container_of(
drivers/switch/hds_fsa8008.c:	struct delayed_work *dwork = container_of(
drivers/switch/hds_fsa8008.c:	struct delayed_work *dwork = container_of(work, struct delayed_work, work);
drivers/switch/hds_fsa8008.c:	struct delayed_work work;
drivers/switch/hds_fsa8008.c:	struct delayed_work work_for_key_pressed;
drivers/switch/hds_fsa8008.c:	struct delayed_work work_for_key_released;
drivers/switch/hds_fsa8008.c-	struct hsd_info *hi = container_of(
drivers/switch/hds_fsa8008.c-	struct hsd_info *hi = container_of(dwork, struct hsd_info, work);
drivers/switch/hds_fsa8008.c-	struct hsd_info *hi = container_of(dwork, struct hsd_info, work_for_key_pressed);
drivers/switch/hds_fsa8008.c-		/* to detect in initialization with eacjack insertion */
drivers/switch/hds_fsa8008.c-		/* to detect in initialization with eacjack insertion */
drivers/switch/hds_fsa8008.c-	/* work for detect_work */
drivers/switch/hds_fsa8008.c:			work, struct delayed_work, work);
drivers/switch/hds_fsa8008.c:			work, struct delayed_work, work);
drivers/thermal/franco_thermal.c-
drivers/thermal/franco_thermal.c-
drivers/thermal/franco_thermal.c-
drivers/thermal/franco_thermal.c-
drivers/thermal/franco_thermal.c-
drivers/thermal/franco_thermal.c-
drivers/thermal/franco_thermal.c-}
drivers/thermal/franco_thermal.c-	INIT_DELAYED_WORK(&check_temp_work, check_temp);
drivers/thermal/franco_thermal.c-reschedule:
drivers/thermal/franco_thermal.c-	return ret;
drivers/thermal/franco_thermal.c:	schedule_delayed_work_on(0, &check_temp_work, 0);
drivers/thermal/franco_thermal.c:	schedule_delayed_work_on(0, &check_temp_work, msecs_to_jiffies(250));
drivers/thermal/franco_thermal.c:static struct delayed_work check_temp_work;
drivers/thermal/franco_thermal.c-static struct msm_thermal_data franco_thermal_info;
drivers/thermal/franco_thermal.c-unsigned short get_threshold(void)
drivers/thermal/machinex_thermal.c-
drivers/thermal/machinex_thermal.c-
drivers/thermal/machinex_thermal.c-
drivers/thermal/machinex_thermal.c-
drivers/thermal/machinex_thermal.c-}
drivers/thermal/machinex_thermal.c-}
drivers/thermal/machinex_thermal.c-};
drivers/thermal/machinex_thermal.c-		}
drivers/thermal/machinex_thermal.c-bool core_control_enabled;
drivers/thermal/machinex_thermal.c-		break;
drivers/thermal/machinex_thermal.c:	cancel_delayed_work_sync(&check_temp_work);
drivers/thermal/machinex_thermal.c-	case PM_SUSPEND_PREPARE:
drivers/thermal/machinex_thermal.c-					   &check_temp_work, 0);
drivers/thermal/machinex_thermal.c-	destroy_workqueue(intellithermal_wq);
drivers/thermal/machinex_thermal.c-	if (likely(enabled))
drivers/thermal/machinex_thermal.c-			INIT_DELAYED_WORK(&check_temp_work, check_temp);
drivers/thermal/machinex_thermal.c-			intellithermal_wq = create_hipri_workqueue("intellithermal");
drivers/thermal/machinex_thermal.c:		mod_delayed_work_on(0, intellithermal_wq, &check_temp_work,
drivers/thermal/machinex_thermal.c:		mod_delayed_work_on(0, intellithermal_wq, &check_temp_work, 0);
drivers/thermal/machinex_thermal.c-				msecs_to_jiffies(msm_thermal_info.poll_ms));
drivers/thermal/machinex_thermal.c-			mutex_unlock(&core_control_mutex);
drivers/thermal/machinex_thermal.c-			pr_debug("msm_thermal: rescheduling...\n");
drivers/thermal/machinex_thermal.c:			queue_delayed_work_on(0, intellithermal_wq,
drivers/thermal/machinex_thermal.c:	queue_delayed_work_on(0, intellithermal_wq, &check_temp_work, 0);
drivers/thermal/machinex_thermal.c-		register_cpu_notifier(&msm_thermal_cpu_notifier);
drivers/thermal/machinex_thermal.c-	register_pm_notifier(&msm_thermal_pm_notifier);
drivers/thermal/machinex_thermal.c-			return;
drivers/thermal/machinex_thermal.c-	return 0;
drivers/thermal/machinex_thermal.c:static struct delayed_work check_temp_work;
drivers/thermal/machinex_thermal.c-static struct workqueue_struct *intellithermal_wq;
drivers/thermal/msm_thermal_backup.c-
drivers/thermal/msm_thermal_backup.c-
drivers/thermal/msm_thermal_backup.c-
drivers/thermal/msm_thermal_backup.c-
drivers/thermal/msm_thermal_backup.c-}
drivers/thermal/msm_thermal_backup.c-}
drivers/thermal/msm_thermal_backup.c-};
drivers/thermal/msm_thermal_backup.c-		}
drivers/thermal/msm_thermal_backup.c-		break;
drivers/thermal/msm_thermal_backup.c:	cancel_delayed_work_sync(&check_temp_work);
drivers/thermal/msm_thermal_backup.c-	case PM_SUSPEND_PREPARE:
drivers/thermal/msm_thermal_backup.c-					   &check_temp_work, 0);
drivers/thermal/msm_thermal_backup.c-	destroy_workqueue(intellithermal_wq);
drivers/thermal/msm_thermal_backup.c-	if (likely(enabled))
drivers/thermal/msm_thermal_backup.c-			INIT_DELAYED_WORK(&check_temp_work, check_temp);
drivers/thermal/msm_thermal_backup.c-			intellithermal_wq = create_hipri_workqueue("intellithermal");
drivers/thermal/msm_thermal_backup.c:		mod_delayed_work_on(0, intellithermal_wq, &check_temp_work,
drivers/thermal/msm_thermal_backup.c:		mod_delayed_work_on(0, intellithermal_wq, &check_temp_work, 0);
drivers/thermal/msm_thermal_backup.c-				msecs_to_jiffies(msm_thermal_info.poll_ms));
drivers/thermal/msm_thermal_backup.c-			mutex_unlock(&core_control_mutex);
drivers/thermal/msm_thermal_backup.c-			pr_debug("msm_thermal: rescheduling...\n");
drivers/thermal/msm_thermal_backup.c:			queue_delayed_work_on(0, intellithermal_wq,
drivers/thermal/msm_thermal_backup.c:	queue_delayed_work_on(0, intellithermal_wq, &check_temp_work, 0);
drivers/thermal/msm_thermal_backup.c-		register_cpu_notifier(&msm_thermal_cpu_notifier);
drivers/thermal/msm_thermal_backup.c-	register_pm_notifier(&msm_thermal_pm_notifier);
drivers/thermal/msm_thermal_backup.c-	return 0;
drivers/thermal/msm_thermal_backup.c-static bool core_control_enabled;
drivers/thermal/msm_thermal_backup.c:static struct delayed_work check_temp_work;
drivers/thermal/msm_thermal_backup.c-static struct workqueue_struct *intellithermal_wq;
drivers/thermal/msm_thermal_backup.c-	unsigned int cpu = smp_processor_id();
drivers/thermal/msm_thermal.c-
drivers/thermal/msm_thermal.c-
drivers/thermal/msm_thermal.c-}
drivers/thermal/msm_thermal.c-	}
drivers/thermal/msm_thermal.c-		}
drivers/thermal/msm_thermal.c-		break;
drivers/thermal/msm_thermal.c-	default:
drivers/thermal/msm_thermal.c-	if (!setup_mitigator()) {
drivers/thermal/msm_thermal.c-	last_tempcheck = ktime_get();
drivers/thermal/msm_thermal.c:		mod_delayed_work(intellithermal_wq, &check_temp_work, 0);
drivers/thermal/msm_thermal.c-				msecs_to_jiffies(msm_thermal_info.poll_ms));
drivers/thermal/msm_thermal.c-			mutex_unlock(&core_control_mutex);
drivers/thermal/msm_thermal.c:		queue_delayed_work(intellithermal_wq, &check_temp_work,
drivers/thermal/msm_thermal.c:		queue_delayed_work(intellithermal_wq, &check_temp_work, 0);
drivers/thermal/msm_thermal.c-reschedule:
drivers/thermal/msm_thermal.c-		return;
drivers/thermal/msm_thermal.c-static const uint32_t msm_sens_id[NR_CPUS] = { 7, 8, 9, 10 };
drivers/thermal/msm_thermal.c:static struct delayed_work check_temp_work;
drivers/thermal/msm_thermal.c-static struct workqueue_struct *intellithermal_wq;
drivers/thermal/msm_thermal.c-static struct work_struct get_table_work;
drivers/thermal/msm_thermal-last-working.c-
drivers/thermal/msm_thermal-last-working.c-
drivers/thermal/msm_thermal-last-working.c-
drivers/thermal/msm_thermal-last-working.c-
drivers/thermal/msm_thermal-last-working.c-}
drivers/thermal/msm_thermal-last-working.c-}
drivers/thermal/msm_thermal-last-working.c-};
drivers/thermal/msm_thermal-last-working.c-		}
drivers/thermal/msm_thermal-last-working.c-bool core_control_enabled;
drivers/thermal/msm_thermal-last-working.c-		break;
drivers/thermal/msm_thermal-last-working.c:	cancel_delayed_work_sync(&check_temp_work);
drivers/thermal/msm_thermal-last-working.c-	case PM_SUSPEND_PREPARE:
drivers/thermal/msm_thermal-last-working.c-					   &check_temp_work, 0);
drivers/thermal/msm_thermal-last-working.c-	destroy_workqueue(intellithermal_wq);
drivers/thermal/msm_thermal-last-working.c-	if (likely(enabled))
drivers/thermal/msm_thermal-last-working.c-			INIT_DELAYED_WORK(&check_temp_work, check_temp);
drivers/thermal/msm_thermal-last-working.c-			intellithermal_wq = create_hipri_workqueue("intellithermal");
drivers/thermal/msm_thermal-last-working.c:		mod_delayed_work_on(0, intellithermal_wq, &check_temp_work,
drivers/thermal/msm_thermal-last-working.c:		mod_delayed_work_on(0, intellithermal_wq, &check_temp_work, 0);
drivers/thermal/msm_thermal-last-working.c-				msecs_to_jiffies(msm_thermal_info.poll_ms));
drivers/thermal/msm_thermal-last-working.c-			mutex_unlock(&core_control_mutex);
drivers/thermal/msm_thermal-last-working.c-			pr_debug("msm_thermal: rescheduling...\n");
drivers/thermal/msm_thermal-last-working.c:			queue_delayed_work_on(0, intellithermal_wq,
drivers/thermal/msm_thermal-last-working.c:	queue_delayed_work_on(0, intellithermal_wq, &check_temp_work, 0);
drivers/thermal/msm_thermal-last-working.c-		register_cpu_notifier(&msm_thermal_cpu_notifier);
drivers/thermal/msm_thermal-last-working.c-	register_pm_notifier(&msm_thermal_pm_notifier);
drivers/thermal/msm_thermal-last-working.c-			return;
drivers/thermal/msm_thermal-last-working.c-	return 0;
drivers/thermal/msm_thermal-last-working.c:static struct delayed_work check_temp_work;
drivers/thermal/msm_thermal-last-working.c-static struct workqueue_struct *intellithermal_wq;
drivers/thermal/msm_thermal_wip.c-
drivers/thermal/msm_thermal_wip.c-
drivers/thermal/msm_thermal_wip.c-
drivers/thermal/msm_thermal_wip.c-
drivers/thermal/msm_thermal_wip.c-}
drivers/thermal/msm_thermal_wip.c-}
drivers/thermal/msm_thermal_wip.c-};
drivers/thermal/msm_thermal_wip.c-		}
drivers/thermal/msm_thermal_wip.c-		break;
drivers/thermal/msm_thermal_wip.c:	cancel_delayed_work_sync(&check_temp_work);
drivers/thermal/msm_thermal_wip.c-	case PM_SUSPEND_PREPARE:
drivers/thermal/msm_thermal_wip.c-					   &check_temp_work, 0);
drivers/thermal/msm_thermal_wip.c-	destroy_workqueue(intellithermal_wq);
drivers/thermal/msm_thermal_wip.c-	if (likely(enabled))
drivers/thermal/msm_thermal_wip.c-			INIT_DELAYED_WORK(&check_temp_work, check_temp);
drivers/thermal/msm_thermal_wip.c-			intellithermal_wq = create_hipri_workqueue("intellithermal");
drivers/thermal/msm_thermal_wip.c:		mod_delayed_work_on(0, intellithermal_wq, &check_temp_work,
drivers/thermal/msm_thermal_wip.c:		mod_delayed_work_on(0, intellithermal_wq, &check_temp_work, 0);
drivers/thermal/msm_thermal_wip.c-				msecs_to_jiffies(msm_thermal_info.poll_ms));
drivers/thermal/msm_thermal_wip.c-			mutex_unlock(&core_control_mutex);
drivers/thermal/msm_thermal_wip.c-			pr_debug("msm_thermal: rescheduling...\n");
drivers/thermal/msm_thermal_wip.c:			queue_delayed_work_on(0, intellithermal_wq,
drivers/thermal/msm_thermal_wip.c:	queue_delayed_work_on(0, intellithermal_wq, &check_temp_work, 0);
drivers/thermal/msm_thermal_wip.c-		register_cpu_notifier(&msm_thermal_cpu_notifier);
drivers/thermal/msm_thermal_wip.c-	register_pm_notifier(&msm_thermal_pm_notifier);
drivers/thermal/msm_thermal_wip.c-	return 0;
drivers/thermal/msm_thermal_wip.c-static bool core_control_enabled;
drivers/thermal/msm_thermal_wip.c:static struct delayed_work check_temp_work;
drivers/thermal/msm_thermal_wip.c-static struct workqueue_struct *intellithermal_wq;
drivers/thermal/msm_thermal_wip.c-	struct msm_thermal_pcpu *lcpu;
drivers/thermal/pm8xxx-tm.c-
drivers/thermal/pm8xxx-tm.c-
drivers/thermal/pm8xxx-tm.c-{
drivers/thermal/pm8xxx-tm.c:	cancel_delayed_work_sync(&chip->irq_work);
drivers/thermal/pm8xxx-tm.c:		cancel_delayed_work_sync(&chip->irq_work);
drivers/thermal/pm8xxx-tm.c-		= container_of(dwork, struct pm8xxx_tm_chip, irq_work);
drivers/thermal/pm8xxx-tm.c:		= container_of(work, struct delayed_work, work);
drivers/thermal/pm8xxx-tm.c-err_cancel_work:
drivers/thermal/pm8xxx-tm.c-err_free_tz:
drivers/thermal/pm8xxx-tm.c-		free_irq(chip->overtemp_irq, chip);
drivers/thermal/pm8xxx-tm.c-		free_irq(chip->tempstat_irq, chip);
drivers/thermal/pm8xxx-tm.c-	free_irq(chip->tempstat_irq, chip);
drivers/thermal/pm8xxx-tm.c-	if (chip) {
drivers/thermal/pm8xxx-tm.c-		msecs_to_jiffies(STATUS_REGISTER_DELAY_MS) + 1);
drivers/thermal/pm8xxx-tm.c-		platform_set_drvdata(pdev, NULL);
drivers/thermal/pm8xxx-tm.c:	schedule_delayed_work(&chip->irq_work,
drivers/thermal/pm8xxx-tm.c-static void pm8xxx_tm_work(struct work_struct *work)
drivers/thermal/pm8xxx-tm.c:	struct delayed_work *dwork
drivers/thermal/pm8xxx-tm.c:	struct delayed_work		irq_work;
drivers/thermal/pm8xxx-tm.c-	struct device			*dev;
drivers/thermal/pm8xxx-tm.c-struct pm8xxx_tm_chip {
drivers/thermal/pm8xxx-tm.c-	struct pm8xxx_tm_chip *chip
drivers/thermal/pm8xxx-tm.c-	struct pm8xxx_tm_chip *chip = data;
drivers/thermal/pm8xxx-tm.c-	struct pm8xxx_tm_core_data	cdata;
drivers/thermal/pm8xxx-tm.c-	struct thermal_zone_device	*tz_dev;
drivers/thermal/pm8xxx-tm.c-	thermal_zone_device_unregister(chip->tz_dev);
drivers/thermal/thermal_core.c-
drivers/thermal/thermal_core.c-{
drivers/thermal/thermal_core.c-}
drivers/thermal/thermal_core.c:		cancel_delayed_work(&tz->poll_queue);
drivers/thermal/thermal_core.c-	else
drivers/thermal/thermal_core.c-	else if (delay)
drivers/thermal/thermal_core.c-	if (delay > 1000)
drivers/thermal/thermal_core.c:		mod_delayed_work(system_freezable_wq, &tz->poll_queue,
drivers/thermal/thermal_core.c:		mod_delayed_work(system_freezable_wq, &tz->poll_queue,
drivers/thermal/thermal_core.c-				 msecs_to_jiffies(delay));
drivers/thermal/thermal_core.c-				 round_jiffies(msecs_to_jiffies(delay)));
drivers/tty/hvc/hvc_iucv.c-
drivers/tty/hvc/hvc_iucv.c-
drivers/tty/hvc/hvc_iucv.c-
drivers/tty/hvc/hvc_iucv.c-
drivers/tty/hvc/hvc_iucv.c-
drivers/tty/hvc/hvc_iucv.c-
drivers/tty/hvc/hvc_iucv.c:	cancel_delayed_work_sync(&priv->sndbuf_work);
drivers/tty/hvc/hvc_iucv.c-#define QUEUE_SNDBUF_DELAY	(HZ / 25)
drivers/tty/hvc/hvc_iucv.c-	/* flush buffered output data... */
drivers/tty/hvc/hvc_iucv.c-	if (priv->iucv_state == IUCV_CONNECTED)
drivers/tty/hvc/hvc_iucv.c-	int sync_wait;
drivers/tty/hvc/hvc_iucv.c-out_path_handled:
drivers/tty/hvc/hvc_iucv.c-	return len;
drivers/tty/hvc/hvc_iucv.c:	schedule_delayed_work(&priv->sndbuf_work, 5);
drivers/tty/hvc/hvc_iucv.c:		schedule_delayed_work(&priv->sndbuf_work, QUEUE_SNDBUF_DELAY);
drivers/tty/hvc/hvc_iucv.c-	size_t			sndbuf_len;	/* length of send buffer  */
drivers/tty/hvc/hvc_iucv.c-	spin_lock_bh(&priv->lock);
drivers/tty/hvc/hvc_iucv.c:	struct delayed_work	sndbuf_work;	/* work: send iucv msg(s) */
drivers/tty/hvc/hvc_iucv.c-	struct list_head	tty_outqueue;	/* outgoing IUCV messages */
drivers/tty/hvc/hvc_iucv.c-	wait_queue_head_t	sndbuf_waitq;	/* wait for send completion */
drivers/tty/hvc/hvsi.c-
drivers/tty/hvc/hvsi.c-
drivers/tty/hvc/hvsi.c-
drivers/tty/hvc/hvsi.c-
drivers/tty/hvc/hvsi.c-	}
drivers/tty/hvc/hvsi.c-	}
drivers/tty/hvc/hvsi.c-		 */
drivers/tty/hvc/hvsi.c-		 */
drivers/tty/hvc/hvsi.c-		 * again once a second.
drivers/tty/hvc/hvsi.c:	cancel_delayed_work_sync(&hp->writer);
drivers/tty/hvc/hvsi.c-	else {
drivers/tty/hvc/hvsi.c-	flush_work(&hp->handshaker);
drivers/tty/hvc/hvsi.c-		goto out;
drivers/tty/hvc/hvsi.c-	hvsi_push(hp);
drivers/tty/hvc/hvsi.c-#ifdef DEBUG
drivers/tty/hvc/hvsi.c-	if (hp->n_outbuf > 0)
drivers/tty/hvc/hvsi.c-		 * schedule another push attempt.
drivers/tty/hvc/hvsi.c:		schedule_delayed_work(&hp->writer, 10);
drivers/tty/hvc/hvsi.c:		schedule_delayed_work(&hp->writer, 10);
drivers/tty/hvc/hvsi.c:		schedule_delayed_work(&hp->writer, HZ);
drivers/tty/hvc/hvsi.c:	struct delayed_work writer;
drivers/tty/hvc/hvsi.c-struct hvsi_struct {
drivers/tty/hvc/hvsi.c-	struct work_struct handshaker;
drivers/tty/hvc/hvsi.c-	wait_queue_head_t emptyq; /* woken when outbuf is emptied */
drivers/tty/hvc/hvsi.c-	/* 'writer' could still be pending if it didn't see n_outbuf = 0 yet */
drivers/tty/n_smux.c-
drivers/tty/n_smux.c-
drivers/tty/n_smux.c-
drivers/tty/n_smux.c-
drivers/tty/n_smux.c-}
drivers/tty/n_smux.c-}
drivers/tty/n_smux.c-	}
drivers/tty/n_smux.c-	}
drivers/tty/n_smux.c-	}
drivers/tty/n_smux.c-		}
drivers/tty/n_smux.c-		 */
drivers/tty/n_smux.c:		cancel_delayed_work(&smux_wakeup_delayed_work);
drivers/tty/n_smux.c:		cancel_delayed_work(&smux_wakeup_delayed_work);
drivers/tty/n_smux.c-		++ch->rx_retry_queue_cnt;
drivers/tty/n_smux.c-		else
drivers/tty/n_smux.c-	} else if (smux.power_state == SMUX_PWR_TURNING_ON) {
drivers/tty/n_smux.c-					__func__, wakeup_delay / 1000);
drivers/tty/n_smux.c-		if (ch->rx_retry_queue_cnt)
drivers/tty/n_smux.c-		if (ch->rx_retry_queue_cnt)
drivers/tty/n_smux.c-		if (ch->rx_retry_queue_cnt == 1)
drivers/tty/n_smux.c-		if (immediate_retry)
drivers/tty/n_smux.c-	if (smux.power_state != SMUX_PWR_OFF)
drivers/tty/n_smux.c-				msecs_to_jiffies(retry->timeout_in_ms));
drivers/tty/n_smux.c-					msecs_to_jiffies(retry->timeout_in_ms));
drivers/tty/n_smux.c-			msecs_to_jiffies(SMUX_INACTIVITY_TIMEOUT_MS));
drivers/tty/n_smux.c-			msecs_to_jiffies(SMUX_INACTIVITY_TIMEOUT_MS));
drivers/tty/n_smux.c-			msecs_to_jiffies(SMUX_INACTIVITY_TIMEOUT_MS));
drivers/tty/n_smux.c-					msecs_to_jiffies(wakeup_delay / 1000));
drivers/tty/n_smux.c-		/* Purge RX retry queue */
drivers/tty/n_smux.c-		/* Purge RX retry queue */
drivers/tty/n_smux.c:			queue_delayed_work(smux_rx_wq, &ch->rx_retry_work,
drivers/tty/n_smux.c:			queue_delayed_work(smux_rx_wq, &ch->rx_retry_work,
drivers/tty/n_smux.c:			queue_delayed_work(smux_rx_wq, &ch->rx_retry_work, 0);
drivers/tty/n_smux.c:			queue_delayed_work(smux_rx_wq, &ch->rx_retry_work, 0);
drivers/tty/n_smux.c:			queue_delayed_work(smux_rx_wq, &ch->rx_retry_work, 0);
drivers/tty/n_smux.c:			queue_delayed_work(smux_tx_wq,
drivers/tty/n_smux.c:		queue_delayed_work(smux_tx_wq, &smux_delayed_inactivity_work,
drivers/tty/n_smux.c:		queue_delayed_work(smux_tx_wq, &smux_delayed_inactivity_work,
drivers/tty/n_smux.c:		queue_delayed_work(smux_tx_wq, &smux_delayed_inactivity_work,
drivers/tty/n_smux.c-		queue_work(smux_tx_wq, &smux_tx_work);
drivers/tty/n_smux.c-		queue_work(smux_tx_wq, &smux_tx_work);
drivers/tty/n_smux.c-		queue_work(smux_tx_wq, &smux_tx_work);
drivers/tty/n_smux.c-		queue_work(smux_tx_wq, &smux_wakeup_work);
drivers/tty/n_smux.c-	/* reschedule inactivity worker */
drivers/tty/n_smux.c-		smux.power_state = SMUX_PWR_ON;
drivers/tty/n_smux.c-		SMUX_PWR("smux: %s: wakeup aborted\n", __func__);
drivers/tty/n_smux.c-		smux_send_byte(SMUX_WAKEUP_ACK);
drivers/tty/n_smux.c-			"smux: %s: scheduling delayed wakeup in %u ms\n",
drivers/tty/n_smux.c:					&smux_wakeup_delayed_work,
drivers/tty/n_smux.c-		spin_unlock_irqrestore(&ch->state_lock_lhb1, flags);
drivers/tty/n_smux.c-		spin_unlock_irqrestore(&ch->state_lock_lhb1, flags);
drivers/tty/n_smux.c-	spin_unlock_irqrestore(&ch->state_lock_lhb1, flags);
drivers/tty/n_smux.c-		spin_unlock_irqrestore(&smux.tx_lock_lha2, flags);
drivers/tty/n_smux.c:static DECLARE_DELAYED_WORK(smux_wakeup_delayed_work, smux_wakeup_worker);
drivers/tty/n_smux.c-static DECLARE_WORK(smux_wakeup_work, smux_wakeup_worker);
drivers/tty/n_smux.c-static void smux_inactivity_worker(struct work_struct *work);
drivers/tty/n_smux.c-static void smux_rx_worker(struct work_struct *work);
drivers/tty/n_smux.c-		 *    workqueue as new TX wakeup requests
drivers/tty/serial/msm_serial_hs.c-
drivers/tty/serial/msm_serial_hs.c-	}
drivers/tty/serial/msm_serial_hs.c-	}
drivers/tty/serial/msm_serial_hs.c-	bool dma_in_flight;
drivers/tty/serial/msm_serial_hs.c:	cancel_delayed_work_sync(&msm_uport->rx.flip_insert_work);
drivers/tty/serial/msm_serial_hs.c-	else
drivers/tty/serial/msm_serial_hs.c-	flush_workqueue(msm_uport->hsuart_wq);
drivers/tty/serial/msm_serial_hs.c-	if (msm_uport->rx.buffer_pending)
drivers/tty/serial/msm_serial_hs.c-				      msecs_to_jiffies(RETRY_TIMEOUT));
drivers/tty/serial/msm_serial_hs.c-				      , msecs_to_jiffies(RETRY_TIMEOUT));
drivers/tty/serial/msm_serial_hs.c-	msm_hs_write(uport, UARTDM_DMEN_ADDR, data);
drivers/tty/serial/msm_serial_hs.c-	pm_runtime_disable(uport->dev);
drivers/tty/serial/msm_serial_hs.c:		schedule_delayed_work(&msm_uport->rx.flip_insert_work
drivers/tty/serial/msm_serial_hs.c:		schedule_delayed_work(&msm_uport->rx.flip_insert_work,
drivers/tty/serial/msm_serial_hs.c-			       "Stalling\n");
drivers/tty/serial/msm_serial_hs.c:	struct delayed_work flip_insert_work;
drivers/tty/serial/msm_serial_hs.c-	struct dma_pool *pool;
drivers/tty/serial/msm_serial_hs.c-	struct tasklet_struct tlet;
drivers/tty/serial/msm_serial_hs.c-	struct wake_lock wake_lock;
drivers/tty/serial/msm_serial_hs.c-			       "tty buffer exhausted. "
drivers/usb/atm/cxacru.c-
drivers/usb/atm/cxacru.c-
drivers/usb/atm/cxacru.c-
drivers/usb/atm/cxacru.c-}
drivers/usb/atm/cxacru.c:		cancel_delayed_work_sync(&instance->poll_work);
drivers/usb/atm/cxacru.c-	if (is_polling)
drivers/usb/atm/cxacru.c-	if (keep_polling)
drivers/usb/atm/cxacru.c-	int adsl_status;
drivers/usb/atm/cxacru.c-				round_jiffies_relative(POLL_INTERVAL*HZ));
drivers/usb/atm/cxacru.c:		schedule_delayed_work(&instance->poll_work,
drivers/usb/atm/cxacru.c:	struct delayed_work poll_work;
drivers/usb/atm/cxacru.c-	struct mutex adsl_state_serialize;
drivers/usb/atm/cxacru.c-	struct mutex poll_state_serialize;
drivers/usb/atm/cxacru.c-	u32 card_info[CXINF_MAX];
drivers/usb/atm/cxacru.c-	usb_kill_urb(instance->snd_urb);
drivers/usb/core/driver.c-
drivers/usb/core/driver.c-		msecs_to_jiffies(THOST_REQ_POLL));
drivers/usb/core/driver.c-out:
drivers/usb/core/driver.c-reschedule:
drivers/usb/core/driver.c:	schedule_delayed_work(&bus->hnp_polling,
drivers/usb/core/hub.c-
drivers/usb/core/hub.c-
drivers/usb/core/hub.c-
drivers/usb/core/hub.c-
drivers/usb/core/hub.c-
drivers/usb/core/hub.c-
drivers/usb/core/hub.c-}
drivers/usb/core/hub.c-};
drivers/usb/core/hub.c-	}
drivers/usb/core/hub.c-	}
drivers/usb/core/hub.c-	}
drivers/usb/core/hub.c-	}
drivers/usb/core/hub.c-		}
drivers/usb/core/hub.c-		}
drivers/usb/core/hub.c-		 */
drivers/usb/core/hub.c-				}
drivers/usb/core/hub.c-		 * and the implementation looks like a home-brewed sort of
drivers/usb/core/hub.c:	cancel_delayed_work_sync(&hub->init_work);
drivers/usb/core/hub.c:		cancel_delayed_work_sync(&hub->leds);
drivers/usb/core/hub.c:		cancel_delayed_work_sync(&udev->bus->hnp_polling);
drivers/usb/core/hub.c-		dev_err(hub->intfdev, "activate --> %d\n", status);
drivers/usb/core/hub.c-			device_unlock(hub->intfdev);
drivers/usb/core/hub.c-		else
drivers/usb/core/hub.c-#endif
drivers/usb/core/hub.c-		flush_work(&hub->tt.clear_work);
drivers/usb/core/hub.c-					hub->indicator[port1-1] =
drivers/usb/core/hub.c-			hub->indicator[port1-1] = INDICATOR_GREEN_BLINK;
drivers/usb/core/hub.c-		 * hub's initial power-up delays.  This is pretty awkward
drivers/usb/core/hub.c-	if (changed)
drivers/usb/core/hub.c-#ifdef CONFIG_USB_OTG
drivers/usb/core/hub.c-		if (hub->has_indicators) {
drivers/usb/core/hub.c-	if (hub->has_indicators)
drivers/usb/core/hub.c-	if (hub->has_indicators && blinkenlights)
drivers/usb/core/hub.c-	if (hub->tt.hub)
drivers/usb/core/hub.c-		if (type == HUB_INIT2) {
drivers/usb/core/hub.c-	if (udev->bus->hnp_support && udev->portnum == udev->bus->otg_port) {
drivers/usb/core/hub.c-		if (udev->bus->quick_hnp)
drivers/usb/core/hub.c-						INDICATOR_AMBER_BLINK;
drivers/usb/core/hub.c-			INIT_DELAYED_WORK(&hub->init_work, hub_init_func2);
drivers/usb/core/hub.c-			INIT_DELAYED_WORK(&hub->init_work, hub_init_func3);
drivers/usb/core/hub.c-	int i;
drivers/usb/core/hub.c-	/* khubd and related activity won't re-trigger */
drivers/usb/core/hub.c-					msecs_to_jiffies(delay));
drivers/usb/core/hub.c-					msecs_to_jiffies(delay));
drivers/usb/core/hub.c-				msecs_to_jiffies(OTG_TTST_SUSP));
drivers/usb/core/hub.c-				msecs_to_jiffies(THOST_REQ_POLL));
drivers/usb/core/hub.c-	/* Scan all ports that need attention */
drivers/usb/core/hub.c:			schedule_delayed_work(&hub->init_work,
drivers/usb/core/hub.c:			schedule_delayed_work(&hub->init_work,
drivers/usb/core/hub.c:					schedule_delayed_work (&hub->leds, 0);
drivers/usb/core/hub.c:			schedule_delayed_work (&hub->leds, 0);
drivers/usb/core/hub.c:		schedule_delayed_work(&hub->leds, LED_CYCLE_PERIOD);
drivers/usb/core/hub.c:		schedule_delayed_work(&hub->leds, LED_CYCLE_PERIOD);
drivers/usb/core/hub.c:			schedule_delayed_work(&udev->bus->hnp_polling,
drivers/usb/core/hub.c:			schedule_delayed_work(&udev->bus->hnp_polling,
drivers/usb/core/hub.c:		/* Speed up system boot by using a delayed_work for the
drivers/usb/core/hub.c-				status = -ENOTCONN;	/* Don't retry */
drivers/usb/core/hub.c:	struct delayed_work	init_work;
drivers/usb/core/hub.c:	struct delayed_work	leds;
drivers/usb/core/hub.c-	u8			indicator[USB_MAXCHILDREN];
drivers/usb/core/hub.c-		udev->bus->hnp_support = 0;
drivers/usb/core/hub.c-	unsigned		has_indicators:1;
drivers/usb/core/hub.c-	usb_kill_urb(hub->urb);
drivers/usb/core/hub.c-	void			**port_owners;
drivers/usb/dwc3/dwc3-msm.c-
drivers/usb/dwc3/dwc3-msm.c-
drivers/usb/dwc3/dwc3-msm.c-
drivers/usb/dwc3/dwc3-msm.c-
drivers/usb/dwc3/dwc3-msm.c-}
drivers/usb/dwc3/dwc3-msm.c-}
drivers/usb/dwc3/dwc3-msm.c-	}
drivers/usb/dwc3/dwc3-msm.c-	atomic_t		in_lpm;
drivers/usb/dwc3/dwc3-msm.c-	atomic_t                pm_suspended;
drivers/usb/dwc3/dwc3-msm.c:		cancel_delayed_work_sync(&mdwc->chg_work);
drivers/usb/dwc3/dwc3-msm.c-		charger->chg_type = DWC3_INVALID_CHARGER;
drivers/usb/dwc3/dwc3-msm.c-	charger->chg_type = DWC3_INVALID_CHARGER;
drivers/usb/dwc3/dwc3-msm.c-	enum usb_chg_state	chg_state;
drivers/usb/dwc3/dwc3-msm.c-	if (start == false) {
drivers/usb/dwc3/dwc3-msm.c-		mdwc->chg_state = USB_CHG_STATE_UNDEFINED;
drivers/usb/dwc3/dwc3-msm.c-	mdwc->chg_state = USB_CHG_STATE_UNDEFINED;
drivers/usb/dwc3/dwc3-msm.c:	queue_delayed_work(system_wq, &mdwc->chg_work, 0);
drivers/usb/dwc3/dwc3-msm.c:	queue_delayed_work(system_wq, &mdwc->chg_work, delay);
drivers/usb/dwc3/dwc3-msm.c:	struct delayed_work	chg_work;
drivers/usb/dwc3/dwc3-msm.c:	struct delayed_work	resume_work;
drivers/usb/dwc3/dwc3-msm.c-	struct dwc3_charger	charger;
drivers/usb/dwc3/dwc3-msm.c-	struct usb_phy		*otg_xceiv;
drivers/usb/dwc3/dwc3-msm.c-	struct wake_lock	wlock;
drivers/usb/dwc3/dwc3-msm.c-	u8			dcd_retries;
drivers/usb/gadget/ci13xxx_udc.c-
drivers/usb/gadget/ci13xxx_udc.c-	}
drivers/usb/gadget/ci13xxx_udc.c-		}
drivers/usb/gadget/ci13xxx_udc.c:		schedule_delayed_work(&udc->rw_work, REMOTE_WAKEUP_DELAY);
drivers/usb/gadget/ci13xxx_udc.c-		usb_phy_set_suspend(udc->transceiver, 0);
drivers/usb/gadget/f_accessory.c-
drivers/usb/gadget/f_accessory.c-
drivers/usb/gadget/f_accessory.c-	/* delayed work for handling ACCESSORY_START */
drivers/usb/gadget/f_accessory.c-			dev->start_requested = 1;
drivers/usb/gadget/f_accessory.c-				&dev->start_work, msecs_to_jiffies(10));
drivers/usb/gadget/f_accessory.c-		if (b_request == ACCESSORY_START) {
drivers/usb/gadget/f_accessory.c:			schedule_delayed_work(
drivers/usb/gadget/f_accessory.c:	struct delayed_work start_work;
drivers/usb/gadget/f_accessory.c-			value = 0;
drivers/usb/gadget/f_accessory.c-	/* worker for registering and unregistering hid devices */
drivers/usb/gadget/f_rmnet_sdio.c-
drivers/usb/gadget/f_rmnet_sdio.c-
drivers/usb/gadget/f_rmnet_sdio.c-
drivers/usb/gadget/f_rmnet_sdio.c-
drivers/usb/gadget/f_rmnet_sdio.c-
drivers/usb/gadget/f_rmnet_sdio.c-
drivers/usb/gadget/f_rmnet_sdio.c-	}
drivers/usb/gadget/f_rmnet_sdio.c-	}
drivers/usb/gadget/f_rmnet_sdio.c-	}
drivers/usb/gadget/f_rmnet_sdio.c:	cancel_delayed_work_sync(&dev->sdio_open_work);
drivers/usb/gadget/f_rmnet_sdio.c-#define RMNET_SDIO_CH_OPEN	1
drivers/usb/gadget/f_rmnet_sdio.c-	destroy_workqueue(dev->wq);
drivers/usb/gadget/f_rmnet_sdio.c-	} else {
drivers/usb/gadget/f_rmnet_sdio.c-								function);
drivers/usb/gadget/f_rmnet_sdio.c-	if (!skb) {
drivers/usb/gadget/f_rmnet_sdio.c-		pr_info("%s: dmux_ch open event\n", __func__);
drivers/usb/gadget/f_rmnet_sdio.c:		queue_delayed_work(dev->wq, &dev->sdio_open_work,
drivers/usb/gadget/f_rmnet_sdio.c:		queue_delayed_work(dev->wq, &dev->sdio_open_work, 0);
drivers/usb/gadget/f_rmnet_sdio.c:	queue_delayed_work(dev->wq, &dev->sdio_open_work, 0);
drivers/usb/gadget/f_rmnet_sdio.c-		return;
drivers/usb/gadget/f_rmnet_sdio.c-	return 0;
drivers/usb/gadget/f_rmnet_sdio.c-				RMNET_SDIO_OPEN_RETRY_DELAY);
drivers/usb/gadget/f_rmnet_sdio.c:	struct delayed_work sdio_open_work;
drivers/usb/gadget/f_rmnet_sdio.c-	struct work_struct data_rx_work;
drivers/usb/gadget/f_rmnet_sdio.c-	struct work_struct sdio_close_work;
drivers/usb/gadget/f_rmnet_smd_sdio.c-
drivers/usb/gadget/f_rmnet_smd_sdio.c-
drivers/usb/gadget/f_rmnet_smd_sdio.c-
drivers/usb/gadget/f_rmnet_smd_sdio.c-
drivers/usb/gadget/f_rmnet_smd_sdio.c-	}
drivers/usb/gadget/f_rmnet_smd_sdio.c-		}
drivers/usb/gadget/f_rmnet_smd_sdio.c-	atomic_t sdio_open;
drivers/usb/gadget/f_rmnet_smd_sdio.c:		queue_delayed_work(dev->wq, &sdio_dev->open_work,
drivers/usb/gadget/f_rmnet_smd_sdio.c:	queue_delayed_work(dev->wq, &sdio_dev->open_work, 0);
drivers/usb/gadget/f_rmnet_smd_sdio.c-		retry_cnt++;
drivers/usb/gadget/f_rmnet_smd_sdio.c-		return;
drivers/usb/gadget/f_rmnet_smd_sdio.c-	return 0;
drivers/usb/gadget/f_rmnet_smd_sdio.c-					SDIO_OPEN_RETRY_DELAY);
drivers/usb/gadget/f_rmnet_smd_sdio.c:	struct delayed_work open_work;
drivers/usb/gadget/f_rmnet_smd_sdio.c-	struct work_struct data_rx_work;
drivers/usb/gadget/msm72k_udc.c-
drivers/usb/gadget/msm72k_udc.c-
drivers/usb/gadget/msm72k_udc.c-
drivers/usb/gadget/msm72k_udc.c-
drivers/usb/gadget/msm72k_udc.c-
drivers/usb/gadget/msm72k_udc.c-
drivers/usb/gadget/msm72k_udc.c-
drivers/usb/gadget/msm72k_udc.c-
drivers/usb/gadget/msm72k_udc.c-	}
drivers/usb/gadget/msm72k_udc.c-		atomic_set(&ui->remote_wakeup, 0);
drivers/usb/gadget/msm72k_udc.c-	atomic_t remote_wakeup;
drivers/usb/gadget/msm72k_udc.c-	atomic_t self_powered;
drivers/usb/gadget/msm72k_udc.c-	bool proprietary_chg;
drivers/usb/gadget/msm72k_udc.c:					cancel_delayed_work_sync(&ui->chg_det);
drivers/usb/gadget/msm72k_udc.c-				dev_dbg(&ui->pdev->dev,
drivers/usb/gadget/msm72k_udc.c-	if (is_active && !ui->gadget.is_a_peripheral)
drivers/usb/gadget/msm72k_udc.c-	if (temp != USB_CHG_TYPE__WALLCHARGER && temp != USB_CHG_TYPE__SDP
drivers/usb/gadget/msm72k_udc.c-				if (!ui->gadget.is_a_peripheral)
drivers/usb/gadget/msm72k_udc.c-				if (!ui->gadget.is_a_peripheral)
drivers/usb/gadget/msm72k_udc.c-				if (!ui->gadget.is_a_peripheral)
drivers/usb/gadget/msm72k_udc.c-		if (!ui->gadget.is_a_peripheral)
drivers/usb/gadget/msm72k_udc.c-	return 0;
drivers/usb/gadget/msm72k_udc.c:					schedule_delayed_work(
drivers/usb/gadget/msm72k_udc.c:					schedule_delayed_work(
drivers/usb/gadget/msm72k_udc.c:		schedule_delayed_work(&ui->chg_det, USB_CHG_DET_DELAY);
drivers/usb/gadget/msm72k_udc.c:		schedule_delayed_work(&ui->chg_det, USB_CHG_DET_DELAY);
drivers/usb/gadget/msm72k_udc.c:			schedule_delayed_work(&ui->chg_stop, 0);
drivers/usb/gadget/msm72k_udc.c:		schedule_delayed_work(&ui->rw_work, REMOTE_WAKEUP_DELAY);
drivers/usb/gadget/msm72k_udc.c-		spin_unlock_irqrestore(&ui->lock, flags);
drivers/usb/gadget/msm72k_udc.c:	struct delayed_work chg_det;
drivers/usb/gadget/msm72k_udc.c:	struct delayed_work chg_stop;
drivers/usb/gadget/msm72k_udc.c:	struct delayed_work rw_work;
drivers/usb/gadget/msm72k_udc.c-	struct msm_hsusb_gadget_platform_data *pdata;
drivers/usb/gadget/msm72k_udc.c-	struct usb_phy *xceiv;
drivers/usb/gadget/msm72k_udc.c-	struct work_struct phy_status_check;
drivers/usb/gadget/msm72k_udc.c-							&ui->chg_det,
drivers/usb/gadget/msm72k_udc.c-							&ui->chg_det,
drivers/usb/gadget/msm72k_udc.c-		ui->chg_type_retry_cnt++;
drivers/usb/gadget/msm72k_udc.c-					&& !ui->chg_type_retry_cnt) {
drivers/usb/gadget/msm72k_udc.c-	unsigned chg_type_retry_cnt;
drivers/usb/gadget/msm72k_udc.c-							USB_CHG_DET_DELAY);
drivers/usb/gadget/msm72k_udc.c-							USB_CHG_DET_DELAY);
drivers/usb/gadget/msm72k_udc.c-		usb_phy_set_suspend(ui->xceiv, 0);
drivers/usb/gadget/msm72k_udc.c-				/* wait incase chg_detect is running */
drivers/usb/gadget/msm72k_udc.c-		wake_lock(&ui->wlock);
drivers/usb/gadget/msm72k_udc.c-		writel(readl(USB_ENDPTSETUPSTAT), USB_ENDPTSETUPSTAT);
drivers/usb/gadget/u_rmnet_ctrl_smd.c-
drivers/usb/gadget/u_rmnet_ctrl_smd.c-
drivers/usb/gadget/u_rmnet_ctrl_smd.c-
drivers/usb/gadget/u_rmnet_ctrl_smd.c-
drivers/usb/gadget/u_rmnet_ctrl_smd.c-
drivers/usb/gadget/u_rmnet_ctrl_smd.c-
drivers/usb/gadget/u_rmnet_ctrl_smd.c-}
drivers/usb/gadget/u_rmnet_ctrl_smd.c-};
drivers/usb/gadget/u_rmnet_ctrl_smd.c-		} else {
drivers/usb/gadget/u_rmnet_ctrl_smd.c-					__func__, c->name, ret);
drivers/usb/gadget/u_rmnet_ctrl_smd.c-			if (port->port_usb)
drivers/usb/gadget/u_rmnet_ctrl_smd.c-				msecs_to_jiffies(250));
drivers/usb/gadget/u_rmnet_ctrl_smd.c-							&port->connect_w, 0);
drivers/usb/gadget/u_rmnet_ctrl_smd.c-			pr_debug("%s: SMD port not ready - rescheduling:%s err:%d\n",
drivers/usb/gadget/u_rmnet_ctrl_smd.c:				queue_delayed_work(grmnet_ctrl_wq,
drivers/usb/gadget/u_rmnet_ctrl_smd.c:			queue_delayed_work(grmnet_ctrl_wq, &port->connect_w,
drivers/usb/gadget/u_rmnet_ctrl_smd.c:	queue_delayed_work(grmnet_ctrl_wq, &port->connect_w, 0);
drivers/usb/gadget/u_rmnet_ctrl_smd.c:	queue_delayed_work(grmnet_ctrl_wq, &port->disconnect_w, 0);
drivers/usb/gadget/u_rmnet_ctrl_smd.c-	return 0;
drivers/usb/gadget/u_rmnet_ctrl_smd.c-		smd_tiocmset(c->ch, c->cbits_tomodem, ~c->cbits_tomodem);
drivers/usb/gadget/u_rmnet_ctrl_smd.c-			spin_lock_irqsave(&port->port_lock, flags);
drivers/usb/gadget/u_rmnet_ctrl_smd.c-	spinlock_t		port_lock;
drivers/usb/gadget/u_rmnet_ctrl_smd.c-			spin_unlock_irqrestore(&port->port_lock, flags);
drivers/usb/gadget/u_rmnet_ctrl_smd.c-	spin_unlock_irqrestore(&port->port_lock, flags);
drivers/usb/gadget/u_rmnet_ctrl_smd.c:	struct delayed_work	connect_w;
drivers/usb/gadget/u_rmnet_ctrl_smd.c:	struct delayed_work	disconnect_w;
drivers/usb/gadget/u_sdio.c-
drivers/usb/gadget/u_sdio.c-#define SDIO_ACM_CTRL_RI		(1 << 3)
drivers/usb/gadget/u_sdio.c-	int				ctrl_ch_err;
drivers/usb/gadget/u_sdio.c-				&port->sdio_open_work, SDIO_OPEN_DELAY);
drivers/usb/gadget/u_sdio.c-			port->sdio_probe = 1;
drivers/usb/gadget/u_sdio.c:			queue_delayed_work(gsdio_wq,
drivers/usb/gadget/u_sdio.c-			return 0;
drivers/usb/gadget/u_sdio.c-					SDIO_CH_NAME_MAX_LEN)) {
drivers/usb/gadget/u_sdio.c:	struct delayed_work		sdio_open_work;
drivers/usb/gadget/u_sdio.c-	struct sdio_port_info		*sport_info;
drivers/usb/gadget/u_smd.c-
drivers/usb/gadget/u_smd.c-
drivers/usb/gadget/u_smd.c-
drivers/usb/gadget/u_smd.c-
drivers/usb/gadget/u_smd.c-		} else {
drivers/usb/gadget/u_smd.c-					__func__, pi->name, ret);
drivers/usb/gadget/u_smd.c-	gser->out->driver_data = port;
drivers/usb/gadget/u_smd.c-			if (port->port_usb)
drivers/usb/gadget/u_smd.c-					msecs_to_jiffies(0));
drivers/usb/gadget/u_smd.c-				msecs_to_jiffies(250));
drivers/usb/gadget/u_smd.c-			pr_debug("%s: SMD port not ready - rescheduling:%s err:%d\n",
drivers/usb/gadget/u_smd.c:				queue_delayed_work(gsmd_wq, &port->connect_work,
drivers/usb/gadget/u_smd.c:			queue_delayed_work(gsmd_wq, &port->connect_work,
drivers/usb/gadget/u_smd.c:	queue_delayed_work(gsmd_wq, &port->connect_work, msecs_to_jiffies(0));
drivers/usb/gadget/u_smd.c-	return 0;
drivers/usb/gadget/u_smd.c-			spin_lock_irqsave(&port->port_lock, flags);
drivers/usb/gadget/u_smd.c-			spin_unlock_irqrestore(&port->port_lock, flags);
drivers/usb/gadget/u_smd.c:	struct delayed_work	connect_work;
drivers/usb/gadget/u_smd.c-	struct smd_port_info	*pi;
drivers/usb/gadget/u_smd.c-	struct work_struct	disconnect_work;
drivers/usb/host/u132-hcd.c-{
drivers/usb/host/u132-hcd.c-{
drivers/usb/host/u132-hcd.c-{
drivers/usb/host/u132-hcd.c-{
drivers/usb/host/u132-hcd.c-{
drivers/usb/host/u132-hcd.c-{
drivers/usb/host/u132-hcd.c-{
drivers/usb/host/u132-hcd.c-}
drivers/usb/host/u132-hcd.c-}
drivers/usb/host/u132-hcd.c-}
drivers/usb/host/u132-hcd.c-}
drivers/usb/host/u132-hcd.c-}
drivers/usb/host/u132-hcd.c-}
drivers/usb/host/u132-hcd.c-};
drivers/usb/host/u132-hcd.c-};
drivers/usb/host/u132-hcd.c:	} else if (queue_delayed_work(workqueue, &ring->scheduler, 0))
drivers/usb/host/u132-hcd.c:	if (cancel_delayed_work(&endp->scheduler))
drivers/usb/host/u132-hcd.c:	if (cancel_delayed_work(&ring->scheduler))
drivers/usb/host/u132-hcd.c:	if (cancel_delayed_work(&u132->monitor))
drivers/usb/host/u132-hcd.c-	if (delta > 0) {
drivers/usb/host/u132-hcd.c:	if (queue_delayed_work(workqueue, &endp->scheduler, delta))
drivers/usb/host/u132-hcd.c:		if (queue_delayed_work(workqueue, &ring->scheduler, delta))
drivers/usb/host/u132-hcd.c:	if (!queue_delayed_work(workqueue, &u132->monitor, delta))
drivers/usb/host/u132-hcd.c:	if (queue_delayed_work(workqueue, &u132->monitor, delta))
drivers/usb/host/u132-hcd.c-	int flags;
drivers/usb/host/u132-hcd.c-	int num_endpoints;
drivers/usb/host/u132-hcd.c-		kref_get(&endp->kref);
drivers/usb/host/u132-hcd.c-		kref_get(&u132->kref);
drivers/usb/host/u132-hcd.c-		kref_put(&endp->kref, u132_endp_delete);
drivers/usb/host/u132-hcd.c-		kref_put(&u132->kref, u132_hcd_delete);
drivers/usb/host/u132-hcd.c-		kref_put(&u132->kref, u132_hcd_delete);
drivers/usb/host/u132-hcd.c-		kref_put(&u132->kref, u132_hcd_delete);
drivers/usb/host/u132-hcd.c-	kref_put(&u132->kref, u132_hcd_delete);
drivers/usb/host/u132-hcd.c-		return;
drivers/usb/host/u132-hcd.c-			return;
drivers/usb/host/u132-hcd.c-static void u132_endp_cancel_work(struct u132 *u132, struct u132_endp *endp)
drivers/usb/host/u132-hcd.c-static void u132_monitor_cancel_work(struct u132 *u132)
drivers/usb/host/u132-hcd.c-static void u132_monitor_queue_work(struct u132 *u132, unsigned int delta)
drivers/usb/host/u132-hcd.c-static void u132_monitor_requeue_work(struct u132 *u132, unsigned int delta)
drivers/usb/host/u132-hcd.c-static void u132_ring_cancel_work(struct u132 *u132, struct u132_ring *ring)
drivers/usb/host/u132-hcd.c:	struct delayed_work monitor;
drivers/usb/host/u132-hcd.c:	struct delayed_work scheduler;
drivers/usb/host/u132-hcd.c:	struct delayed_work scheduler;
drivers/usb/host/u132-hcd.c-	struct list_head urb_more;
drivers/usb/host/u132-hcd.c-struct u132 {
drivers/usb/host/u132-hcd.c-	struct u132_addr addr[MAX_U132_ADDRS];
drivers/usb/host/u132-hcd.c-	struct u132_endp *curr_endp;
drivers/usb/host/u132-hcd.c-struct u132_ring {
drivers/usb/host/u132-hcd.c-	struct u132 *u132;
drivers/usb/host/u132-hcd.c-	struct urb *urb_list[ENDP_QUEUE_SIZE];
drivers/usb/host/u132-hcd.c-	unsigned int delta)
drivers/usb/host/u132-hcd.c-	unsigned long next_statechange;
drivers/usb/misc/appledisplay.c-
drivers/usb/misc/appledisplay.c-
drivers/usb/misc/appledisplay.c-}
drivers/usb/misc/appledisplay.c-		backlight_device_unregister(pdata->bd);
drivers/usb/misc/appledisplay.c-		break;
drivers/usb/misc/appledisplay.c:		cancel_delayed_work(&pdata->work);
drivers/usb/misc/appledisplay.c-	case ACD_BTN_BRIGHT_DOWN:
drivers/usb/misc/appledisplay.c-	case ACD_BTN_NONE:
drivers/usb/misc/appledisplay.c-	if (pdata) {
drivers/usb/misc/appledisplay.c-	if (pdata->button_pressed)
drivers/usb/misc/appledisplay.c-	int button_pressed;
drivers/usb/misc/appledisplay.c-		pdata->button_pressed = 1;
drivers/usb/misc/appledisplay.c-	/* Poll again in about 125ms if there's still a button pressed */
drivers/usb/misc/appledisplay.c:		queue_delayed_work(wq, &pdata->work, 0);
drivers/usb/misc/appledisplay.c:		schedule_delayed_work(&pdata->work, HZ / 8);
drivers/usb/misc/appledisplay.c-	spinlock_t lock;
drivers/usb/misc/appledisplay.c:	struct delayed_work work;
drivers/usb/misc/appledisplay.c-	u8 *msgdata;			/* control message data buffer */
drivers/usb/misc/appledisplay.c-		usb_free_coherent(pdata->udev, ACD_URB_BUFFER_LEN,
drivers/usb/misc/appledisplay.c-		usb_kill_urb(pdata->urb);
drivers/usb/misc/ftdi-elan.c-{
drivers/usb/misc/ftdi-elan.c-{
drivers/usb/misc/ftdi-elan.c-{
drivers/usb/misc/ftdi-elan.c-{
drivers/usb/misc/ftdi-elan.c-{
drivers/usb/misc/ftdi-elan.c-{
drivers/usb/misc/ftdi-elan.c-{
drivers/usb/misc/ftdi-elan.c-{
drivers/usb/misc/ftdi-elan.c-{
drivers/usb/misc/ftdi-elan.c-}
drivers/usb/misc/ftdi-elan.c-}
drivers/usb/misc/ftdi-elan.c-}
drivers/usb/misc/ftdi-elan.c-}
drivers/usb/misc/ftdi-elan.c-}
drivers/usb/misc/ftdi-elan.c-}
drivers/usb/misc/ftdi-elan.c-}
drivers/usb/misc/ftdi-elan.c-}
drivers/usb/misc/ftdi-elan.c-}
drivers/usb/misc/ftdi-elan.c:        if (cancel_delayed_work(&ftdi->command_work))
drivers/usb/misc/ftdi-elan.c:        if (cancel_delayed_work(&ftdi->respond_work))
drivers/usb/misc/ftdi-elan.c:        if (cancel_delayed_work(&ftdi->status_work))
drivers/usb/misc/ftdi-elan.c:	if (!queue_delayed_work(command_queue, &ftdi->command_work, delta))
drivers/usb/misc/ftdi-elan.c:	if (queue_delayed_work(command_queue, &ftdi->command_work, delta))
drivers/usb/misc/ftdi-elan.c:	if (!queue_delayed_work(respond_queue, &ftdi->respond_work, delta))
drivers/usb/misc/ftdi-elan.c:	if (queue_delayed_work(respond_queue, &ftdi->respond_work, delta))
drivers/usb/misc/ftdi-elan.c:	if (!queue_delayed_work(status_queue, &ftdi->status_work, delta))
drivers/usb/misc/ftdi-elan.c:	if (queue_delayed_work(status_queue, &ftdi->status_work, delta))
drivers/usb/misc/ftdi-elan.c-		kref_get(&ftdi->kref);
drivers/usb/misc/ftdi-elan.c-		kref_get(&ftdi->kref);
drivers/usb/misc/ftdi-elan.c-		kref_get(&ftdi->kref);
drivers/usb/misc/ftdi-elan.c-                kref_put(&ftdi->kref, ftdi_elan_delete);
drivers/usb/misc/ftdi-elan.c-                kref_put(&ftdi->kref, ftdi_elan_delete);
drivers/usb/misc/ftdi-elan.c-                kref_put(&ftdi->kref, ftdi_elan_delete);
drivers/usb/misc/ftdi-elan.c-		kref_put(&ftdi->kref, ftdi_elan_delete);
drivers/usb/misc/ftdi-elan.c-		kref_put(&ftdi->kref, ftdi_elan_delete);
drivers/usb/misc/ftdi-elan.c-		kref_put(&ftdi->kref, ftdi_elan_delete);
drivers/usb/misc/ftdi-elan.c-static void ftdi_command_cancel_work(struct usb_ftdi *ftdi)
drivers/usb/misc/ftdi-elan.c-static void ftdi_command_queue_work(struct usb_ftdi *ftdi, unsigned int delta)
drivers/usb/misc/ftdi-elan.c-static void ftdi_command_requeue_work(struct usb_ftdi *ftdi, unsigned int delta)
drivers/usb/misc/ftdi-elan.c-static void ftdi_respond_queue_work(struct usb_ftdi *ftdi, unsigned int delta)
drivers/usb/misc/ftdi-elan.c-static void ftdi_response_cancel_work(struct usb_ftdi *ftdi)
drivers/usb/misc/ftdi-elan.c-static void ftdi_status_cancel_work(struct usb_ftdi *ftdi)
drivers/usb/misc/ftdi-elan.c-static void ftdi_status_queue_work(struct usb_ftdi *ftdi, unsigned int delta)
drivers/usb/misc/ftdi-elan.c-static void ftdi_status_requeue_work(struct usb_ftdi *ftdi, unsigned int delta)
drivers/usb/misc/ftdi-elan.c:        struct delayed_work command_work;
drivers/usb/misc/ftdi-elan.c:        struct delayed_work respond_work;
drivers/usb/misc/ftdi-elan.c:        struct delayed_work status_work;
drivers/usb/misc/ftdi-elan.c-        struct resource resources[0];
drivers/usb/misc/ftdi-elan.c-        struct u132_platform_data platform_data;
drivers/usb/misc/ftdi-elan.c-        struct usb_class_driver *class;
drivers/usb/misc/ftdi-elan.c-        struct usb_interface *interface;
drivers/usb/misc/ftdi-elan.c-        unsigned int delta)
drivers/usb/otg/ab8500-usb.c-
drivers/usb/otg/ab8500-usb.c-
drivers/usb/otg/ab8500-usb.c-
drivers/usb/otg/ab8500-usb.c-
drivers/usb/otg/ab8500-usb.c-
drivers/usb/otg/ab8500-usb.c-
drivers/usb/otg/ab8500-usb.c-
drivers/usb/otg/ab8500-usb.c-
drivers/usb/otg/ab8500-usb.c-
drivers/usb/otg/ab8500-usb.c-
drivers/usb/otg/ab8500-usb.c-{
drivers/usb/otg/ab8500-usb.c-}
drivers/usb/otg/ab8500-usb.c-	}
drivers/usb/otg/ab8500-usb.c-	}
drivers/usb/otg/ab8500-usb.c-	 */
drivers/usb/otg/ab8500-usb.c-		 */
drivers/usb/otg/ab8500-usb.c-		 */
drivers/usb/otg/ab8500-usb.c-	ab8500_usb_irq_free(ab);
drivers/usb/otg/ab8500-usb.c-	/* all: Disable phy when called from set_host and set_peripheral */
drivers/usb/otg/ab8500-usb.c-	 * all: Updates form set_host and set_peripheral as they are atomic.
drivers/usb/otg/ab8500-usb.c:	cancel_delayed_work_sync(&ab->dwork);
drivers/usb/otg/ab8500-usb.c-	cancel_work_sync(&ab->phy_dis_work);
drivers/usb/otg/ab8500-usb.c:	INIT_DELAYED_WORK(&ab->dwork, ab8500_usb_delayed_work);
drivers/usb/otg/ab8500-usb.c-	int irq_num_link_status;
drivers/usb/otg/ab8500-usb.c-	return IRQ_HANDLED;
drivers/usb/otg/ab8500-usb.c-	return IRQ_HANDLED;
drivers/usb/otg/ab8500-usb.c:		schedule_delayed_work(&ab->dwork, ab->link_status_wait);
drivers/usb/otg/ab8500-usb.c:		schedule_delayed_work(&ab->dwork, ab->link_status_wait);
drivers/usb/otg/ab8500-usb.c:	schedule_delayed_work(&ab->dwork, ab->link_status_wait);
drivers/usb/otg/ab8500-usb.c:	schedule_delayed_work(&ab->dwork, ab->link_status_wait);
drivers/usb/otg/ab8500-usb.c:static void ab8500_usb_delayed_work(struct work_struct *work)
drivers/usb/otg/ab8500-usb.c-	struct ab8500_usb *ab = container_of(work, struct ab8500_usb,
drivers/usb/otg/ab8500-usb.c:	struct delayed_work dwork;
drivers/usb/otg/ab8500-usb.c-	struct work_struct phy_dis_work;
drivers/usb/otg/ab8500-usb.c-	unsigned long link_status_wait;
drivers/usb/otg/ab8500-usb.c-	unsigned vbus_draw;
drivers/usb/otg/ab8500-usb.c-		 * Use same delay to avoid any race condition.
drivers/usb/otg/ab8500-usb.c-		 * Use same delay to avoid any race condition.
drivers/usb/otg/ab8500-usb.c-	/* Wait for link status to become stable. */
drivers/usb/otg/ab8500-usb.c-	/* Wait for link status to become stable. */
drivers/usb/otg/fsl_otg.c-
drivers/usb/otg/fsl_otg.c-		 */
drivers/usb/otg/fsl_otg.c-					100);
drivers/usb/otg/fsl_otg.c:				cancel_delayed_work(&
drivers/usb/otg/fsl_otg.c-	} else {
drivers/usb/otg/fsl_otg.c-			} else {	/* switch to host */
drivers/usb/otg/fsl_otg.c-			if (fsm->id) {	/* switch to gadget */
drivers/usb/otg/fsl_otg.c-		otg_dev->host_working = 1;
drivers/usb/otg/fsl_otg.c-						    otg_event);
drivers/usb/otg/fsl_otg.c-		return 0;
drivers/usb/otg/fsl_otg.c:				schedule_delayed_work(
drivers/usb/otg/fsl_otg.c:		schedule_delayed_work(&otg_dev->otg_event, 100);
drivers/usb/otg/fsl_otg.c-						    ((struct fsl_otg *)dev_id)->
drivers/usb/otg/fsl_otg.c-					&((struct fsl_otg *)dev_id)->otg_event,
drivers/usb/otg/gpio_vbus.c-
drivers/usb/otg/gpio_vbus.c-
drivers/usb/otg/gpio_vbus.c-
drivers/usb/otg/gpio_vbus.c-
drivers/usb/otg/gpio_vbus.c:	cancel_delayed_work_sync(&gpio_vbus->work);
drivers/usb/otg/gpio_vbus.c-	if (otg->gadget)
drivers/usb/otg/gpio_vbus.c-	int gpio = pdata->gpio_vbus;
drivers/usb/otg/gpio_vbus.c-	int			irq;
drivers/usb/otg/gpio_vbus.c-	int			vbus;
drivers/usb/otg/gpio_vbus.c-	int			vbus_draw_enabled;
drivers/usb/otg/gpio_vbus.c-	regulator_put(gpio_vbus->vbus_draw);
drivers/usb/otg/gpio_vbus.c-	return IRQ_HANDLED;
drivers/usb/otg/gpio_vbus.c:		schedule_delayed_work(&gpio_vbus->work, msecs_to_jiffies(100));
drivers/usb/otg/gpio_vbus.c:	struct delayed_work	work;
drivers/usb/otg/gpio_vbus.c-	unsigned		mA;
drivers/usb/otg/msm_otg_8930.c-
drivers/usb/otg/msm_otg_8930.c-
drivers/usb/otg/msm_otg_8930.c-
drivers/usb/otg/msm_otg_8930.c-
drivers/usb/otg/msm_otg_8930.c-
drivers/usb/otg/msm_otg_8930.c-}
drivers/usb/otg/msm_otg_8930.c-}
drivers/usb/otg/msm_otg_8930.c-	}
drivers/usb/otg/msm_otg_8930.c-	}
drivers/usb/otg/msm_otg_8930.c-					}
drivers/usb/otg/msm_otg_8930.c-							(1000 * HZ/1000));
drivers/usb/otg/msm_otg_8930.c-					break;
drivers/usb/otg/msm_otg_8930.c:	cancel_delayed_work_sync(&motg->check_ta_work);
drivers/usb/otg/msm_otg_8930.c:			cancel_delayed_work_sync(&motg->check_ta_work);
drivers/usb/otg/msm_otg_8930.c:	cancel_delayed_work_sync(&motg->chg_work);
drivers/usb/otg/msm_otg_8930.c:			cancel_delayed_work_sync(&motg->chg_work);
drivers/usb/otg/msm_otg_8930.c:	cancel_delayed_work_sync(&motg->pmic_id_status_work);
drivers/usb/otg/msm_otg_8930.c-	cancel_work_sync(&motg->sm_work);
drivers/usb/otg/msm_otg_8930.c-			clear_bit(A_BUS_REQ, &motg->inputs);
drivers/usb/otg/msm_otg_8930.c-			else
drivers/usb/otg/msm_otg_8930.c-#endif
drivers/usb/otg/msm_otg_8930.c-#endif
drivers/usb/otg/msm_otg_8930.c-	if (!aca_id_turned_on)
drivers/usb/otg/msm_otg_8930.c-#ifdef CONFIG_USB_HOST_NOTIFY
drivers/usb/otg/msm_otg_8930.c-			motg->chg_state = USB_CHG_STATE_UNDEFINED;
drivers/usb/otg/msm_otg_8930.c-			motg->chg_type = USB_INVALID_CHARGER;
drivers/usb/otg/msm_otg_8930.c-				msecs_to_jiffies(MSM_PMIC_ID_STATUS_DELAY));
drivers/usb/otg/msm_otg_8930.c-						MSM_CHECK_TA_DELAY);
drivers/usb/otg/msm_otg_8930.c-	msm_otg_debugfs_cleanup();
drivers/usb/otg/msm_otg_8930.c-							OTG_STATE_B_PERIPHERAL;
drivers/usb/otg/msm_otg_8930.c-			pr_debug("chg_work cancel");
drivers/usb/otg/msm_otg_8930.c:	queue_delayed_work(system_wq, &motg->chg_work, delay);
drivers/usb/otg/msm_otg_8930.c:		queue_delayed_work(system_wq, &motg->pmic_id_status_work,
drivers/usb/otg/msm_otg_8930.c-		return;
drivers/usb/otg/msm_otg_8930.c-		/*schedule delayed work for 5msec for ID line state to settle*/
drivers/usb/otg/msm_otg_8930.c:					schedule_delayed_work(&motg->check_ta_work,
drivers/usb/otg/msm_otg_8930.c:	schedule_delayed_work(&motg->check_ta_work, MSM_CHECK_TA_DELAY);
drivers/usb/otg/msm_otg_8930.c:				schedule_delayed_work(&motg->late_power_work,
drivers/usb/otg/msm_otg.c-
drivers/usb/otg/msm_otg.c-
drivers/usb/otg/msm_otg.c-
drivers/usb/otg/msm_otg.c-
drivers/usb/otg/msm_otg.c-
drivers/usb/otg/msm_otg.c-
drivers/usb/otg/msm_otg.c-{
drivers/usb/otg/msm_otg.c-}
drivers/usb/otg/msm_otg.c-}
drivers/usb/otg/msm_otg.c-	}
drivers/usb/otg/msm_otg.c-	}
drivers/usb/otg/msm_otg.c-							(1000 * HZ/1000));
drivers/usb/otg/msm_otg.c:	cancel_delayed_work_sync(&motg->check_ta_work);
drivers/usb/otg/msm_otg.c:			cancel_delayed_work_sync(&motg->check_ta_work);
drivers/usb/otg/msm_otg.c:	cancel_delayed_work_sync(&motg->chg_work);
drivers/usb/otg/msm_otg.c:			cancel_delayed_work_sync(&motg->chg_work);
drivers/usb/otg/msm_otg.c:	cancel_delayed_work_sync(&motg->late_power_work);
drivers/usb/otg/msm_otg.c:	cancel_delayed_work_sync(&motg->pmic_id_status_work);
drivers/usb/otg/msm_otg.c-	cancel_work_sync(&motg->notify_work);
drivers/usb/otg/msm_otg.c-	cancel_work_sync(&motg->sm_work);
drivers/usb/otg/msm_otg.c-			clear_bit(A_BUS_REQ, &motg->inputs);
drivers/usb/otg/msm_otg.c-			else
drivers/usb/otg/msm_otg.c-#endif
drivers/usb/otg/msm_otg.c-#endif
drivers/usb/otg/msm_otg.c-	host_notify_dev_unregister(&motg->ndev);
drivers/usb/otg/msm_otg.c-	if (!aca_id_turned_on)
drivers/usb/otg/msm_otg.c-#ifdef CONFIG_USB_HOST_NOTIFY
drivers/usb/otg/msm_otg.c-			motg->chg_state = USB_CHG_STATE_UNDEFINED;
drivers/usb/otg/msm_otg.c-			motg->chg_type = USB_INVALID_CHARGER;
drivers/usb/otg/msm_otg.c-				msecs_to_jiffies(MSM_PMIC_ID_STATUS_DELAY));
drivers/usb/otg/msm_otg.c-	msm_otg_debugfs_cleanup();
drivers/usb/otg/msm_otg.c-			pr_debug("chg_work cancel");
drivers/usb/otg/msm_otg.c:	queue_delayed_work(system_wq, &motg->chg_work, delay);
drivers/usb/otg/msm_otg.c:		queue_delayed_work(system_wq, &motg->pmic_id_status_work,
drivers/usb/otg/msm_otg.c-		return;
drivers/usb/otg/msm_otg.c-		/*schedule delayed work for 5msec for ID line state to settle*/
drivers/usb/otg/msm_otg.c:	schedule_delayed_work(&motg->check_ta_work, MSM_CHECK_TA_DELAY);
drivers/usb/otg/msm_otg.c:				schedule_delayed_work(&motg->late_power_work,
drivers/usb/otg/msm_otg.c-static void msm_otg_late_power_work(struct work_struct *w)
drivers/usb/otg/msm_otg.c-				struct msm_otg, late_power_work);
drivers/usb/otg/msm_otg.c:	struct msm_otg *motg = container_of((struct delayed_work *)w,
drivers/usb/otg/mv_otg.c-
drivers/usb/otg/mv_otg.c-
drivers/usb/otg/mv_otg.c-
drivers/usb/otg/mv_otg.c-
drivers/usb/otg/mv_otg.c-}
drivers/usb/otg/mv_otg.c-	int old_state;
drivers/usb/otg/mv_otg.c:	mvotg = container_of((struct delayed_work *)work, struct mv_otg, work);
drivers/usb/otg/mv_otg.c:	queue_delayed_work(mvotg->qwork, &mvotg->work, delay);
drivers/usb/otg/mv_otg.c-		return;
drivers/usb/otg/mv_otg.c-run:
drivers/usb/renesas_usbhs/common.c-	 */
drivers/usb/renesas_usbhs/common.c-			      msecs_to_jiffies(delay));
drivers/usb/renesas_usbhs/common.c-	return 0;
drivers/usb/renesas_usbhs/common.c:	schedule_delayed_work(&priv->notify_hotplug_work,
drivers/usb/renesas_usbhs/common.c-	 * use workqueue for usbhs_notify_hotplug
drivers/usb/serial/oti6858.c-
drivers/usb/serial/oti6858.c-
drivers/usb/serial/oti6858.c-
drivers/usb/serial/oti6858.c-
drivers/usb/serial/oti6858.c-		}
drivers/usb/serial/oti6858.c-			}
drivers/usb/serial/oti6858.c-			}
drivers/usb/serial/oti6858.c-				}
drivers/usb/serial/oti6858.c-				}
drivers/usb/serial/oti6858.c:	cancel_delayed_work_sync(&priv->delayed_setup_work);
drivers/usb/serial/oti6858.c:	cancel_delayed_work_sync(&priv->delayed_write_work);
drivers/usb/serial/oti6858.c-	/* cancel scheduled setup */
drivers/usb/serial/oti6858.c-					dbg("%s(): scheduling setup_line()",
drivers/usb/serial/oti6858.c-					dbg("%s(): scheduling setup_line()",
drivers/usb/serial/oti6858.c-		dev_err(&port->dev, "%s(): out of memory!\n", __func__);
drivers/usb/serial/oti6858.c-	} flags;
drivers/usb/serial/oti6858.c-					    __func__);
drivers/usb/serial/oti6858.c-					    __func__);
drivers/usb/serial/oti6858.c-	if (priv->flags.write_urb_in_use) {
drivers/usb/serial/oti6858.c-		if (priv->flags.write_urb_in_use == 0 && count != 0) {
drivers/usb/serial/oti6858.c-		kfree(new_setup);
drivers/usb/serial/oti6858.c-						msecs_to_jiffies(2));
drivers/usb/serial/oti6858.c-						msecs_to_jiffies(2));
drivers/usb/serial/oti6858.c-							msecs_to_jiffies(2));
drivers/usb/serial/oti6858.c-			resubmit = 0;
drivers/usb/serial/oti6858.c-		return;
drivers/usb/serial/oti6858.c-		return;
drivers/usb/serial/oti6858.c-		return;
drivers/usb/serial/oti6858.c:		schedule_delayed_work(&priv->delayed_setup_work,
drivers/usb/serial/oti6858.c:		schedule_delayed_work(&priv->delayed_setup_work,
drivers/usb/serial/oti6858.c:					schedule_delayed_work(&priv->delayed_setup_work, 0);
drivers/usb/serial/oti6858.c:					schedule_delayed_work(&priv->delayed_setup_work, 0);
drivers/usb/serial/oti6858.c:		schedule_delayed_work(&priv->delayed_write_work,
drivers/usb/serial/oti6858.c:			schedule_delayed_work(&priv->delayed_write_work, 0);
drivers/usb/serial/oti6858.c-	/* shutdown our urbs */
drivers/usb/serial/oti6858.c-		spin_lock_irqsave(&priv->lock, flags);
drivers/usb/serial/oti6858.c-		spin_unlock_irqrestore(&priv->lock, flags);
drivers/usb/serial/oti6858.c-	struct {
drivers/usb/serial/oti6858.c:	struct delayed_work delayed_setup_work;
drivers/usb/serial/oti6858.c:	struct delayed_work delayed_write_work;
drivers/usb/serial/oti6858.c-	struct usb_serial_port *port;   /* USB port with which associated */
drivers/usb/serial/oti6858.c-	u8 setup_done;
drivers/usb/serial/oti6858.c-	u8 transient;
drivers/usb/serial/oti6858.c-		u8 write_urb_in_use;
drivers/usb/serial/oti6858.c-		/* we will try again */
drivers/usb/serial/oti6858.c-		/* we will try again */
drivers/usb/storage/usb.c-
drivers/usb/storage/usb.c-
drivers/usb/storage/usb.c-
drivers/usb/storage/usb.c-	}
drivers/usb/storage/usb.c-	 */
drivers/usb/storage/usb.c-	/* Balance autopm calls if scanning was cancelled */
drivers/usb/storage/usb.c:	cancel_delayed_work_sync(&us->scan_dwork);
drivers/usb/storage/usb.c-			delay_use * HZ);
drivers/usb/storage/usb.c-		dev_dbg(dev, "waiting for device to settle before scanning\n");
drivers/usb/storage/usb.c-	if (delay_use > 0)
drivers/usb/storage/usb.c-	 * or wait for the SCSI-scanning routine to stop.
drivers/usb/storage/usb.c:	queue_delayed_work(system_freezable_wq, &us->scan_dwork,
drivers/usb/storage/usb.c-	return 0;
drivers/usb/storage/usb.c-	set_bit(US_FLIDX_SCAN_PENDING, &us->dflags);
drivers/usb/storage/usb.c:	/* Submit the delayed_work for SCSI-device scanning */
drivers/usb/wusbcore/devconnect.c-
drivers/usb/wusbcore/devconnect.c-
drivers/usb/wusbcore/devconnect.c-
drivers/usb/wusbcore/devconnect.c-
drivers/usb/wusbcore/devconnect.c-
drivers/usb/wusbcore/devconnect.c-{
drivers/usb/wusbcore/devconnect.c-}
drivers/usb/wusbcore/devconnect.c:	cancel_delayed_work_sync(&wusbhc->keep_alive_timer);
drivers/usb/wusbcore/devconnect.c-	kfree(wusbhc->wuie_host_info);
drivers/usb/wusbcore/devconnect.c-			   msecs_to_jiffies(wusbhc->trust_timeout / 2));
drivers/usb/wusbcore/devconnect.c-	mutex_unlock(&wusbhc->mutex);
drivers/usb/wusbcore/devconnect.c-	mutex_unlock(&wusbhc->mutex);
drivers/usb/wusbcore/devconnect.c:	queue_delayed_work(wusbd, &wusbhc->keep_alive_timer,
drivers/usb/wusbcore/devconnect.c:	queue_delayed_work(wusbd, &wusbhc->keep_alive_timer,
drivers/usb/wusbcore/devconnect.c-static void wusbhc_keep_alive_run(struct work_struct *ws)
drivers/usb/wusbcore/devconnect.c:	struct delayed_work *dw = to_delayed_work(ws);
drivers/usb/wusbcore/devconnect.c-	struct wusbhc *wusbhc =	container_of(dw, struct wusbhc, keep_alive_timer);
drivers/usb/wusbcore/devconnect.c-	wusbhc_mmcie_rm(wusbhc, &wusbhc->wuie_host_info->hdr);
drivers/usb/wusbcore/devconnect.c-			   (wusbhc->trust_timeout*CONFIG_HZ)/1000/2);
drivers/usb/wusbcore/devconnect.c-	wusbhc->wuie_host_info = hi;
drivers/usb/wusbcore/wusbhc.c:	cancel_delayed_work(&wusbhc->keep_alive_timer);
drivers/usb/wusbcore/wusbhc.c-	/* FIXME: maybe we should check for range validity? */
drivers/usb/wusbcore/wusbhc.c-	flush_workqueue(wusbd);
drivers/usb/wusbcore/wusbhc.c-out:
drivers/usb/wusbcore/wusbhc.c:	queue_delayed_work(wusbd, &wusbhc->keep_alive_timer,
drivers/usb/wusbcore/wusbhc.c-			   (trust_timeout * CONFIG_HZ)/1000/2);
drivers/usb/wusbcore/wusbhc.c-	wusbhc->trust_timeout = trust_timeout;
drivers/uwb/drp.c-
drivers/uwb/drp.c-
drivers/uwb/drp.c-	
drivers/uwb/drp.c-	
drivers/uwb/drp.c-	}
drivers/uwb/drp.c-	bitmap_or(rc->cnflt_alien_bitmap.bm, rc->cnflt_alien_bitmap.bm, mas.bm, UWB_NUM_MAS);
drivers/uwb/drp.c-	kfree(cnflt);
drivers/uwb/drp.c:	queue_delayed_work(rc->rsv_workq, &rc->rsv_alien_bp_work, usecs_to_jiffies(delay_us));
drivers/uwb/drp.c:	queue_delayed_work(rc->rsv_workq, &rc->rsv_alien_bp_work, usecs_to_jiffies(delay_us));
drivers/uwb/drp.c-	/* start the timer */
drivers/uwb/rsv.c-
drivers/uwb/rsv.c-
drivers/uwb/rsv.c-
drivers/uwb/rsv.c-
drivers/uwb/rsv.c-{
drivers/uwb/rsv.c-}
drivers/uwb/rsv.c:	cancel_delayed_work_sync(&rc->rsv_update_work);
drivers/uwb/rsv.c-	flush_workqueue(rc->rsv_workq);
drivers/uwb/rsv.c:	if (!delayed_work_pending(&rc->rsv_update_work)) {
drivers/uwb/rsv.c-		if (rc->set_drp_ie_pending > 0) {
drivers/uwb/rsv.c-	mutex_unlock(&rc->rsvs_mutex);
drivers/uwb/rsv.c:	queue_delayed_work(rc->rsv_workq, &rc->rsv_update_work, usecs_to_jiffies(delay_us));
drivers/uwb/rsv.c-			rc->set_drp_ie_pending++;
drivers/uwb/rsv.c-	spin_lock_bh(&rc->rsvs_lock);
drivers/uwb/rsv.c-	unsigned long delay_us = UWB_MAS_LENGTH_US * UWB_MAS_PER_ZONE;
drivers/video/fb_defio.c-
drivers/video/fb_defio.c-
drivers/video/fb_defio.c-
drivers/video/fb_defio.c-
drivers/video/fb_defio.c-}
drivers/video/fb_defio.c-	BUG_ON(!fbdefio);
drivers/video/fb_defio.c:	cancel_delayed_work_sync(&info->deferred_work);
drivers/video/fb_defio.c:	cancel_delayed_work_sync(&info->deferred_work);
drivers/video/fb_defio.c-	/* clear out the mapping that we setup */
drivers/video/fb_defio.c-	/* come back after delay to process the deferred IO */
drivers/video/fb_defio.c:	err = schedule_delayed_work(&info->deferred_work, 0);
drivers/video/fb_defio.c-	/* Kill off the delayed work */
drivers/video/fb_defio.c-	mutex_lock(&inode->i_mutex);
drivers/video/fb_defio.c-	mutex_unlock(&inode->i_mutex);
drivers/video/fb_defio.c-	return err;
drivers/video/fb_defio.c-	return VM_FAULT_LOCKED;
drivers/video/fb_defio.c-	/* Run it immediately */
drivers/video/fb_defio.c:	schedule_delayed_work(&info->deferred_work, fbdefio->delay);
drivers/video/hyperv_fb.c-
drivers/video/hyperv_fb.c-
drivers/video/hyperv_fb.c-
drivers/video/hyperv_fb.c-
drivers/video/hyperv_fb.c-
drivers/video/hyperv_fb.c-
drivers/video/hyperv_fb.c-}
drivers/video/hyperv_fb.c-}
drivers/video/hyperv_fb.c-	}
drivers/video/hyperv_fb.c-	bool update;
drivers/video/hyperv_fb.c:	cancel_delayed_work_sync(&par->dwork);
drivers/video/hyperv_fb.c:	cancel_delayed_work_sync(&par->dwork);
drivers/video/hyperv_fb.c-error1:
drivers/video/hyperv_fb.c-	framebuffer_release(info);
drivers/video/hyperv_fb.c-	hv_set_drvdata(hdev, NULL);
drivers/video/hyperv_fb.c-		if (par->update)
drivers/video/hyperv_fb.c-	if (par->update)
drivers/video/hyperv_fb.c-		par->update = msg->feature_chg.is_dirt_needed;
drivers/video/hyperv_fb.c:			schedule_delayed_work(&par->dwork, HVFB_UPDATE_DELAY);
drivers/video/hyperv_fb.c:		schedule_delayed_work(&par->dwork, HVFB_UPDATE_DELAY);
drivers/video/hyperv_fb.c:	struct delayed_work dwork;
drivers/video/hyperv_fb.c-	u32 synthvid_version;
drivers/video/hyperv_fb.c-	unregister_framebuffer(info);
drivers/video/hyperv_fb.c-	vmbus_close(hdev->channel);
drivers/video/hyperv_fb.c-	vmbus_close(hdev->channel);
drivers/video/msm/mdp.c-
drivers/video/msm/mdp.c-
drivers/video/msm/mdp.c-
drivers/video/msm/mdp.c-
drivers/video/msm/mdp.c-
drivers/video/msm/mdp.c-{
drivers/video/msm/mdp.c-		 */
drivers/video/msm/mdp.c-			/*
drivers/video/msm/mdp.c-			 */
drivers/video/msm/mdp.c-			 * accept the next job which is same as
drivers/video/msm/mdp.c:	cancel_delayed_work(&mdp_pipe_ctrl_worker);
drivers/video/msm/mdp.c:		cancel_delayed_work(&mdp_pipe_ctrl_worker);
drivers/video/msm/mdp.c-	/* cancel pipe ctrl worker */
drivers/video/msm/mdp.c-			} else {
drivers/video/msm/mdp.c-			 * from the list, it's about to expire and run),
drivers/video/msm/mdp.c-	/* if can't be cancelled... */
drivers/video/msm/mdp.c:		//if (delayed_work_pending(&mdp_pipe_ctrl_worker)) {
drivers/video/msm/mdp.c-			if (mdp_all_blocks_off) {
drivers/video/msm/mdp.c-		if ((mdp_all_blocks_off) && (mdp_current_clk_on)) {
drivers/video/msm/mdp.c-						   &mdp_pipe_ctrl_worker,
drivers/video/msm/mdp.c-						   &mdp_pipe_ctrl_worker,
drivers/video/msm/mdp.c:				mod_delayed_work(mdp_pipe_ctrl_wq,
drivers/video/msm/mdp.c:				mod_delayed_work(mdp_pipe_ctrl_wq,
drivers/video/msm/mdp.c-						   msecs_to_jiffies(mdp_timer_duration));
drivers/video/msm/mdp.c-						   msecs_to_jiffies(mdp_timer_duration));
drivers/video/msm/mdp.c:			 * queue_delayed_work(mdp_timer_duration = 0)
drivers/video/msm/mdp.c-				/* send workqueue to turn off mdp power */
drivers/video/msm/mdp.c-				/* send workqueue to turn off mdp power */
drivers/video/msm/mdp.c-static boolean mdp_suspended = FALSE;
drivers/video/msm/mdp.c:static struct delayed_work mdp_pipe_ctrl_worker;
drivers/video/msm/mdp.c-static struct workqueue_struct *mdp_pipe_ctrl_wq; /* mdp mdp pipe ctrl wq */
drivers/video/msm/mdp.c-			 * stop (which means del_timer can't delete it
drivers/video/msm/mdp.c-			 * try to cancel the current work if it fails to
drivers/video/msm/mdp.c:			 * we have to let it run. queue_delayed_work won't
drivers/video/msm/mdss/mdss_mdp.c-
drivers/video/msm/mdss/mdss_mdp.c-
drivers/video/msm/mdss/mdss_mdp.c-{
drivers/video/msm/mdss/mdss_mdp.c:	cancel_delayed_work(&mdss_res->clk_ctrl_worker);
drivers/video/msm/mdss/mdss_mdp.c:			cancel_delayed_work(&mdss_res->clk_ctrl_worker);
drivers/video/msm/mdss/mdss_mdp.c-	} else {
drivers/video/msm/mdss/mdss_mdp.c-			} else {
drivers/video/msm/mdss/mdss_mdp.c-	flush_workqueue(mdss_res->clk_ctrl_wq);
drivers/video/msm/mdss/mdss_mdp.c-		if (atomic_read(&clk_ref)) {
drivers/video/msm/mdss/mdss_mdp.c:		if (delayed_work_pending(&mdss_res->clk_ctrl_worker))
drivers/video/msm/mdss/mdss_mdp.c-		/* if it's power off send workqueue to turn off clocks */
drivers/video/msm/mdss/mdss_mdp.c-		if (mdss_res->clk_ena && !atomic_read(&clk_ref))
drivers/video/msm/mdss/mdss_mdp.c-					   &mdss_res->clk_ctrl_worker,
drivers/video/msm/mdss/mdss_mdp.c-						   &mdss_res->clk_ctrl_worker,
drivers/video/msm/mdss/mdss_mdp.c-					   mdss_res->timeout);
drivers/video/msm/mdss/mdss_mdp.c-						   mdss_res->timeout);
drivers/video/msm/mdss/mdss_mdp.c-		mutex_lock(&clk_ctrl_lock);
drivers/video/msm/mdss/mdss_mdp.c:			queue_delayed_work(mdss_res->clk_ctrl_wq,
drivers/video/msm/mdss/mdss_mdp.c:				queue_delayed_work(mdss_res->clk_ctrl_wq,
drivers/video/msm/mdss/mdss_mdp.c-				/* send workqueue to turn off mdp power */
drivers/video/msm/mdss/mdss_mdp.c-static void mdss_mdp_suspend_sub(void)
drivers/video/msm/mipi_ql_dsi2lvds.c-
drivers/video/msm/mipi_ql_dsi2lvds.c-
drivers/video/msm/mipi_ql_dsi2lvds.c-
drivers/video/msm/mipi_ql_dsi2lvds.c-
drivers/video/msm/mipi_ql_dsi2lvds.c-#endif
drivers/video/msm/mipi_ql_dsi2lvds.c-#endif
drivers/video/msm/mipi_ql_dsi2lvds.c-#endif
drivers/video/msm/mipi_ql_dsi2lvds.c-#if defined(CONFIG_MACH_LT02_TMO)
drivers/video/msm/mipi_ql_dsi2lvds.c-#if defined(CONFIG_MACH_LT02_TMO)
drivers/video/msm/mipi_ql_dsi2lvds.c:	INIT_DELAYED_WORK(&auto_brightness_delayed_work, delay_auto_brightness_store);
drivers/video/msm/mipi_ql_dsi2lvds.c-int saved_auto_brightness;
drivers/video/msm/mipi_ql_dsi2lvds.c-		pr_info("%s: Invalid argument!!", __func__);
drivers/video/msm/mipi_ql_dsi2lvds.c-	return size;
drivers/video/msm/mipi_ql_dsi2lvds.c:	schedule_delayed_work(&auto_brightness_delayed_work, msecs_to_jiffies(1000));
drivers/video/msm/mipi_ql_dsi2lvds.c:struct delayed_work auto_brightness_delayed_work;
drivers/video/msm/mipi_samsung_esd_refresh-8960.c-
drivers/video/msm/mipi_samsung_esd_refresh-8960.c-
drivers/video/msm/mipi_samsung_esd_refresh-8960.c-}
drivers/video/msm/mipi_samsung_esd_refresh-8960.c-	}
drivers/video/msm/mipi_samsung_esd_refresh-8960.c-	}
drivers/video/msm/mipi_samsung_esd_refresh-8960.c:	cancel_delayed_work(&esd_enable->esd_enable_delay);
drivers/video/msm/mipi_samsung_esd_refresh-8960.c-	esd_enable->esd_ignore = true;
drivers/video/msm/mipi_samsung_esd_refresh-8960.c-	msecs_to_jiffies(500));
drivers/video/msm/mipi_samsung_esd_refresh-8960.c-		return;
drivers/video/msm/mipi_samsung_esd_refresh-8960.c:	schedule_delayed_work(&esd_enable->esd_enable_delay,\
drivers/video/msm/mipi_samsung_esd_refresh.c-
drivers/video/msm/mipi_samsung_esd_refresh.c-	}
drivers/video/msm/mipi_samsung_esd_refresh.c-	}
drivers/video/msm/mipi_samsung_esd_refresh.c:	cancel_delayed_work(&esd_enable->esd_enable_delay);
drivers/video/msm/mipi_samsung_esd_refresh.c-#else
drivers/video/msm/mipi_samsung_esd_refresh.c-#endif
drivers/video/msm/mipi_samsung_esd_refresh.c-	esd_enable->esd_ignore = true;
drivers/video/msm/mipi_samsung_esd_refresh.c-#if defined(CONFIG_FB_MSM_MIPI_NOVATEK_VIDEO_HD_PT_PANEL)
drivers/video/msm/mipi_samsung_esd_refresh.c-	msecs_to_jiffies(100));
drivers/video/msm/mipi_samsung_esd_refresh.c-	msecs_to_jiffies(500));
drivers/video/msm/mipi_samsung_esd_refresh.c-		return;
drivers/video/msm/mipi_samsung_esd_refresh.c:	schedule_delayed_work(&esd_enable->esd_enable_delay,\
drivers/video/msm/mipi_samsung_esd_refresh.c:	schedule_delayed_work(&esd_enable->esd_enable_delay,\
drivers/video/msm/mipi_samsung_oled-8960.c-
drivers/video/msm/mipi_samsung_oled-8960.c-
drivers/video/msm/mipi_samsung_oled-8960.c-
drivers/video/msm/mipi_samsung_oled-8960.c-
drivers/video/msm/mipi_samsung_oled-8960.c-
drivers/video/msm/mipi_samsung_oled-8960.c-
drivers/video/msm/mipi_samsung_oled-8960.c-
drivers/video/msm/mipi_samsung_oled-8960.c:	cancel_delayed_work(&(msd.mpd->esd_work));
drivers/video/msm/mipi_samsung_oled-8960.c:	cancel_delayed_work_sync(&(msd.mpd->esd_work));
drivers/video/msm/mipi_samsung_oled-8960.c-#else
drivers/video/msm/mipi_samsung_oled-8960.c-#endif
drivers/video/msm/mipi_samsung_oled-8960.c-#ifdef READ_REGISTER_ESD
drivers/video/msm/mipi_samsung_oled-8960.c-	if ((id2 == 0xA6) || (id2 == 0xB6)) {
drivers/video/msm/mipi_samsung_oled-8960.c-	if (mfd->resume_state != MIPI_SUSPEND_STATE)
drivers/video/msm/mipi_samsung_oled-8960.c-	mfd->resume_state = MIPI_SUSPEND_STATE;
drivers/video/msm/mipi_samsung_oled-8960.c-				&(msd.mpd->esd_work), ESD_INTERVAL * HZ);
drivers/video/msm/mipi_samsung_oled-8960.c-				&(msd.mpd->esd_work), ESD_INTERVAL * HZ);
drivers/video/msm/mipi_samsung_oled-8960.c-				&(msd.mpd->esd_work), ESD_INTERVAL * HZ);
drivers/video/msm/mipi_samsung_oled-8960.c-		pr_info("%s ESD FUNCTION QUEUED", __func__);
drivers/video/msm/mipi_samsung_oled-8960.c:	queue_delayed_work(msd.mpd->esd_workqueue,
drivers/video/msm/mipi_samsung_oled-8960.c:		queue_delayed_work(msd.mpd->esd_workqueue,
drivers/video/msm/mipi_samsung_oled-8960.c:		queue_delayed_work(msd.mpd->esd_workqueue,
drivers/video/msm/mipi_samsung_oled-8960.c-	wake_lock(&(msd.mpd->esd_wake_lock));
drivers/video/msm/mipi_samsung_oled-8960.c-	wake_lock(&(msd.mpd->esd_wake_lock));
drivers/video/msm/mipi_samsung_oled-8960.c-	wake_unlock(&(msd.mpd->esd_wake_lock));
drivers/video/omap2/displays/panel-taal.c-
drivers/video/omap2/displays/panel-taal.c-
drivers/video/omap2/displays/panel-taal.c-
drivers/video/omap2/displays/panel-taal.c-
drivers/video/omap2/displays/panel-taal.c-
drivers/video/omap2/displays/panel-taal.c-
drivers/video/omap2/displays/panel-taal.c-
drivers/video/omap2/displays/panel-taal.c-
drivers/video/omap2/displays/panel-taal.c-
drivers/video/omap2/displays/panel-taal.c-
drivers/video/omap2/displays/panel-taal.c-
drivers/video/omap2/displays/panel-taal.c-
drivers/video/omap2/displays/panel-taal.c-
drivers/video/omap2/displays/panel-taal.c-
drivers/video/omap2/displays/panel-taal.c-}
drivers/video/omap2/displays/panel-taal.c-}
drivers/video/omap2/displays/panel-taal.c-}
drivers/video/omap2/displays/panel-taal.c-}
drivers/video/omap2/displays/panel-taal.c-		atomic_set(&td->do_update, 1);
drivers/video/omap2/displays/panel-taal.c-	bool cabc_broken;
drivers/video/omap2/displays/panel-taal.c-	bool ulps_enabled;
drivers/video/omap2/displays/panel-taal.c:	cancel_delayed_work(&td->esd_work);
drivers/video/omap2/displays/panel-taal.c:		cancel_delayed_work(&td->te_timeout_work);
drivers/video/omap2/displays/panel-taal.c:	cancel_delayed_work(&td->ulps_work);
drivers/video/omap2/displays/panel-taal.c-	if (old) {
drivers/video/omap2/displays/panel-taal.c-	if (td->esd_interval > 0)
drivers/video/omap2/displays/panel-taal.c-	if (td->te_enabled && panel_data->use_ext_te) {
drivers/video/omap2/displays/panel-taal.c-	if (td->ulps_timeout > 0)
drivers/video/omap2/displays/panel-taal.c-	int channel;
drivers/video/omap2/displays/panel-taal.c-				msecs_to_jiffies(250));
drivers/video/omap2/displays/panel-taal.c-				msecs_to_jiffies(td->esd_interval));
drivers/video/omap2/displays/panel-taal.c-				msecs_to_jiffies(td->ulps_timeout));
drivers/video/omap2/displays/panel-taal.c:		queue_delayed_work(td->workqueue, &td->esd_work,
drivers/video/omap2/displays/panel-taal.c:		queue_delayed_work(td->workqueue, &td->ulps_work,
drivers/video/omap2/displays/panel-taal.c-		r = omap_dsi_update(dssdev, td->channel, taal_framedone_cb,
drivers/video/omap2/displays/panel-taal.c:		schedule_delayed_work(&td->te_timeout_work,
drivers/video/omap2/displays/panel-taal.c:	struct delayed_work esd_work;
drivers/video/omap2/displays/panel-taal.c:	struct delayed_work te_timeout_work;
drivers/video/omap2/displays/panel-taal.c:	struct delayed_work ulps_work;
drivers/video/omap2/displays/panel-taal.c-	struct panel_config *panel_config;
drivers/video/omap2/displays/panel-taal.c-	struct taal_data *td = dev_get_drvdata(&dssdev->dev);
drivers/video/omap2/displays/panel-taal.c-	struct taal_data *td = dev_get_drvdata(&dssdev->dev);
drivers/video/omap2/displays/panel-taal.c-	struct workqueue_struct *workqueue;
drivers/video/omap2/displays/panel-taal.c-	unsigned esd_interval;
drivers/video/omap2/displays/panel-taal.c-	unsigned ulps_timeout;
drivers/video/omap2/dss/dsi.c-
drivers/video/omap2/dss/dsi.c-
drivers/video/omap2/dss/dsi.c-
drivers/video/omap2/dss/dsi.c-
drivers/video/omap2/dss/dsi.c-
drivers/video/omap2/dss/dsi.c-	 */
drivers/video/omap2/dss/dsi.c-	BUG_ON(r == 0);
drivers/video/omap2/dss/dsi.c:	cancel_delayed_work(&dsi->framedone_timeout_work);
drivers/video/omap2/dss/dsi.c-	dsi_handle_framedone(dsidev, 0);
drivers/video/omap2/dss/dsi.c-	dsi_perf_mark_start(dsidev);
drivers/video/omap2/dss/dsi.c-#ifdef DSI_CATCH_MISSING_TE
drivers/video/omap2/dss/dsi.c-		msecs_to_jiffies(250));
drivers/video/omap2/dss/dsi.c:	r = schedule_delayed_work(&dsi->framedone_timeout_work,
drivers/video/omap2/dss/dsi.c:	struct delayed_work framedone_timeout_work;
drivers/video/omap2/dss/dsi.c-	void *framedone_data;
drivers/video/omap2/omapfb/omapfb-main.c-
drivers/video/omap2/omapfb/omapfb-main.c-
drivers/video/omap2/omapfb/omapfb-main.c-}
drivers/video/omap2/omapfb/omapfb-main.c:	cancel_delayed_work_sync(&d->auto_update_work);
drivers/video/omap2/omapfb/omapfb-main.c-	d->auto_update_work_enabled = false;
drivers/video/omap2/omapfb/omapfb-main.c-			&d->auto_update_work, HZ / freq);
drivers/video/omap2/omapfb/omapfb-main.c-	d = get_display_data(fbdev, display);
drivers/video/omap2/omapfb/omapfb-main.c-		freq = 20;
drivers/video/omap2/omapfb/omapfb-main.c-	if (freq == 0)
drivers/video/omap2/omapfb/omapfb-main.c:	queue_delayed_work(fbdev->auto_update_wq,
drivers/video/omap/lcd_mipid.c-
drivers/video/omap/lcd_mipid.c-
drivers/video/omap/lcd_mipid.c-{
drivers/video/omap/lcd_mipid.c-{
drivers/video/omap/lcd_mipid.c-}
drivers/video/omap/lcd_mipid.c-}
drivers/video/omap/lcd_mipid.c-};
drivers/video/omap/lcd_mipid.c:		cancel_delayed_work_sync(&md->esd_work);
drivers/video/omap/lcd_mipid.c-	if (md->esd_check != NULL)
drivers/video/omap/lcd_mipid.c-	if (md->esd_check != NULL)
drivers/video/omap/lcd_mipid.c-				   MIPID_ESD_CHECK_PERIOD);
drivers/video/omap/lcd_mipid.c:		queue_delayed_work(md->esd_wq, &md->esd_work,
drivers/video/omap/lcd_mipid.c:	struct delayed_work	esd_work;
drivers/video/omap/lcd_mipid.c-	struct workqueue_struct	*esd_wq;
drivers/video/omap/lcd_mipid.c-	void			(*esd_check)(struct mipid_device *m);
drivers/video/sh_mobile_hdmi.c-
drivers/video/sh_mobile_hdmi.c-	}
drivers/video/sh_mobile_hdmi.c-			}
drivers/video/sh_mobile_hdmi.c:	cancel_delayed_work_sync(&hdmi->edid_work);
drivers/video/sh_mobile_hdmi.c-		/* Disable EDID interrupt */
drivers/video/sh_mobile_hdmi.c-			/* display_off will switch back to mode_a */
drivers/video/sh_mobile_hdmi.c-	free_irq(irq, hdmi);
drivers/video/sh_mobile_hdmi.c-				hdmi->hp_state = HDMI_HOTPLUG_DISCONNECTED;
drivers/video/sh_mobile_hdmi.c-		hdmi_write(hdmi, 0xC0, HDMI_INTERRUPT_MASK_1);
drivers/video/sh_mobile_hdmi.c-			if (hdmi->hp_state != HDMI_HOTPLUG_DISCONNECTED) {
drivers/video/sh_mobile_hdmi.c-	pm_runtime_disable(&pdev->dev);
drivers/video/sh_mobile_hdmi.c-	pm_runtime_put(&pdev->dev);
drivers/video/sh_mobile_hdmi.c:				schedule_delayed_work(&hdmi->edid_work, 0);
drivers/video/sh_mobile_hdmi.c:		schedule_delayed_work(&hdmi->edid_work, msecs_to_jiffies(10));
drivers/video/sh_mobile_hdmi.c-	struct clk *hdmi_clk;
drivers/video/sh_mobile_hdmi.c:	struct delayed_work edid_work;
drivers/video/sh_mobile_hdmi.c-	struct device *dev;
drivers/video/sh_mobile_hdmi.c-	struct fb_monspecs monspec;
drivers/video/sh_mobile_hdmi.c-	struct fb_videomode mode;
drivers/video/sh_mobile_hdmi.c-	/* Wait for already scheduled work */
drivers/video/sh_mobile_lcdcfb.c-
drivers/video/sh_mobile_lcdcfb.c-
drivers/video/sh_mobile_lcdcfb.c-}
drivers/video/sh_mobile_lcdcfb.c-			ch->frame_end = 0;
drivers/video/sh_mobile_lcdcfb.c-			fb_deferred_io_cleanup(ch->info);
drivers/video/sh_mobile_lcdcfb.c-		if (ch->info && ch->info->fbdefio) {
drivers/video/sh_mobile_lcdcfb.c-	if (fbdefio)
drivers/video/sh_mobile_lcdcfb.c:			schedule_delayed_work(&ch->info->deferred_work, 0);
drivers/video/sh_mobile_lcdcfb.c:		schedule_delayed_work(&info->deferred_work, fbdefio->delay);
drivers/video/sh_mobile_lcdcfb.c-			wait_event(ch->frame_end_wait, ch->frame_end);
drivers/video/smscufx.c-
drivers/video/smscufx.c-
drivers/video/smscufx.c-};
drivers/video/smscufx.c-	atomic_t lost_pixels; /* 1 = a render op failed. Need screen refresh */
drivers/video/smscufx.c-	atomic_t usb_active; /* 0 = update virtual buffer, but no usb traffic */
drivers/video/smscufx.c-	bool virtualized; /* true when physical usb device not present */
drivers/video/smscufx.c-	else
drivers/video/smscufx.c-	/* if clients still have us open, will be freed on last close */
drivers/video/smscufx.c-	if (dev->fb_count == 0)
drivers/video/smscufx.c-	if ((dev->fb_count == 0) && (info->fbdefio)) {
drivers/video/smscufx.c-	if (dev->virtualized && (dev->fb_count == 0))
drivers/video/smscufx.c-	if (fb_defio)
drivers/video/smscufx.c-	int fb_count;
drivers/video/smscufx.c-	/* release reference taken by kref_init in probe() */
drivers/video/smscufx.c:		schedule_delayed_work(&dev->free_framebuffer_work, 0);
drivers/video/smscufx.c:		schedule_delayed_work(&dev->free_framebuffer_work, HZ);
drivers/video/smscufx.c:		schedule_delayed_work(&unode->release_urb_work, 0);
drivers/video/smscufx.c:	struct delayed_work free_framebuffer_work;
drivers/video/smscufx.c:	struct delayed_work release_urb_work;
drivers/video/smscufx.c-	struct list_head entry;
drivers/video/smscufx.c-	struct ufx_data *dev;
drivers/video/smscufx.c-	struct urb *urb;
drivers/video/smscufx.c-		up(&dev->urbs.limit_sem);
drivers/video/smscufx.c-	/* We can't free fb_info here - fbmem will touch it when we return */
drivers/video/smscufx.c-	 * while another is waiting. So queue to another process */
drivers/video/udlfb.c-
drivers/video/udlfb.c-
drivers/video/udlfb.c-
drivers/video/udlfb.c-	 */
drivers/video/udlfb.c-			  dlfb_init_framebuffer_work);
drivers/video/udlfb.c-	else
drivers/video/udlfb.c-	/* if clients still have us open, will be freed on last close */
drivers/video/udlfb.c-	if (dev->fb_count == 0)
drivers/video/udlfb.c-	if ((dev->fb_count == 0) && (info->fbdefio)) {
drivers/video/udlfb.c-	if (dev->virtualized && (dev->fb_count == 0))
drivers/video/udlfb.c-	if (fb_defio)
drivers/video/udlfb.c-	INIT_DELAYED_WORK(&dev->init_framebuffer_work,
drivers/video/udlfb.c-	/* release reference taken by kref_init in probe() */
drivers/video/udlfb.c-	return 0;
drivers/video/udlfb.c:		schedule_delayed_work(&dev->free_framebuffer_work, 0);
drivers/video/udlfb.c:		schedule_delayed_work(&dev->free_framebuffer_work, HZ);
drivers/video/udlfb.c:	schedule_delayed_work(&dev->init_framebuffer_work, 0);
drivers/video/udlfb.c:		schedule_delayed_work(&unode->release_urb_work, 0);
drivers/video/udlfb.c-		up(&dev->urbs.limit_sem);
drivers/video/udlfb.c-	/* We can't free fb_info here - fbmem will touch it when we return */
drivers/xen/balloon.c-
drivers/xen/balloon.c-
drivers/xen/balloon.c-
drivers/xen/balloon.c-{
drivers/xen/balloon.c-}
drivers/xen/balloon.c-		balloon_append(pages[--pgno]);
drivers/xen/balloon.c-	balloon_stats.target_pages = target;
drivers/xen/balloon.c-EXPORT_SYMBOL_GPL(balloon_set_new_target);
drivers/xen/balloon.c-	/* Free the memory back to the kernel soon */
drivers/xen/balloon.c-	if (current_credit())
drivers/xen/balloon.c-	if (state == BP_EAGAIN)
drivers/xen/balloon.c-	if (val == MEM_ONLINE)
drivers/xen/balloon.c-	mutex_unlock(&balloon_mutex);
drivers/xen/balloon.c-	mutex_unlock(&balloon_mutex);
drivers/xen/balloon.c-	mutex_unlock(&balloon_mutex);
drivers/xen/balloon.c-	/* No need for lock. Not read-modify-write updates. */
drivers/xen/balloon.c-	return -ENOMEM;
drivers/xen/balloon.c-	return NOTIFY_OK;
drivers/xen/balloon.c:		schedule_delayed_work(&balloon_worker, 0);
drivers/xen/balloon.c:		schedule_delayed_work(&balloon_worker, 0);
drivers/xen/balloon.c:	schedule_delayed_work(&balloon_worker, 0);
drivers/xen/balloon.c:	schedule_delayed_work(&balloon_worker, 0);
drivers/xen/balloon.c:		schedule_delayed_work(&balloon_worker, balloon_stats.schedule_delay * HZ);
drivers/xen/balloon.c-	/* Schedule more work if there is some still to be done. */
drivers/xen/balloon.c-	/* The balloon may be too large now. Shrink it if needed. */
drivers/xen/xen-selfballoon.c-
drivers/xen/xen-selfballoon.c-
drivers/xen/xen-selfballoon.c-
drivers/xen/xen-selfballoon.c-
drivers/xen/xen-selfballoon.c-}
drivers/xen/xen-selfballoon.c-#endif
drivers/xen/xen-selfballoon.c-	     frontswap_selfshrinking)
drivers/xen/xen-selfballoon.c-	if (reset_timer)
drivers/xen/xen-selfballoon.c-	if (!was_enabled && xen_selfballooning_enabled)
drivers/xen/xen-selfballoon.c-	if (!was_enabled && !xen_selfballooning_enabled &&
drivers/xen/xen-selfballoon.c-	return 0;
drivers/xen/xen-selfballoon.c-		return -ENODEV;
drivers/xen/xen-selfballoon.c:		schedule_delayed_work(&selfballoon_worker,
drivers/xen/xen-selfballoon.c:		schedule_delayed_work(&selfballoon_worker,
drivers/xen/xen-selfballoon.c:		schedule_delayed_work(&selfballoon_worker,
drivers/xen/xen-selfballoon.c:	schedule_delayed_work(&selfballoon_worker, selfballoon_interval * HZ);
drivers/xen/xen-selfballoon.c-			selfballoon_interval * HZ);
drivers/xen/xen-selfballoon.c-			selfballoon_interval * HZ);
drivers/xen/xen-selfballoon.c-			selfballoon_interval * HZ);
drivers/xen/xen-selfballoon.c-	xen_selfballooning_enabled = !!tmp;
fs/affs/super.c-
fs/affs/super.c-
fs/affs/super.c-
fs/affs/super.c-	}
fs/affs/super.c-	}
fs/affs/super.c-	affs_free_bitmap(sb);
fs/affs/super.c:	cancel_delayed_work_sync(&sbi->sb_work);
fs/affs/super.c-	       delay = msecs_to_jiffies(dirty_writeback_interval * 10);
fs/affs/super.c:	flush_delayed_work_sync(&sbi->sb_work);
fs/affs/super.c-	if (!sbi->work_queued) {
fs/affs/super.c-	kfree(sbi->s_prefix);
fs/affs/super.c-	pr_debug("AFFS: put_super()\n");
fs/affs/super.c:	       queue_delayed_work(system_long_wq, &sbi->sb_work, delay);
fs/affs/super.c-	replace_mount_options(sb, new_opts);
fs/affs/super.c-	       sbi->work_queued = 1;
fs/afs/callback.c-
fs/afs/callback.c-
fs/afs/callback.c-{
fs/afs/callback.c-}
fs/afs/callback.c-			   &afs_vnode_update, timeout * HZ);
fs/afs/callback.c-				   &afs_vnode_update, timeout * HZ);
fs/afs/callback.c-		break;
fs/afs/callback.c-	case 1 ... AFSCBMAX - 1:
fs/afs/callback.c-	_debug("timeout %ld", timeout);
fs/afs/callback.c-	if (timeout > 0) {
fs/afs/callback.c:	mod_delayed_work(afs_callback_update_worker, &server->cb_break_work, 0);
fs/afs/callback.c:		queue_delayed_work(afs_callback_update_worker,
fs/afs/callback.c:	queue_delayed_work(afs_vnode_update_worker,
fs/afs/callback.c:		queue_delayed_work(afs_vnode_update_worker,
fs/afs/callback.c-				   &server->cb_break_work, HZ * 2);
fs/afs/callback.c-	spin_unlock(&server->cb_lock);
fs/afs/callback.c-		spin_unlock(&server->cb_lock);
fs/afs/callback.c-	switch (atomic_inc_return(&server->cb_break_n)) {
fs/afs/callback.c-	timeout = vnode->update_at - now;
fs/afs/callback.c-void afs_flush_callback_breaks(struct afs_server *server)
fs/afs/flock.c-
fs/afs/flock.c-
fs/afs/flock.c-{
fs/afs/flock.c-{
fs/afs/flock.c-}
fs/afs/flock.c-}
fs/afs/flock.c-			   AFS_LOCKWAIT * HZ / 2);
fs/afs/flock.c-			break;
fs/afs/flock.c:	cancel_delayed_work(&vnode->lock_work);
fs/afs/flock.c-	_enter("{%x:%u}", vnode->fid.vid, vnode->fid.vnode);
fs/afs/flock.c-			       " Failed to extend lock on {%x:%x} error %d\n",
fs/afs/flock.c-					   HZ * 10);
fs/afs/flock.c-	if (!test_and_clear_bit(AFS_VNODE_READLOCKED, &vnode->flags) &&
fs/afs/flock.c:			queue_delayed_work(afs_lock_manager, &vnode->lock_work,
fs/afs/flock.c:	queue_delayed_work(afs_lock_manager, &vnode->lock_work,
fs/afs/flock.c:	queue_delayed_work(afs_lock_manager, &vnode->lock_work, 0);
fs/afs/flock.c-static void afs_defer_unlock(struct afs_vnode *vnode, struct key *key)
fs/afs/flock.c-static void afs_schedule_lock_extension(struct afs_vnode *vnode)
fs/afs/flock.c-	    !test_and_clear_bit(AFS_VNODE_WRITELOCKED, &vnode->flags))
fs/afs/flock.c-			       vnode->fid.vid, vnode->fid.vnode, ret);
fs/afs/mntpt.c-
fs/afs/mntpt.c-}
fs/afs/mntpt.c-	}
fs/afs/mntpt.c-			   afs_mntpt_expiry_timeout * HZ);
fs/afs/mntpt.c-				   afs_mntpt_expiry_timeout * HZ);
fs/afs/mntpt.c-	ASSERT(list_empty(&afs_vfsmounts));
fs/afs/mntpt.c:	cancel_delayed_work_sync(&afs_mntpt_expiry_timer);
fs/afs/mntpt.c-	if (!list_empty(&afs_vfsmounts)) {
fs/afs/mntpt.c-	_leave(" = %p", newmnt);
fs/afs/mntpt.c-		mark_mounts_for_expiry(&afs_vfsmounts);
fs/afs/mntpt.c-	mntget(newmnt); /* prevent immediate expiration */
fs/afs/mntpt.c-	mnt_set_expiry(newmnt, &afs_vfsmounts);
fs/afs/mntpt.c:		queue_delayed_work(afs_wq, &afs_mntpt_expiry_timer,
fs/afs/mntpt.c:	queue_delayed_work(afs_wq, &afs_mntpt_expiry_timer,
fs/afs/server.c-
fs/afs/server.c-
fs/afs/server.c-{
fs/afs/server.c-}
fs/afs/server.c-	}
fs/afs/server.c-		}
fs/afs/server.c-	afs_server_timeout = 0;
fs/afs/server.c-				   afs_server_timeout * HZ);
fs/afs/server.c-	ASSERTCMP(server->fs_vnodes.rb_node, ==, NULL);
fs/afs/server.c-	ASSERTIF(server->cb_break_head != server->cb_break_tail,
fs/afs/server.c-			break;
fs/afs/server.c:		 delayed_work_pending(&server->cb_break_work));
fs/afs/server.c-			delay = (expiry - now) * HZ;
fs/afs/server.c-		if (expiry > now) {
fs/afs/server.c-		list_move_tail(&server->grave, &afs_server_graveyard);
fs/afs/server.c:	mod_delayed_work(afs_wq, &afs_server_reaper, 0);
fs/afs/server.c:			mod_delayed_work(afs_wq, &afs_server_reaper, delay);
fs/afs/server.c:		queue_delayed_work(afs_wq, &afs_server_reaper,
fs/afs/server.c-		server->time_of_death = get_seconds();
fs/afs/vlocation.c-
fs/afs/vlocation.c-
fs/afs/vlocation.c-
fs/afs/vlocation.c-
fs/afs/vlocation.c-}
fs/afs/vlocation.c-		}
fs/afs/vlocation.c-				   afs_vlocation_timeout * HZ);
fs/afs/vlocation.c-				   &afs_vlocation_update,
fs/afs/vlocation.c-			   &afs_vlocation_update, timeout * HZ);
fs/afs/vlocation.c-				   &afs_vlocation_update, timeout * HZ);
fs/afs/vlocation.c-				   afs_vlocation_update_timeout * HZ);
fs/afs/vlocation.c-			break;
fs/afs/vlocation.c-			_debug("delay %lu", delay);
fs/afs/vlocation.c-	_debug("timeout %ld", timeout);
fs/afs/vlocation.c-			delay = (expiry - now) * HZ;
fs/afs/vlocation.c-	destroy_workqueue(afs_vlocation_update_worker);
fs/afs/vlocation.c-	} else {
fs/afs/vlocation.c-	if (timeout > 0) {
fs/afs/vlocation.c-	list_del_init(&afs_vlocation_updates);
fs/afs/vlocation.c-		list_move_tail(&vl->grave, &afs_vlocation_graveyard);
fs/afs/vlocation.c:	mod_delayed_work(afs_vlocation_update_worker, &afs_vlocation_update, 0);
fs/afs/vlocation.c:	mod_delayed_work(afs_wq, &afs_vlocation_reap, 0);
fs/afs/vlocation.c:			mod_delayed_work(afs_wq, &afs_vlocation_reap, delay);
fs/afs/vlocation.c:	queue_delayed_work(afs_vlocation_update_worker,
fs/afs/vlocation.c:		queue_delayed_work(afs_vlocation_update_worker,
fs/afs/vlocation.c:		queue_delayed_work(afs_vlocation_update_worker,
fs/afs/vlocation.c:		queue_delayed_work(afs_wq, &afs_vlocation_reap,
fs/afs/vlocation.c-	spin_unlock(&afs_vlocation_updates_lock);
fs/afs/vlocation.c-	spin_unlock(&afs_vlocation_updates_lock);
fs/afs/vlocation.c-		spin_unlock(&afs_vlocation_updates_lock);
fs/afs/vlocation.c-	timeout = vl->update_at - now;
fs/afs/vlocation.c-		vl->time_of_death = get_seconds();
fs/afs/vlocation.c-			vl->update_at = xvl->update_at + 1;
fs/btrfs/transaction.c-
fs/btrfs/transaction.c-
fs/btrfs/transaction.c-
fs/btrfs/transaction.c-};
fs/btrfs/transaction.c-	btrfs_end_transaction(trans, root);
fs/btrfs/transaction.c:	schedule_delayed_work(&ac->work, 0);
fs/btrfs/transaction.c-	struct btrfs_root *root;
fs/btrfs/transaction.c-	struct btrfs_trans_handle *newtrans;
fs/btrfs/transaction.c:	struct delayed_work work;
fs/btrfs/transaction.c-	/* wait for transaction to start and unblock */
fs/ceph/mds_client.c-
fs/ceph/mds_client.c-
fs/ceph/mds_client.c-
fs/ceph/mds_client.c-
fs/ceph/mds_client.c-
fs/ceph/mds_client.c-{
fs/ceph/mds_client.c-{
fs/ceph/mds_client.c-}
fs/ceph/mds_client.c:	cancel_delayed_work_sync(&mdsc->delayed_work); /* cancel timer */
fs/ceph/mds_client.c:	cancel_delayed_work_sync(&mdsc->delayed_work); /* cancel timer */
fs/ceph/mds_client.c-	ceph_check_delayed_caps(mdsc);
fs/ceph/mds_client.c-	ceph_cleanup_empty_realms(mdsc);
fs/ceph/mds_client.c-		ceph_mdsmap_destroy(mdsc->mdsmap);
fs/ceph/mds_client.c:		container_of(work, struct ceph_mds_client, delayed_work.work);
fs/ceph/mds_client.c:	dout("mdsc delayed_work\n");
fs/ceph/mds_client.c-	dout("stop\n");
fs/ceph/mds_client.c-	dout("stopped\n");
fs/ceph/mds_client.c-	if (mdsc->mdsmap)
fs/ceph/mds_client.c:	INIT_DELAYED_WORK(&mdsc->delayed_work, delayed_work);
fs/ceph/mds_client.c-	INIT_LIST_HEAD(&mdsc->cap_delay_list);
fs/ceph/mds_client.c-	int delay = 5;
fs/ceph/mds_client.c-	int i;
fs/ceph/mds_client.c-	int renew_caps;
fs/ceph/mds_client.c-	int renew_interval;
fs/ceph/mds_client.c-	mdsc->last_renew_caps = jiffies;
fs/ceph/mds_client.c-	mdsc->last_tid = 0;
fs/ceph/mds_client.c-	mdsc->request_tree = RB_ROOT;
fs/ceph/mds_client.c:	schedule_delayed_work(&mdsc->delayed_work, hz);
fs/ceph/mds_client.c:static void delayed_work(struct work_struct *work)
fs/ceph/mds_client.c-	struct ceph_mds_client *mdsc =
fs/ceph/mds_client.c-	unsigned hz = round_jiffies_relative(HZ * delay);
fs/cifs/cifs_dfs_ref.c-
fs/cifs/cifs_dfs_ref.c-{
fs/cifs/cifs_dfs_ref.c-}
fs/cifs/cifs_dfs_ref.c-}
fs/cifs/cifs_dfs_ref.c-	BUG_ON(!list_empty(&cifs_dfs_automount_list));
fs/cifs/cifs_dfs_ref.c:	cancel_delayed_work_sync(&cifs_dfs_automount_task);
fs/cifs/cifs_dfs_ref.c-	cFYI(1, "leaving %s [ok]" , __func__);
fs/cifs/cifs_dfs_ref.c-			      cifs_dfs_mountpoint_expiry_timeout);
fs/cifs/cifs_dfs_ref.c-				      cifs_dfs_mountpoint_expiry_timeout);
fs/cifs/cifs_dfs_ref.c-	if (!list_empty(list))
fs/cifs/cifs_dfs_ref.c-	mark_mounts_for_expiry(list);
fs/cifs/cifs_dfs_ref.c-	mntget(newmnt); /* prevent immediate expiration */
fs/cifs/cifs_dfs_ref.c-	mnt_set_expiry(newmnt, &cifs_dfs_automount_list);
fs/cifs/cifs_dfs_ref.c:	schedule_delayed_work(&cifs_dfs_automount_task,
fs/cifs/cifs_dfs_ref.c:		schedule_delayed_work(&cifs_dfs_automount_task,
fs/cifs/connect.c-
fs/cifs/connect.c-
fs/cifs/connect.c-
fs/cifs/connect.c-
fs/cifs/connect.c-
fs/cifs/connect.c-
fs/cifs/connect.c-
fs/cifs/connect.c-
fs/cifs/connect.c-
fs/cifs/connect.c-
fs/cifs/connect.c-
fs/cifs/connect.c-}
fs/cifs/connect.c-}
fs/cifs/connect.c:	cancel_delayed_work_sync(&cifs_sb->prune_tlinks);
fs/cifs/connect.c:	cancel_delayed_work_sync(&server->echo);
fs/cifs/connect.c:	queue_delayed_work(cifsiod_wq, &cifs_sb->prune_tlinks,
fs/cifs/connect.c:	queue_delayed_work(cifsiod_wq, &cifs_sb->prune_tlinks,
fs/cifs/connect.c:	queue_delayed_work(cifsiod_wq, &server->echo, SMB_ECHO_INTERVAL);
fs/cifs/connect.c:	queue_delayed_work(cifsiod_wq, &tcp_ses->echo, SMB_ECHO_INTERVAL);
fs/cifs/connect.c-	/* queue echo request delayed work */
fs/cifs/connect.c-requeue_echo:
fs/cifs/connect.c-	return tcp_ses;
fs/cifs/connect.c-	spin_lock(&cifs_sb->tlink_tree_lock);
fs/cifs/connect.c-	spin_lock(&GlobalMid_Lock);
fs/cifs/connect.c-	spin_unlock(&cifs_sb->tlink_tree_lock);
fs/cifs/connect.c-	spin_unlock(&cifs_sb->tlink_tree_lock);
fs/cifs/connect.c-	spin_unlock(&cifs_tcp_ses_lock);
fs/cifs/connect.c-	struct tcon_link *tlink;
fs/cifs/connect.c-				TLINK_IDLE_EXPIRE);
fs/cifs/connect.c-				TLINK_IDLE_EXPIRE);
fs/fs-writeback.c-
fs/fs-writeback.c-{
fs/fs-writeback.c-}
fs/fs-writeback.c-	}
fs/fs-writeback.c-		bdi_wakeup_thread_delayed(bdi);
fs/fs-writeback.c-	else if (wb_has_dirty_io(wb) && dirty_writeback_interval)
fs/fs-writeback.c-	if (!list_empty(&bdi->work_list))
fs/fs-writeback.c-	if (test_bit(BDI_registered, &bdi->state))
fs/fs-writeback.c-	list_add_tail(&work->list, &bdi->work_list);
fs/fs-writeback.c:		mod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);
fs/fs-writeback.c:	mod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);
fs/fs-writeback.c:		mod_delayed_work(bdi_wq, &wb->dwork, 0);
fs/fs-writeback.c-out_unlock:
fs/fs-writeback.c-	spin_lock_bh(&bdi->wb_lock);
fs/fs-writeback.c-	spin_unlock_bh(&bdi->wb_lock);
fs/fs-writeback.c-	spin_unlock_bh(&bdi->wb_lock);
fs/fs-writeback.c-	struct backing_dev_info *bdi = wb->bdi;
fs/fs-writeback.c-						struct bdi_writeback, dwork);
fs/fs-writeback.c:	struct bdi_writeback *wb = container_of(to_delayed_work(work),
fs/fs-writeback.c-void bdi_writeback_workfn(struct work_struct *work)
fs/gfs2/glock.c-}
fs/gfs2/glock.c-}
fs/gfs2/glock.c-}
fs/gfs2/glock.c-}
fs/gfs2/glock.c-}
fs/gfs2/glock.c-	}
fs/gfs2/glock.c-	}
fs/gfs2/glock.c-			clear_bit(GLF_LOCK, &gl->gl_flags);
fs/gfs2/glock.c-			delay = 0;
fs/gfs2/glock.c-		delay = gl->gl_hold_time;
fs/gfs2/glock.c-	} else { /* lock_nolock */
fs/gfs2/glock.c-		finish_xmote(gl, target);
fs/gfs2/glock.c-	gfs2_glock_hold(gl);
fs/gfs2/glock.c-	gfs2_glock_hold(gl);
fs/gfs2/glock.c-	gfs2_glock_hold(gl);
fs/gfs2/glock.c-	gfs2_glock_hold(gl);
fs/gfs2/glock.c-		gfs2_glock_put(gl);
fs/gfs2/glock.c-		gfs2_glock_put(gl);
fs/gfs2/glock.c-		gfs2_glock_put(gl);
fs/gfs2/glock.c-		gfs2_glock_put(gl);
fs/gfs2/glock.c-		gfs2_glock_put(gl);
fs/gfs2/glock.c-			gfs2_glock_put(gl);
fs/gfs2/glock.c-			gfs2_glock_put(gl);
fs/gfs2/glock.c-		gfs2_glock_put_nolock(gl);
fs/gfs2/glock.c-				gfs2_glock_put_nolock(gl);
fs/gfs2/glock.c-	    gl->gl_name.ln_type == LM_TYPE_INODE)
fs/gfs2/glock.c-	handle_callback(gl, state, delay);
fs/gfs2/glock.c-		if (gl->gl_name.ln_type != LM_TYPE_INODE)
fs/gfs2/glock.c:			if (queue_delayed_work(glock_workqueue, &gl->gl_work, 0) == 0)
fs/gfs2/glock.c:		if (queue_delayed_work(glock_workqueue, &gl->gl_work, 0) == 0)
fs/gfs2/glock.c:	if (queue_delayed_work(glock_workqueue, &gl->gl_work, 0) == 0)
fs/gfs2/glock.c:	if (queue_delayed_work(glock_workqueue, &gl->gl_work, 0) == 0)
fs/gfs2/glock.c:	if (queue_delayed_work(glock_workqueue, &gl->gl_work, 0) == 0)
fs/gfs2/glock.c:	if (queue_delayed_work(glock_workqueue, &gl->gl_work, 0) == 0)
fs/gfs2/glock.c:		if (queue_delayed_work(glock_workqueue, &gl->gl_work, delay) == 0)
fs/gfs2/glock.c:	if (queue_delayed_work(glock_workqueue, &gl->gl_work, delay) == 0)
fs/gfs2/glock.c:	if (queue_delayed_work(glock_workqueue, &gl->gl_work, delay) == 0)
fs/gfs2/glock.c-	return;
fs/gfs2/glock.c-	set_bit(GLF_REPLY_PENDING, &gl->gl_flags);
fs/gfs2/glock.c-	smp_mb__after_clear_bit();
fs/gfs2/glock.c-			smp_mb__after_clear_bit();
fs/gfs2/glock.c-	smp_wmb();
fs/gfs2/glock.c-	spin_unlock(&gl->gl_spin);
fs/gfs2/glock.c-	spin_unlock(&gl->gl_spin);
fs/gfs2/glock.c-			spin_unlock(&gl->gl_spin);
fs/gfs2/lock_dlm.c-
fs/gfs2/lock_dlm.c-
fs/gfs2/lock_dlm.c-
fs/gfs2/lock_dlm.c-
fs/gfs2/lock_dlm.c-	clear_bit(DFL_DLM_RECOVERY, &ls->ls_recover_flags);
fs/gfs2/lock_dlm.c:	flush_delayed_work(&sdp->sd_control_work);
fs/gfs2/lock_dlm.c-	if (!test_bit(DFL_UNMOUNT, &ls->ls_recover_flags))
fs/gfs2/lock_dlm.c-	if (!test_bit(DFL_UNMOUNT, &ls->ls_recover_flags))
fs/gfs2/lock_dlm.c-	/* mounted_lock and control_lock will be purged in dlm recovery */
fs/gfs2/lock_dlm.c:		queue_delayed_work(gfs2_control_wq, &sdp->sd_control_work,
fs/gfs2/lock_dlm.c:		queue_delayed_work(gfs2_control_wq, &sdp->sd_control_work, 0);
fs/gfs2/lock_dlm.c-				   result == LM_RD_GAVEUP ? HZ : 0);
fs/gfs2/lock_dlm.c-	set_bit(DFL_UNMOUNT, &ls->ls_recover_flags);
fs/gfs2/lock_dlm.c-	spin_unlock(&ls->ls_recover_spin);
fs/gfs2/lock_dlm.c-	spin_unlock(&ls->ls_recover_spin);
fs/jffs2/wbuf.c-
fs/jffs2/wbuf.c-
fs/jffs2/wbuf.c-{
fs/jffs2/wbuf.c-}
fs/jffs2/wbuf.c-}
fs/jffs2/wbuf.c-	delay = msecs_to_jiffies(dirty_writeback_interval * 10);
fs/jffs2/wbuf.c:	dwork = container_of(work, struct delayed_work, work);
fs/jffs2/wbuf.c:	if (queue_delayed_work(system_long_wq, &c->wbuf_dwork, delay))
fs/jffs2/wbuf.c-		jffs2_dbg(1, "%s()\n", __func__);
fs/jffs2/wbuf.c-	return container_of(dwork, struct jffs2_sb_info, wbuf_dwork);
fs/jffs2/wbuf.c-static struct jffs2_sb_info *work_to_sb(struct work_struct *work)
fs/jffs2/wbuf.c:	struct delayed_work *dwork;
fs/lockd/svc.c-
fs/lockd/svc.c-
fs/lockd/svc.c-
fs/lockd/svc.c-{
fs/lockd/svc.c-}
fs/lockd/svc.c-	}
fs/lockd/svc.c:	cancel_delayed_work_sync(&ln->grace_period_end);
fs/lockd/svc.c:	cancel_delayed_work_sync(&ln->grace_period_end);
fs/lockd/svc.c:		cancel_delayed_work_sync(&ln->grace_period_end);
fs/lockd/svc.c-	flush_signals(current);
fs/lockd/svc.c-	if (nlmsvc_ops)
fs/lockd/svc.c-	locks_end_grace(&ln->lockd_manager);
fs/lockd/svc.c-		locks_end_grace(&ln->lockd_manager);
fs/lockd/svc.c-	locks_start_grace(&ln->lockd_manager);
fs/lockd/svc.c-		nlmsvc_invalidate_all();
fs/lockd/svc.c:	schedule_delayed_work(&ln->grace_period_end, grace_period);
fs/lockd/svc.c-static void grace_ender(struct work_struct *grace)
fs/lockd/svc.c:	struct delayed_work *dwork = container_of(grace, struct delayed_work,
fs/lockd/svc.c-	struct lockd_net *ln = container_of(dwork, struct lockd_net,
fs/lockd/svc.c-		struct lockd_net *ln = net_generic(&init_net, lockd_net_id);
fs/lockd/svc.c-						  work);
fs/namespace.c-	}
fs/namespace.c-		}
fs/namespace.c-		if (llist_add(&mnt->mnt_llist, &delayed_mntput_list))
fs/namespace.c-		return;
fs/namespace.c:			schedule_delayed_work(&delayed_mntput_work, 1);
fs/nfsd/nfs4state.c-
fs/nfsd/nfs4state.c-{
fs/nfsd/nfs4state.c-}
fs/nfsd/nfs4state.c:	cancel_delayed_work_sync(&laundromat_work);
fs/nfsd/nfs4state.c-	destroy_workqueue(laundry_wq);
fs/nfsd/nfs4state.c-	dprintk("NFSD: laundromat_main - sleeping for %ld seconds\n", t);
fs/nfsd/nfs4state.c-		goto out_free_laundry;
fs/nfsd/nfs4state.c-	if (ret)
fs/nfsd/nfs4state.c-	locks_end_grace(&nfsd4_manager);
fs/nfsd/nfs4state.c-nfs4_state_shutdown(void)
fs/nfsd/nfs4state.c:	queue_delayed_work(laundry_wq, &laundromat_work, nfsd4_grace * HZ);
fs/nfsd/nfs4state.c:	queue_delayed_work(laundry_wq, &laundromat_work, t*HZ);
fs/nfsd/nfs4state.c-	return 0;
fs/nfsd/nfs4state.c-	set_max_delegations();
fs/nfsd/nfs4state.c-	t = nfs4_laundromat();
fs/nfs/namespace.c-
fs/nfs/namespace.c-
fs/nfs/namespace.c-
fs/nfs/namespace.c-{
fs/nfs/namespace.c-}
fs/nfs/namespace.c-}
fs/nfs/namespace.c:		cancel_delayed_work(&nfs_automount_task);
fs/nfs/namespace.c-	if (!list_empty(list))
fs/nfs/namespace.c-	if (list_empty(&nfs_automount_list))
fs/nfs/namespace.c-	mark_mounts_for_expiry(list);
fs/nfs/namespace.c-	mntget(mnt); /* prevent immediate expiration */
fs/nfs/namespace.c-	mnt_set_expiry(mnt, &nfs_automount_list);
fs/nfs/namespace.c-out:
fs/nfs/namespace.c:		schedule_delayed_work(&nfs_automount_task, nfs_mountpoint_expiry_timeout);
fs/nfs/namespace.c:	schedule_delayed_work(&nfs_automount_task, nfs_mountpoint_expiry_timeout);
fs/nfs/nfs4renewd.c-
fs/nfs/nfs4renewd.c-{
fs/nfs/nfs4renewd.c-}
fs/nfs/nfs4renewd.c:	cancel_delayed_work_sync(&clp->cl_renewd);
fs/nfs/nfs4renewd.c-	dprintk("%s: requeueing work. Lease period = %ld\n",
fs/nfs/nfs4renewd.c-			__func__, (timeout + HZ - 1) / HZ);
fs/nfs/nfs4renewd.c-nfs4_kill_renewd(struct nfs_client *clp)
fs/nfs/nfs4renewd.c:	queue_delayed_work(system_wq, &clp->cl_renewd, timeout);
fs/nfs/nfs4renewd.c-	set_bit(NFS_CS_RENEWD, &clp->cl_res_state);
fs/nfs/nfs4renewd.c-	spin_unlock(&clp->cl_lock);
fs/ocfs2/alloc.c-
fs/ocfs2/alloc.c-
fs/ocfs2/alloc.c-
fs/ocfs2/alloc.c-	}
fs/ocfs2/alloc.c:		cancel_delayed_work(&osb->osb_truncate_log_wq);
fs/ocfs2/alloc.c:			cancel_delayed_work(&osb->osb_truncate_log_wq);
fs/ocfs2/alloc.c-		flush_workqueue(ocfs2_wq);
fs/ocfs2/alloc.c-		if (cancel)
fs/ocfs2/alloc.c-	if (tl_inode) {
fs/ocfs2/alloc.c-				   OCFS2_TRUNCATE_LOG_FLUSH_INTERVAL);
fs/ocfs2/alloc.c:		queue_delayed_work(ocfs2_wq, &osb->osb_truncate_log_wq,
fs/ocfs2/alloc.c-		 * still running. */
fs/ocfs2/cluster/heartbeat.c-
fs/ocfs2/cluster/heartbeat.c-
fs/ocfs2/cluster/heartbeat.c-
fs/ocfs2/cluster/heartbeat.c-{
fs/ocfs2/cluster/heartbeat.c-}
fs/ocfs2/cluster/heartbeat.c-}
fs/ocfs2/cluster/heartbeat.c-	}
fs/ocfs2/cluster/heartbeat.c:	cancel_delayed_work(&reg->hr_write_timeout_work);
fs/ocfs2/cluster/heartbeat.c:	cancel_delayed_work_sync(&reg->hr_write_timeout_work);
fs/ocfs2/cluster/heartbeat.c-			      msecs_to_jiffies(O2HB_MAX_WRITE_TIMEOUT_MS));
fs/ocfs2/cluster/heartbeat.c-	reg->hr_last_timeout_start = jiffies;
fs/ocfs2/cluster/heartbeat.c:	schedule_delayed_work(&reg->hr_write_timeout_work,
fs/ocfs2/cluster/heartbeat.c-		spin_unlock(&o2hb_live_lock);
fs/ocfs2/cluster/heartbeat.c-static void o2hb_disarm_write_timeout(struct o2hb_region *reg)
fs/ocfs2/cluster/heartbeat.c:	struct delayed_work	hr_write_timeout_work;
fs/ocfs2/cluster/heartbeat.c-	u64			hr_generation;
fs/ocfs2/cluster/heartbeat.c-	unsigned long		hr_last_timeout_start;
fs/ocfs2/cluster/tcp.c-
fs/ocfs2/cluster/tcp.c-
fs/ocfs2/cluster/tcp.c-
fs/ocfs2/cluster/tcp.c-{
fs/ocfs2/cluster/tcp.c-{
fs/ocfs2/cluster/tcp.c-{
fs/ocfs2/cluster/tcp.c-}
fs/ocfs2/cluster/tcp.c-}
fs/ocfs2/cluster/tcp.c-}
fs/ocfs2/cluster/tcp.c-	}
fs/ocfs2/cluster/tcp.c-	}
fs/ocfs2/cluster/tcp.c-	}
fs/ocfs2/cluster/tcp.c-		/*
fs/ocfs2/cluster/tcp.c-		 */
fs/ocfs2/cluster/tcp.c:		cancel_delayed_work(&nn->nn_connect_expired);
fs/ocfs2/cluster/tcp.c:		cancel_delayed_work(&nn->nn_connect_expired);
fs/ocfs2/cluster/tcp.c:		cancel_delayed_work(&nn->nn_connect_work);
fs/ocfs2/cluster/tcp.c:		cancel_delayed_work(&nn->nn_still_up);
fs/ocfs2/cluster/tcp.c-			delay = 0;
fs/ocfs2/cluster/tcp.c-		delay += msecs_to_jiffies(o2net_idle_timeout());
fs/ocfs2/cluster/tcp.c-		del_timer_sync(&sc->sc_idle_timeout);
fs/ocfs2/cluster/tcp.c-		flush_workqueue(o2net_wq);
fs/ocfs2/cluster/tcp.c:	if (cancel_delayed_work(work))
fs/ocfs2/cluster/tcp.c-	if (o2net_wq) {
fs/ocfs2/cluster/tcp.c:	if (!queue_delayed_work(o2net_wq, work, delay))
fs/ocfs2/cluster/tcp.c-	if (!was_err && nn->nn_persistent_error) {
fs/ocfs2/cluster/tcp.c-	if (!was_valid && valid) {
fs/ocfs2/cluster/tcp.c-					int delay)
fs/ocfs2/cluster/tcp.c-		kernel_sock_shutdown(sc->sc_sock, SHUT_RDWR);
fs/ocfs2/cluster/tcp.c-		mlog(ML_CONN, "queueing conn attempt in %lu jiffies\n", delay);
fs/ocfs2/cluster/tcp.c-		      msecs_to_jiffies(o2net_keepalive_delay()));
fs/ocfs2/cluster/tcp.c-				   msecs_to_jiffies(O2NET_QUORUM_DELAY_MS));
fs/ocfs2/cluster/tcp.c:		o2net_sc_cancel_delayed_work(sc, &sc->sc_keepalive_work);
fs/ocfs2/cluster/tcp.c:	o2net_sc_cancel_delayed_work(sc, &sc->sc_keepalive_work);
fs/ocfs2/cluster/tcp.c:	o2net_sc_queue_delayed_work(sc, &sc->sc_keepalive_work,
fs/ocfs2/cluster/tcp.c-	o2net_set_sock_timer(sc);
fs/ocfs2/cluster/tcp.c-		       o2nm_this_node() > sc->sc_node->nd_num ?
fs/ocfs2/cluster/tcp.c-		o2quo_conn_err(o2net_num_from_nn(nn));
fs/ocfs2/cluster/tcp.c-		o2quo_conn_up(o2net_num_from_nn(nn));
fs/ocfs2/cluster/tcp.c-		printk(KERN_NOTICE "o2net: %s " SC_NODEF_FMT "\n",
fs/ocfs2/cluster/tcp.c:		queue_delayed_work(o2net_wq, &nn->nn_connect_expired, delay);
fs/ocfs2/cluster/tcp.c:		queue_delayed_work(o2net_wq, &nn->nn_connect_work, delay);
fs/ocfs2/cluster/tcp.c:		queue_delayed_work(o2net_wq, &nn->nn_still_up,
fs/ocfs2/cluster/tcp.c-		 * races with pending sc work structs are harmless */
fs/ocfs2/cluster/tcp.c-	sc_get(sc);
fs/ocfs2/cluster/tcp.c-		sc_put(sc);
fs/ocfs2/cluster/tcp.c-		sc_put(sc);
fs/ocfs2/cluster/tcp.c-		sc_put(sc);
fs/ocfs2/cluster/tcp.c-		sc_put(sc);
fs/ocfs2/cluster/tcp.c:static void o2net_sc_cancel_delayed_work(struct o2net_sock_container *sc,
fs/ocfs2/cluster/tcp.c:static void o2net_sc_queue_delayed_work(struct o2net_sock_container *sc,
fs/ocfs2/cluster/tcp.c-static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc)
fs/ocfs2/cluster/tcp.c:					 struct delayed_work *work)
fs/ocfs2/cluster/tcp.c:					struct delayed_work *work,
fs/ocfs2/journal.c-	}
fs/ocfs2/journal.c-	}
fs/ocfs2/journal.c-		atomic_set(&os->os_state, ORPHAN_SCAN_ACTIVE);
fs/ocfs2/journal.c-		atomic_set(&os->os_state, ORPHAN_SCAN_INACTIVE);
fs/ocfs2/journal.c:		cancel_delayed_work(&os->os_orphan_scan_work);
fs/ocfs2/journal.c-	else {
fs/ocfs2/journal.c-	if (atomic_read(&os->os_state) == ORPHAN_SCAN_ACTIVE)
fs/ocfs2/journal.c-		mutex_lock(&os->os_lock);
fs/ocfs2/journal.c-	mutex_unlock(&os->os_lock);
fs/ocfs2/journal.c-		mutex_unlock(&os->os_lock);
fs/ocfs2/journal.c-				   ocfs2_orphan_scan_timeout());
fs/ocfs2/journal.c-				      ocfs2_orphan_scan_timeout());
fs/ocfs2/journal.c-	ocfs2_queue_orphan_scan(osb);
fs/ocfs2/journal.c:		queue_delayed_work(ocfs2_wq, &os->os_orphan_scan_work,
fs/ocfs2/journal.c:		queue_delayed_work(ocfs2_wq, &os->os_orphan_scan_work,
fs/ocfs2/localalloc.c-
fs/ocfs2/localalloc.c-
fs/ocfs2/localalloc.c-		}
fs/ocfs2/localalloc.c-		}
fs/ocfs2/localalloc.c:	cancel_delayed_work(&osb->la_enable_wq);
fs/ocfs2/localalloc.c:			cancel_delayed_work(&osb->la_enable_wq);
fs/ocfs2/localalloc.c-	flush_workqueue(ocfs2_wq);
fs/ocfs2/localalloc.c-		goto out_unlock;
fs/ocfs2/localalloc.c-		if (num_clusters >= osb->local_alloc_default_bits) {
fs/ocfs2/localalloc.c-				   OCFS2_LA_ENABLE_INTERVAL);
fs/ocfs2/localalloc.c-			osb->local_alloc_state = OCFS2_LA_DISABLED;
fs/ocfs2/localalloc.c-			osb->local_alloc_state = OCFS2_LA_ENABLED;
fs/ocfs2/localalloc.c-	    osb->local_alloc_state == OCFS2_LA_THROTTLED)
fs/ocfs2/localalloc.c:		queue_delayed_work(ocfs2_wq, &osb->la_enable_wq,
fs/ocfs2/localalloc.c-	struct ocfs2_dinode *alloc = NULL;
fs/ocfs2/quota_global.c-
fs/ocfs2/quota_global.c-
fs/ocfs2/quota_global.c-}
fs/ocfs2/quota_global.c-	dquot_scan_active(sb, ocfs2_sync_dquot_helper, oinfo->dqi_type);
fs/ocfs2/quota_global.c-	INIT_DELAYED_WORK(&oinfo->dqi_sync_work, qsync_work_fn);
fs/ocfs2/quota_global.c-			      msecs_to_jiffies(oinfo->dqi_syncms));
fs/ocfs2/quota_global.c-			      msecs_to_jiffies(oinfo->dqi_syncms));
fs/ocfs2/quota_global.c-	oinfo->dqi_gi.dqi_qtree_depth = qtree_depth(&oinfo->dqi_gi);
fs/ocfs2/quota_global.c:	schedule_delayed_work(&oinfo->dqi_sync_work,
fs/ocfs2/quota_global.c:	schedule_delayed_work(&oinfo->dqi_sync_work,
fs/reiserfs/journal.c-
fs/reiserfs/journal.c-
fs/reiserfs/journal.c-	/*
fs/reiserfs/journal.c:	cancel_delayed_work(&SB_JOURNAL(sb)->j_work);
fs/reiserfs/journal.c-	} else if (!(jl->j_state & LIST_COMMIT_PENDING))
fs/reiserfs/journal.c-		flush_journal_list(sb, jl, 1);
fs/reiserfs/journal.c-	/* if the next transaction has any chance of wrapping, flush
fs/reiserfs/journal.c:		queue_delayed_work(commit_wq, &journal->j_work, HZ / 10);
fs/reiserfs/journal.c-	reiserfs_mounted_fs_count--;
fs/reiserfs/journal.c-	/* wait for all commits to finish */
fs/ufs/super.c-
fs/ufs/super.c-	}
fs/ufs/super.c:	cancel_delayed_work_sync(&sbi->sync_work);
fs/ufs/super.c-		delay = msecs_to_jiffies(dirty_writeback_interval * 10);
fs/ufs/super.c-	if (!sbi->work_queued) {
fs/ufs/super.c-	if (!(sb->s_flags & MS_RDONLY))
fs/ufs/super.c:		queue_delayed_work(system_long_wq, &sbi->sync_work, delay);
fs/ufs/super.c-		sbi->work_queued = 1;
fs/ufs/super.c-	ubh_brelse_uspi (sbi->s_uspi);
fs/ufs/super.c-		ufs_put_super_internal(sb);
fs/xfs/xfs_mru_cache.c-
fs/xfs/xfs_mru_cache.c-	}
fs/xfs/xfs_mru_cache.c-	}
fs/xfs/xfs_mru_cache.c-		}
fs/xfs/xfs_mru_cache.c:		cancel_delayed_work_sync(&mru->work);
fs/xfs/xfs_mru_cache.c-		else
fs/xfs/xfs_mru_cache.c-		if (!mru->queued) {
fs/xfs/xfs_mru_cache.c-	if (mru->queued) {
fs/xfs/xfs_mru_cache.c-			                   mru->grp_count * mru->grp_time);
fs/xfs/xfs_mru_cache.c-			mru->queued = 1;
fs/xfs/xfs_mru_cache.c-			next -= now;
fs/xfs/xfs_mru_cache.c:			queue_delayed_work(xfs_mru_reap_wq, &mru->work,
fs/xfs/xfs_mru_cache.c:		queue_delayed_work(xfs_mru_reap_wq, &mru->work, next);
fs/xfs/xfs_mru_cache.c-		spin_lock(&mru->lock);
fs/xfs/xfs_mru_cache.c-		spin_unlock(&mru->lock);
fs/xfs/xfs_sync.c-
fs/xfs/xfs_sync.c-{
fs/xfs/xfs_sync.c-{
fs/xfs/xfs_sync.c-{
fs/xfs/xfs_sync.c-{
fs/xfs/xfs_sync.c-}
fs/xfs/xfs_sync.c-}
fs/xfs/xfs_sync.c-	}
fs/xfs/xfs_sync.c:	cancel_delayed_work_sync(&mp->m_reclaim_work);
fs/xfs/xfs_sync.c:	cancel_delayed_work_sync(&mp->m_sync_work);
fs/xfs/xfs_sync.c-	cancel_work_sync(&mp->m_flush_work);
fs/xfs/xfs_sync.c-	if (radix_tree_tagged(&mp->m_perag_tree, XFS_ICI_RECLAIM_TAG)) {
fs/xfs/xfs_sync.c-	int		error;
fs/xfs/xfs_sync.c-				msecs_to_jiffies(xfs_syncd_centisecs * 10));
fs/xfs/xfs_sync.c-			msecs_to_jiffies(xfs_syncd_centisecs / 6 * 10));
fs/xfs/xfs_sync.c:		queue_delayed_work(xfs_syncd_wq, &mp->m_reclaim_work,
fs/xfs/xfs_sync.c:	queue_delayed_work(xfs_syncd_wq, &mp->m_sync_work,
fs/xfs/xfs_sync.c-	rcu_read_lock();
fs/xfs/xfs_sync.c-	struct work_struct *work)
fs/xfs/xfs_sync.c-	struct work_struct *work)
fs/xfs/xfs_sync.c-	struct xfs_mount        *mp)
fs/xfs/xfs_sync.c-	struct xfs_mount	*mp)
fs/xfs/xfs_sync.c:	struct xfs_mount *mp = container_of(to_delayed_work(work),
fs/xfs/xfs_sync.c:	struct xfs_mount *mp = container_of(to_delayed_work(work),
fs/xfs/xfs_sync.c-					struct xfs_mount, m_reclaim_work);
fs/xfs/xfs_sync.c-					struct xfs_mount, m_sync_work);
include/linux/blkdev.h-
include/linux/blkdev.h-
include/linux/blkdev.h-	 */
include/linux/blkdev.h-	 * Delayed queue handling
include/linux/blkdev.h-#ifdef CONFIG_BLK_CGROUP
include/linux/blkdev.h:int kblockd_schedule_delayed_work_on(int cpu, struct delayed_work *dwork, unsigned long delay);
include/linux/blkdev.h:int kblockd_schedule_delayed_work(struct delayed_work *dwork, unsigned long delay);
include/linux/blkdev.h-int kblockd_schedule_work_on(int cpu, struct work_struct *work);
include/linux/blkdev.h-int kblockd_schedule_work(struct work_struct *work);
include/linux/blkdev.h-	struct backing_dev_info	backing_dev_info;
include/linux/blkdev.h:	struct delayed_work	delay_work;
include/linux/kthread.h-
include/linux/kthread.h-
include/linux/kthread.h-
include/linux/kthread.h-
include/linux/kthread.h-
include/linux/kthread.h-
include/linux/kthread.h-
include/linux/kthread.h-
include/linux/kthread.h-
include/linux/kthread.h-
include/linux/kthread.h-
include/linux/kthread.h-};
include/linux/kthread.h-	}
include/linux/kthread.h-	}
include/linux/kthread.h:bool kthread_cancel_delayed_work_sync(struct kthread_delayed_work *work);
include/linux/kthread.h-bool kthread_cancel_work_sync(struct kthread_work *work);
include/linux/kthread.h:bool kthread_mod_delayed_work(struct kthread_worker *worker,
include/linux/kthread.h:bool kthread_queue_delayed_work(struct kthread_worker *worker,
include/linux/kthread.h-#define DEFINE_KTHREAD_DELAYED_WORK(dwork, fn)				\
include/linux/kthread.h-#define KTHREAD_DELAYED_WORK_INIT(dwork, fn) {				\
include/linux/kthread.h:#define kthread_init_delayed_work(dwork, fn)				\
include/linux/kthread.h:	.delayed_work_list = LIST_HEAD_INIT((worker).delayed_work_list),\
include/linux/kthread.h-	do {								\
include/linux/kthread.h-enum {
include/linux/kthread.h-		__init_timer(&(dwork)->timer,				\
include/linux/kthread.h-		KTHREAD_DELAYED_WORK_INIT(dwork, fn)
include/linux/kthread.h:			     kthread_delayed_work_timer_fn,		\
include/linux/kthread.h-		kthread_init_work(&(dwork)->work, (fn));		\
include/linux/kthread.h-	.lock = __SPIN_LOCK_UNLOCKED((worker).lock),			\
include/linux/kthread.h-	spinlock_t		lock;
include/linux/kthread.h:struct kthread_delayed_work {
include/linux/kthread.h:			      struct kthread_delayed_work *dwork,
include/linux/kthread.h:				struct kthread_delayed_work *dwork,
include/linux/kthread.h:	struct kthread_delayed_work dwork =				\
include/linux/kthread.h-struct kthread_work;
include/linux/kthread.h-	struct kthread_work	*current_work;
include/linux/kthread.h-			struct kthread_work *work);
include/linux/kthread.h-	struct kthread_work work;
include/linux/kthread.h:	struct list_head	delayed_work_list;
include/linux/kthread.h-	struct list_head	work_list;
include/linux/kthread.h-	struct task_struct	*task;
include/linux/kthread.h-	struct timer_list timer;
include/linux/kthread.h-			     TIMER_IRQSAFE);				\
include/linux/kthread.h-				     TIMER_IRQSAFE),			\
include/linux/kthread.h:	.timer = __TIMER_INITIALIZER(kthread_delayed_work_timer_fn,\
include/linux/kthread.h-typedef void (*kthread_work_func_t)(struct kthread_work *work);
include/linux/kthread.h-			      unsigned long delay);
include/linux/kthread.h-				unsigned long delay);
include/linux/kthread.h:void kthread_delayed_work_timer_fn(struct timer_list *t);
include/linux/kthread.h-void kthread_destroy_worker(struct kthread_worker *worker);
include/linux/kthread.h-	} while (0)
include/linux/kthread.h-	} while (0)
include/linux/kthread.h-	.work = KTHREAD_WORK_INIT((dwork).work, (fn)),			\
include/linux/kthread.h-	.work_list = LIST_HEAD_INIT((worker).work_list),		\
include/linux/libata.h-
include/linux/libata.h-
include/linux/libata.h:extern void ata_sff_queue_delayed_work(struct delayed_work *dwork,
include/linux/libata.h-extern void ata_sff_queue_pio_task(struct ata_link *link, unsigned long delay);
include/linux/libata.h-extern void ata_sff_queue_work(struct work_struct *work);
include/linux/libata.h-#ifdef CONFIG_ATA_BMDMA
include/linux/libata.h-	struct ata_bmdma_prd	*bmdma_prd;	/* BMDMA SG list */
include/linux/libata.h-	struct ata_link*	sff_pio_task_link; /* link currently used */
include/linux/libata.h:	struct delayed_work	hotplug_task;
include/linux/libata.h:	struct delayed_work	sff_pio_task;
include/linux/libata.h-	struct mutex		scsi_scan_mutex;
include/linux/libata.h-	struct work_struct	scsi_rescan_task;
include/linux/libata.h-	u8			last_ctl;	/* Cache last written value */
include/linux/libata.h-			    u8 status, int in_wq);
include/linux/libata.h-		unsigned long delay);
include/linux/workqueue.h-
include/linux/workqueue.h-
include/linux/workqueue.h-
include/linux/workqueue.h-
include/linux/workqueue.h-
include/linux/workqueue.h-
include/linux/workqueue.h-
include/linux/workqueue.h-
include/linux/workqueue.h-
include/linux/workqueue.h-
include/linux/workqueue.h-
include/linux/workqueue.h-
include/linux/workqueue.h-
include/linux/workqueue.h-
include/linux/workqueue.h-
include/linux/workqueue.h-
include/linux/workqueue.h-
include/linux/workqueue.h-
include/linux/workqueue.h-
include/linux/workqueue.h-/*
include/linux/workqueue.h-/**
include/linux/workqueue.h-/**
include/linux/workqueue.h-/**
include/linux/workqueue.h-/**
include/linux/workqueue.h-/**
include/linux/workqueue.h-{
include/linux/workqueue.h-{
include/linux/workqueue.h-{
include/linux/workqueue.h-{
include/linux/workqueue.h-{
include/linux/workqueue.h-{
include/linux/workqueue.h-{
include/linux/workqueue.h-}
include/linux/workqueue.h-}
include/linux/workqueue.h-}
include/linux/workqueue.h-}
include/linux/workqueue.h-}
include/linux/workqueue.h-}
include/linux/workqueue.h-};
include/linux/workqueue.h- *
include/linux/workqueue.h- *
include/linux/workqueue.h- */
include/linux/workqueue.h- */
include/linux/workqueue.h- */
include/linux/workqueue.h- */
include/linux/workqueue.h- */
include/linux/workqueue.h- */
include/linux/workqueue.h-	}
include/linux/workqueue.h-	ATOMIC_LONG_INIT((unsigned long)(WORK_STRUCT_NO_POOL | WORK_STRUCT_STATIC))
include/linux/workqueue.h- * cancel_work_sync() instead.
include/linux/workqueue.h- * @cpu: cpu to use
include/linux/workqueue.h-#define DECLARE_DEFERRABLE_WORK(n, f)					\
include/linux/workqueue.h-#define DECLARE_DELAYED_WORK(n, f)					\
include/linux/workqueue.h-#define __DELAYED_WORK_INITIALIZER(n, f, tflags) {			\
include/linux/workqueue.h:#define delayed_work_pending(w) \
include/linux/workqueue.h: * delayed_work_pending - Find out whether a delayable work item is currently
include/linux/workqueue.h:			     delayed_work_timer_fn,			\
include/linux/workqueue.h:				      delayed_work_timer_fn,		\
include/linux/workqueue.h- * @delay: number of jiffies to wait before queueing
include/linux/workqueue.h- * @delay: number of jiffies to wait before queueing
include/linux/workqueue.h- * @delay: number of jiffies to wait or 0 for immediate execution
include/linux/workqueue.h- * @dwork: delayable work to queue
include/linux/workqueue.h- * @dwork: job to be done
include/linux/workqueue.h- * @dwork: job to be done
include/linux/workqueue.h- * @dwork: work to queue
include/linux/workqueue.h-#endif
include/linux/workqueue.h: * Equivalent to queue_delayed_work_on() but tries to use the local CPU.
include/linux/workqueue.h:extern bool cancel_delayed_work(struct delayed_work *dwork);
include/linux/workqueue.h:extern bool cancel_delayed_work_sync(struct delayed_work *dwork);
include/linux/workqueue.h-extern bool cancel_work_sync(struct work_struct *work);
include/linux/workqueue.h:extern bool flush_delayed_work(struct delayed_work *dwork);
include/linux/workqueue.h:extern bool mod_delayed_work_on(int cpu, struct workqueue_struct *wq,
include/linux/workqueue.h:extern bool queue_delayed_work_on(int cpu, struct workqueue_struct *wq,
include/linux/workqueue.h-extern bool queue_work_on(int cpu, struct workqueue_struct *wq,
include/linux/workqueue.h:extern void destroy_delayed_work_on_stack(struct delayed_work *work);
include/linux/workqueue.h-extern void destroy_work_on_stack(struct work_struct *work);
include/linux/workqueue.h-extern void flush_workqueue(struct workqueue_struct *wq);
include/linux/workqueue.h-extern void __init_work(struct work_struct *work, int onstack);
include/linux/workqueue.h-extern void workqueue_set_max_active(struct workqueue_struct *wq,
include/linux/workqueue.h-#ifdef CONFIG_DEBUG_OBJECTS_WORK
include/linux/workqueue.h-		__init_timer_on_stack(&(_work)->timer,			\
include/linux/workqueue.h-		__init_timer(&(_work)->timer,				\
include/linux/workqueue.h-		INIT_WORK_ONSTACK(&(_work)->work, (_func));		\
include/linux/workqueue.h-		INIT_WORK(&(_work)->work, (_func));			\
include/linux/workqueue.h- * In most situations flushing the entire workqueue is overkill; you merely
include/linux/workqueue.h: * In such cases you should use cancel_delayed_work_sync() or
include/linux/workqueue.h: * mod_delayed_work - modify delay of or queue a delayed work
include/linux/workqueue.h: * mod_delayed_work_on() on local CPU.
include/linux/workqueue.h- * need to know that a particular work item isn't queued and isn't running.
include/linux/workqueue.h- * pending
include/linux/workqueue.h: * queue_delayed_work - queue work on a workqueue after delay
include/linux/workqueue.h:	return container_of(work, struct delayed_work, work);
include/linux/workqueue.h:	return mod_delayed_work_on(WORK_CPU_UNBOUND, wq, dwork, delay);
include/linux/workqueue.h:	return mod_delayed_work(system_wq, dwork, delay);
include/linux/workqueue.h:	return queue_delayed_work_on(cpu, system_wq, dwork, delay);
include/linux/workqueue.h:	return queue_delayed_work_on(WORK_CPU_UNBOUND, wq, dwork, delay);
include/linux/workqueue.h:	return queue_delayed_work(system_wq, dwork, delay);
include/linux/workqueue.h: * schedule_delayed_work_on - queue work in global workqueue on CPU after delay
include/linux/workqueue.h: * schedule_delayed_work - put work task in global workqueue after delay
include/linux/workqueue.h:static inline bool mod_delayed_work(struct workqueue_struct *wq,
include/linux/workqueue.h:static inline bool mod_scheduled_work(struct delayed_work *dwork,
include/linux/workqueue.h:static inline bool queue_delayed_work(struct workqueue_struct *wq,
include/linux/workqueue.h:static inline bool schedule_delayed_work_on(int cpu, struct delayed_work *dwork,
include/linux/workqueue.h:static inline bool schedule_delayed_work(struct delayed_work *dwork,
include/linux/workqueue.h:static inline struct delayed_work *to_delayed_work(struct work_struct *work)
include/linux/workqueue.h-static inline unsigned int work_static(struct work_struct *work)
include/linux/workqueue.h-static inline unsigned int work_static(struct work_struct *work) { return 0; }
include/linux/workqueue.h:static inline void destroy_delayed_work_on_stack(struct delayed_work *work) { }
include/linux/workqueue.h-static inline void destroy_work_on_stack(struct work_struct *work) { }
include/linux/workqueue.h-static inline void __init_work(struct work_struct *work, int onstack) { }
include/linux/workqueue.h:struct delayed_work {
include/linux/workqueue.h:				      struct delayed_work *dwork,
include/linux/workqueue.h:				    struct delayed_work *dwork,
include/linux/workqueue.h:			struct delayed_work *dwork, unsigned long delay);
include/linux/workqueue.h:	struct delayed_work n = __DELAYED_WORK_INITIALIZER(n, f, 0)
include/linux/workqueue.h:	struct delayed_work n = __DELAYED_WORK_INITIALIZER(n, f, TIMER_DEFERRABLE)
include/linux/workqueue.h:			struct delayed_work *work, unsigned long delay);
include/linux/workqueue.h-	struct timer_list timer;
include/linux/workqueue.h-struct work_struct;
include/linux/workqueue.h-			struct work_struct *work);
include/linux/workqueue.h-	struct work_struct work;
include/linux/workqueue.h-			     (_tflags) | TIMER_IRQSAFE);		\
include/linux/workqueue.h-				      (_tflags) | TIMER_IRQSAFE);	\
include/linux/workqueue.h-				     (tflags) | TIMER_IRQSAFE),		\
include/linux/workqueue.h:	.timer = __TIMER_INITIALIZER(delayed_work_timer_fn,\
include/linux/workqueue.h-typedef void (*work_func_t)(struct work_struct *work);
include/linux/workqueue.h-				      unsigned long delay)
include/linux/workqueue.h-				    unsigned long delay)
include/linux/workqueue.h-					    unsigned long delay)
include/linux/workqueue.h-					 unsigned long delay)
include/linux/workqueue.h-					 unsigned long delay)
include/linux/workqueue.h:void delayed_work_timer_fn(struct timer_list *t);
include/linux/workqueue.h-	} while (0)
include/linux/workqueue.h-	} while (0)
include/linux/workqueue.h-	work_pending(&(w)->work)
include/linux/workqueue.h- * workqueue.
include/linux/workqueue.h- * workqueue on the specified CPU.
include/linux/workqueue.h-	.work = __WORK_INITIALIZER((n).work, (f)),			\
include/linux/workqueue.h- * @wq: workqueue to use
include/linux/workqueue.h- * @wq: workqueue to use
include/linux/workqueue.h- * @w: The work item in question
include/net/mac80211.h-
include/net/mac80211.h-
include/net/mac80211.h-/**
include/net/mac80211.h- *
include/net/mac80211.h- */
include/net/mac80211.h- * @delay: number of jiffies to wait before queueing
include/net/mac80211.h- * Drivers and mac80211 use this to queue delayed work onto the mac80211
include/net/mac80211.h: * ieee80211_queue_delayed_work - add work onto the mac80211 workqueue
include/net/mac80211.h:				  struct delayed_work *dwork,
include/net/mac80211.h-				  unsigned long delay);
include/net/mac80211.h:void ieee80211_queue_delayed_work(struct ieee80211_hw *hw,
kernel/cgroup.c-
kernel/cgroup.c-
kernel/cgroup.c-
kernel/cgroup.c-{
kernel/cgroup.c-};
kernel/cgroup.c-	 */
kernel/cgroup.c-	 * as destroy_dwork can only be queued while locked.
kernel/cgroup.c-				 CGROUP_PIDLIST_DESTROY_DELAY);
kernel/cgroup.c-						destroy_dwork);
kernel/cgroup.c-	/* for delayed destruction */
kernel/cgroup.c:	if (!delayed_work_pending(dwork)) {
kernel/cgroup.c-	if (l)
kernel/cgroup.c-		list_del(&l->links);
kernel/cgroup.c-	list_for_each_entry_safe(l, tmp_l, &cgrp->pidlists, links)
kernel/cgroup.c:		mod_delayed_work(cgroup_pidlist_destroy_wq, &l->destroy_dwork,
kernel/cgroup.c:		mod_delayed_work(cgroup_pidlist_destroy_wq, &l->destroy_dwork, 0);
kernel/cgroup.c-	mutex_lock(&cgrp->pidlist_mutex);
kernel/cgroup.c-	mutex_unlock(&cgrp->pidlist_mutex);
kernel/cgroup.c-	mutex_unlock(&seq_css(s)->cgroup->pidlist_mutex);
kernel/cgroup.c-		pidlist_free(l->list);
kernel/cgroup.c-static void cgroup_pidlist_destroy_work_fn(struct work_struct *work)
kernel/cgroup.c-	struct cgroup *owner;
kernel/cgroup.c-	struct cgroup_pidlist *l = container_of(dwork, struct cgroup_pidlist,
kernel/cgroup.c:	struct delayed_work destroy_dwork;
kernel/cgroup.c:	struct delayed_work *dwork = to_delayed_work(work);
kernel/jump_label.c-
kernel/jump_label.c-{
kernel/jump_label.c-		atomic_inc(&key->enabled);
kernel/jump_label.c-	} else {
kernel/jump_label.c-	if (!atomic_dec_and_mutex_lock(&key->enabled, &jump_label_mutex)) {
kernel/jump_label.c-	if (rate_limit) {
kernel/jump_label.c-		if (!static_key_type(key))
kernel/jump_label.c:		schedule_delayed_work(work, rate_limit);
kernel/jump_label.c-static void __static_key_slow_dec(struct static_key *key,
kernel/jump_label.c:		unsigned long rate_limit, struct delayed_work *work)
kernel/kprobes.c-
kernel/kprobes.c-
kernel/kprobes.c-{
kernel/kprobes.c-}
kernel/kprobes.c-		cpu_relax();
kernel/kprobes.c:		flush_delayed_work(&optimizing_work);
kernel/kprobes.c-		/* @optimizing_work might not have been queued yet, relax */
kernel/kprobes.c:	schedule_delayed_work(&optimizing_work, OPTIMIZE_DELAY);
kernel/kprobes.c-static __kprobes void kick_kprobe_optimizer(void)
kernel/kprobes.c-		/* this will also make optimizing_work execute immmediately */
kernel/kthread.c-
kernel/kthread.c-
kernel/kthread.c-
kernel/kthread.c-
kernel/kthread.c-
kernel/kthread.c-
kernel/kthread.c-
kernel/kthread.c-
kernel/kthread.c-
kernel/kthread.c-
kernel/kthread.c-
kernel/kthread.c-
kernel/kthread.c-
kernel/kthread.c-
kernel/kthread.c-/**
kernel/kthread.c-/**
kernel/kthread.c-/**
kernel/kthread.c-/**
kernel/kthread.c-/**
kernel/kthread.c-{
kernel/kthread.c-{
kernel/kthread.c-{
kernel/kthread.c-{
kernel/kthread.c-{
kernel/kthread.c-}
kernel/kthread.c-}
kernel/kthread.c-}
kernel/kthread.c-}
kernel/kthread.c-}
kernel/kthread.c- *
kernel/kthread.c- *
kernel/kthread.c- *
kernel/kthread.c- *
kernel/kthread.c- *
kernel/kthread.c- *
kernel/kthread.c- */
kernel/kthread.c- */
kernel/kthread.c- */
kernel/kthread.c- */
kernel/kthread.c-	/*
kernel/kthread.c-	/*
kernel/kthread.c-	}
kernel/kthread.c-	 */
kernel/kthread.c-	 */
kernel/kthread.c- *	after a delay.
kernel/kthread.c- * A special case is when the work is being canceled in parallel.
kernel/kthread.c:	 * be from worker->work_list or from worker->delayed_work_list.
kernel/kthread.c:bool kthread_cancel_delayed_work_sync(struct kthread_delayed_work *dwork)
kernel/kthread.c:bool kthread_mod_delayed_work(struct kthread_worker *worker,
kernel/kthread.c:bool kthread_queue_delayed_work(struct kthread_worker *worker,
kernel/kthread.c-	 * both optimization and correctness.  The earliest @timer can
kernel/kthread.c:			container_of(work, struct kthread_delayed_work, work);
kernel/kthread.c: * delayed_work's. Use kthread_cancel_delayed_work_sync() instead.
kernel/kthread.c- *	delayed work when the timer expires.
kernel/kthread.c- * @delay: number of jiffies to wait before queuing
kernel/kthread.c- * @delay: number of jiffies to wait before queuing
kernel/kthread.c- * @dwork: kthread delayed work to queue
kernel/kthread.c: * @dwork: kthread_delayed_work to queue
kernel/kthread.c- * @dwork: the kthread delayed work to cancel
kernel/kthread.c:	 * expire is on the closest next tick and delayed_work users depend
kernel/kthread.c:EXPORT_SYMBOL_GPL(kthread_cancel_delayed_work_sync);
kernel/kthread.c-EXPORT_SYMBOL_GPL(__kthread_init_worker);
kernel/kthread.c:EXPORT_SYMBOL_GPL(kthread_mod_delayed_work);
kernel/kthread.c:EXPORT_SYMBOL_GPL(kthread_queue_delayed_work);
kernel/kthread.c:EXPORT_SYMBOL(kthread_delayed_work_timer_fn);
kernel/kthread.c-fast_queue:
kernel/kthread.c- * for details.
kernel/kthread.c- * function, @work is guaranteed to be not pending or executing on any CPU.
kernel/kthread.c-	 * If @delay is 0, queue @dwork->work immediately.  This is for
kernel/kthread.c: * If @dwork is idle, equivalent to kthread_queue_delayed_work(). Otherwise,
kernel/kthread.c-	if (is_dwork) {
kernel/kthread.c-	if (!list_empty(&work->node)) {
kernel/kthread.c-	if (!queuing_blocked(worker, work)) {
kernel/kthread.c:	INIT_LIST_HEAD(&worker->delayed_work_list);
kernel/kthread.c-	INIT_LIST_HEAD(&worker->work_list);
kernel/kthread.c: * It might be caused either by the real kthread_cancel_delayed_work_sync()
kernel/kthread.c- * It should have been called from irqsafe timer with irq already off.
kernel/kthread.c: * kthread_cancel_delayed_work_sync - cancel a kthread delayed work and
kernel/kthread.c: * kthread_cancel_work_sync(&delayed_work->work) must not be used for
kernel/kthread.c: * kthread_delayed_work_timer_fn - callback that queues the associated kthread
kernel/kthread.c-	kthread_insert_work_sanity_check(worker, work);
kernel/kthread.c: * kthread_mod_delayed_work - modify delay of or queue a kthread delayed work
kernel/kthread.c: * kthread_queue_delayed_work - queue the associated kthread work
kernel/kthread.c:		__kthread_queue_delayed_work(worker, dwork, delay);
kernel/kthread.c:	__kthread_queue_delayed_work(worker, dwork, delay);
kernel/kthread.c:	list_add(&work->node, &worker->delayed_work_list);
kernel/kthread.c-	list_del_init(&work->node);
kernel/kthread.c-	lockdep_set_class_and_name(&worker->lock, key, name);
kernel/kthread.c- * modify @dwork's timer so that it expires after @delay. If @delay is zero,
kernel/kthread.c:	/* Move the work from worker->delayed_work_list. */
kernel/kthread.c-	 * on that there's no such delay when @delay is 0.
kernel/kthread.c- * operations a reasonable way.
kernel/kthread.c: * or yet another kthread_mod_delayed_work() call. We let the other command
kernel/kthread.c- * otherwise.
kernel/kthread.c-out:
kernel/kthread.c-	ret = __kthread_cancel_work(work, true, &flags);
kernel/kthread.c-		ret = true;
kernel/kthread.c-	return __kthread_cancel_work_sync(&dwork->work, true);
kernel/kthread.c-	return ret;
kernel/kthread.c-	return ret;
kernel/kthread.c- * Return: %true if @dwork was pending, %false otherwise.
kernel/kthread.c: * See __kthread_cancel_work() and kthread_delayed_work_timer_fn()
kernel/kthread.c-	spin_unlock_irqrestore(&worker->lock, flags);
kernel/kthread.c-	spin_unlock(&worker->lock);
kernel/kthread.c-static bool __kthread_cancel_work_sync(struct kthread_work *work, bool is_dwork)
kernel/kthread.c:			      struct kthread_delayed_work *dwork,
kernel/kthread.c:				  struct kthread_delayed_work *dwork,
kernel/kthread.c:				struct kthread_delayed_work *dwork,
kernel/kthread.c:		struct kthread_delayed_work *dwork =
kernel/kthread.c:	struct kthread_delayed_work *dwork = from_timer(dwork, t, timer);
kernel/kthread.c-struct kthread_flush_work {
kernel/kthread.c-		struct kthread_worker *worker = work->worker;
kernel/kthread.c-	struct kthread_worker *worker = work->worker;
kernel/kthread.c-	struct kthread_work *work = &dwork->work;
kernel/kthread.c-	struct kthread_work *work = &dwork->work;
kernel/kthread.c- * The caller must ensure that the worker on which @work was last
kernel/kthread.c- * This function is safe to call from any context including IRQ handler.
kernel/kthread.c-	timer->expires = jiffies + delay;
kernel/kthread.c- * @t: pointer to the expired timer
kernel/kthread.c-	/* Try to cancel the timer if exists. */
kernel/kthread.c-	 * Try to remove the work from a worker list. It might either
kernel/kthread.c-			      unsigned long delay)
kernel/kthread.c-				  unsigned long delay)
kernel/kthread.c-				unsigned long delay)
kernel/kthread.c:void kthread_delayed_work_timer_fn(struct timer_list *t)
kernel/kthread.c:void __kthread_queue_delayed_work(struct kthread_worker *worker,
kernel/kthread.c- *	wait for it to finish.
kernel/kthread.c-	WARN_ON_ONCE(list_empty(&work->node));
kernel/kthread.c:	WARN_ON_ONCE(timer->function != kthread_delayed_work_timer_fn);
kernel/kthread.c-	WARN_ON_ONCE(work->worker != worker);
kernel/kthread.c- * win and return %false here. The caller is supposed to synchronize these
kernel/kthread.c- * @worker: kthread worker to use
kernel/kthread.c- * @worker: target kthread_worker
kernel/kthread.c- * @work is guaranteed to be queued immediately.
kernel/kthread.c-	work->worker = worker;
kernel/power/qos.c-
kernel/power/qos.c-
kernel/power/qos.c-
kernel/power/qos.c-
kernel/power/qos.c-
kernel/power/qos.c-
kernel/power/qos.c-
kernel/power/qos.c-{
kernel/power/qos.c-}
kernel/power/qos.c-}
kernel/power/qos.c-	}
kernel/power/qos.c-	}
kernel/power/qos.c:	cancel_delayed_work_sync(&req->work);
kernel/power/qos.c:	cancel_delayed_work_sync(&req->work);
kernel/power/qos.c:	cancel_delayed_work_sync(&req->work);
kernel/power/qos.c-	__pm_qos_update_request(req, new_value);
kernel/power/qos.c-			&req->node, PM_QOS_UPDATE_REQ, new_value);
kernel/power/qos.c-		return;
kernel/power/qos.c:	schedule_delayed_work(&req->work, usecs_to_jiffies(timeout_us));
kernel/power/qos.c-static void pm_qos_work_fn(struct work_struct *work)
kernel/power/qos.c-						  struct pm_qos_request,
kernel/power/qos.c:	struct pm_qos_request *req = container_of(to_delayed_work(work),
kernel/power/qos.c-	trace_pm_qos_remove_request(req->pm_qos_class, PM_QOS_DEFAULT_VALUE);
kernel/power/qos.c-	trace_pm_qos_update_request_timeout(req->pm_qos_class,
kernel/power/qos.c-						  work);
kernel/power/state_notifier.c-
kernel/power/state_notifier.c-
kernel/power/state_notifier.c-
kernel/power/state_notifier.c-
kernel/power/state_notifier.c-
kernel/power/state_notifier.c-{
kernel/power/state_notifier.c-}
kernel/power/state_notifier.c:	cancel_delayed_work_sync(&resume_work);
kernel/power/state_notifier.c:	cancel_delayed_work_sync(&suspend_work);
kernel/power/state_notifier.c-#define STATE_NOTIFIER "state_notifier"
kernel/power/state_notifier.c-	destroy_workqueue(susp_wq);
kernel/power/state_notifier.c-	else
kernel/power/state_notifier.c:	flush_delayed_work(&resume_work);
kernel/power/state_notifier.c:	flush_delayed_work(&suspend_work);
kernel/power/state_notifier.c-	if (state_notifier_kobj != NULL) {
kernel/power/state_notifier.c-	if (state_suspended)
kernel/power/state_notifier.c-			msecs_to_jiffies(resume_defer_time * 1000));
kernel/power/state_notifier.c-		msecs_to_jiffies(suspend_defer_time * 1000));
kernel/power/state_notifier.c-		printk("[STATE NOTIFIER] - Resume Called\n");
kernel/power/state_notifier.c-	printk("[STATE NOTIFIER] - Suspend Called\n");
kernel/power/state_notifier.c:		queue_delayed_work(susp_wq, &resume_work,
kernel/power/state_notifier.c:	queue_delayed_work(susp_wq, &suspend_work,
kernel/power/state_notifier.c-	//resume_in_progress = false;
kernel/power/state_notifier.c-	//resume_in_progress = true;
kernel/power/state_notifier.c:static struct delayed_work resume_work;
kernel/power/state_notifier.c:static struct delayed_work suspend_work;
kernel/power/state_notifier.c-static struct workqueue_struct *susp_wq;
kernel/power/state_notifier.c-static unsigned int suspend_defer_time = 0;
kernel/power/state_notifier.c-static void state_notifier_exit(void)
kernel/power/state_notifier.c-	suspend_in_progress = false;
kernel/power/state_notifier.c-	suspend_in_progress = true;
kernel/rcu/srcutree.c-
kernel/rcu/srcutree.c-
kernel/rcu/srcutree.c-{
kernel/rcu/srcutree.c-{
kernel/rcu/srcutree.c-}
kernel/rcu/srcutree.c-}
kernel/rcu/srcutree.c- */
kernel/rcu/srcutree.c-	}
kernel/rcu/srcutree.c-	else
kernel/rcu/srcutree.c:		flush_delayed_work(&per_cpu_ptr(sp->sda, cpu)->work);
kernel/rcu/srcutree.c:	flush_delayed_work(&sp->work);
kernel/rcu/srcutree.c-	for_each_possible_cpu(cpu)
kernel/rcu/srcutree.c-	if (pushgp)
kernel/rcu/srcutree.c-	if (READ_ONCE(per_cpu(srcu_online, cpu)))
kernel/rcu/srcutree.c-	if (WARN_ON(rcu_seq_state(READ_ONCE(sp->srcu_gp_seq)) != SRCU_STATE_IDLE) ||
kernel/rcu/srcutree.c-	if (WARN_ON(srcu_readers_active(sp)))
kernel/rcu/srcutree.c-	preempt_disable();
kernel/rcu/srcutree.c-	preempt_enable();
kernel/rcu/srcutree.c:		queue_delayed_work(system_power_efficient_wq, &sp->work,
kernel/rcu/srcutree.c:		queue_delayed_work(system_power_efficient_wq, &sp->work, delay);
kernel/rcu/srcutree.c:		ret = queue_delayed_work_on(cpu, wq, dwork, delay);
kernel/rcu/srcutree.c:		ret = queue_delayed_work(wq, dwork, delay);
kernel/rcu/srcutree.c-		return; /* Leakage unless caller handles error. */
kernel/rcu/srcutree.c-	return ret;
kernel/rcu/srcutree.c-				   &sdp->work, delay);
kernel/rcu/srcutree.c-				   srcu_get_delay(sp));
kernel/rcu/srcutree.c-		srcu_gp_start(sp);
kernel/rcu/srcutree.c:	srcu_queue_delayed_work_on(sdp->cpu, system_power_efficient_wq,
kernel/rcu/srcutree.c:static bool srcu_queue_delayed_work_on(int cpu, struct workqueue_struct *wq,
kernel/rcu/srcutree.c-static void srcu_schedule_cbs_sdp(struct srcu_data *sdp, unsigned long delay)
kernel/rcu/srcutree.c:				       struct delayed_work *dwork,
kernel/rcu/srcutree.c- * that are to invoke the specified CPU's callbacks.
kernel/rcu/srcutree.c-				       unsigned long delay)
kernel/rcu/srcutree.c-		WARN_ON_ONCE(ULONG_CMP_GE(sp->srcu_gp_seq, sp->srcu_gp_seq_needed));
kernel/rcu/srcutree.c-	    WARN_ON(srcu_readers_active(sp))) {
kernel/time/ntp.c-
kernel/time/ntp.c-
kernel/time/ntp.c-}
kernel/time/ntp.c-}
kernel/time/ntp.c-	}
kernel/time/ntp.c-	if (IS_ENABLED(CONFIG_GENERIC_CMOS_UPDATE) ||
kernel/time/ntp.c-	    IS_ENABLED(CONFIG_RTC_SYSTOHC))
kernel/time/ntp.c:	queue_delayed_work(system_power_efficient_wq, &sync_work,
kernel/time/ntp.c:		queue_delayed_work(system_power_efficient_wq, &sync_work, 0);
kernel/time/ntp.c-			   timespec64_to_jiffies(&next));
kernel/workqueue.c-
kernel/workqueue.c-
kernel/workqueue.c-
kernel/workqueue.c-
kernel/workqueue.c-
kernel/workqueue.c-
kernel/workqueue.c-
kernel/workqueue.c-
kernel/workqueue.c-
kernel/workqueue.c-
kernel/workqueue.c-
kernel/workqueue.c-
kernel/workqueue.c-
kernel/workqueue.c-
kernel/workqueue.c-
kernel/workqueue.c-
kernel/workqueue.c-
kernel/workqueue.c-
kernel/workqueue.c-
kernel/workqueue.c-
kernel/workqueue.c-
kernel/workqueue.c-
kernel/workqueue.c-
kernel/workqueue.c-
kernel/workqueue.c-
kernel/workqueue.c-
kernel/workqueue.c-
kernel/workqueue.c-
kernel/workqueue.c-
kernel/workqueue.c-
kernel/workqueue.c-
kernel/workqueue.c-/*
kernel/workqueue.c-/**
kernel/workqueue.c-/**
kernel/workqueue.c-/**
kernel/workqueue.c-/**
kernel/workqueue.c-/**
kernel/workqueue.c-/**
kernel/workqueue.c-/**
kernel/workqueue.c-{
kernel/workqueue.c-{
kernel/workqueue.c-{
kernel/workqueue.c-{
kernel/workqueue.c-{
kernel/workqueue.c-{
kernel/workqueue.c-{
kernel/workqueue.c-{
kernel/workqueue.c-{
kernel/workqueue.c-{
kernel/workqueue.c-}
kernel/workqueue.c-}
kernel/workqueue.c-}
kernel/workqueue.c-}
kernel/workqueue.c-}
kernel/workqueue.c-}
kernel/workqueue.c-}
kernel/workqueue.c-}
kernel/workqueue.c-}
kernel/workqueue.c- *
kernel/workqueue.c- *
kernel/workqueue.c- *
kernel/workqueue.c- *
kernel/workqueue.c- *
kernel/workqueue.c- *
kernel/workqueue.c- *
kernel/workqueue.c- *
kernel/workqueue.c- *
kernel/workqueue.c- *
kernel/workqueue.c- *
kernel/workqueue.c- *
kernel/workqueue.c- */
kernel/workqueue.c- */
kernel/workqueue.c- */
kernel/workqueue.c- */
kernel/workqueue.c- */
kernel/workqueue.c- */
kernel/workqueue.c-	}
kernel/workqueue.c-	}
kernel/workqueue.c-	}
kernel/workqueue.c-	}
kernel/workqueue.c-	 */
kernel/workqueue.c-		/*
kernel/workqueue.c-		 */
kernel/workqueue.c:bool cancel_delayed_work(struct delayed_work *dwork)
kernel/workqueue.c:bool cancel_delayed_work_sync(struct delayed_work *dwork)
kernel/workqueue.c-bool cancel_work(struct work_struct *work)
kernel/workqueue.c-		bool comma = false;
kernel/workqueue.c:bool flush_delayed_work(struct delayed_work *dwork)
kernel/workqueue.c:bool mod_delayed_work_on(int cpu, struct workqueue_struct *wq,
kernel/workqueue.c:bool queue_delayed_work_on(int cpu, struct workqueue_struct *wq,
kernel/workqueue.c-	 * both optimization and correctness.  The earliest @timer can
kernel/workqueue.c-				break;
kernel/workqueue.c: * cancel_delayed_work - cancel a delayed work
kernel/workqueue.c: * cancel_delayed_work_sync - cancel a delayed work and wait for it to finish
kernel/workqueue.c: * cancel_work_sync(&delayed_work->work) must not be used for
kernel/workqueue.c-			comma = !(*work_data_bits(work) & WORK_STRUCT_LINKED);
kernel/workqueue.c- * @cpu: CPU number to execute work on
kernel/workqueue.c- * @cpu: CPU number to execute work on
kernel/workqueue.c-	debug_object_free(&work->work, &work_debug_descr);
kernel/workqueue.c: * delayed_work's.  Use cancel_delayed_work_sync() instead.
kernel/workqueue.c- * @delay: number of jiffies to wait before queueing
kernel/workqueue.c-	destroy_timer_on_stack(&work->timer);
kernel/workqueue.c: * disabled on entry.  This, combined with delayed_work->timer being
kernel/workqueue.c:		drained = !pwq->nr_active && list_empty(&pwq->delayed_works);
kernel/workqueue.c: * @dwork: delayed_work to cancel
kernel/workqueue.c- * @dwork: the delayed work cancel
kernel/workqueue.c- * @dwork: the delayed work to flush
kernel/workqueue.c-#else
kernel/workqueue.c-	} else {
kernel/workqueue.c- * execution.
kernel/workqueue.c:	 * expire is on the closest next tick and delayed_work users depend
kernel/workqueue.c:EXPORT_SYMBOL(cancel_delayed_work);
kernel/workqueue.c:EXPORT_SYMBOL(cancel_delayed_work_sync);
kernel/workqueue.c-EXPORT_SYMBOL(cancel_work);
kernel/workqueue.c:EXPORT_SYMBOL(delayed_work_timer_fn);
kernel/workqueue.c-EXPORT_SYMBOL(destroy_work_on_stack);
kernel/workqueue.c:EXPORT_SYMBOL(flush_delayed_work);
kernel/workqueue.c:EXPORT_SYMBOL_GPL(destroy_delayed_work_on_stack);
kernel/workqueue.c:EXPORT_SYMBOL(mod_delayed_work_on);
kernel/workqueue.c:EXPORT_SYMBOL(queue_delayed_work_on);
kernel/workqueue.c-EXPORT_SYMBOL(queue_work_on);
kernel/workqueue.c- * %false if it was already idle.
kernel/workqueue.c- * @flags: place to store irq state
kernel/workqueue.c: * flush_delayed_work - wait for a dwork to finish executing the last queueing
kernel/workqueue.c-		for_each_pwq(pwq, wq) {
kernel/workqueue.c-		for_each_pwq(pwq, wq) {
kernel/workqueue.c- * guaranteed to be not pending or executing on any CPU.
kernel/workqueue.c-				idle = false;
kernel/workqueue.c-	 * If @delay is 0, queue @dwork->work immediately.  This is for
kernel/workqueue.c: * If @dwork is idle, equivalent to queue_delayed_work_on(); otherwise,
kernel/workqueue.c-	if (is_dwork) {
kernel/workqueue.c-	if (likely(ret >= 0)) {
kernel/workqueue.c:	if (!list_empty(&pwq->delayed_works)) {
kernel/workqueue.c:	if (!list_empty(&pwq->delayed_works)) {
kernel/workqueue.c:			if (pwq->nr_active || !list_empty(&pwq->delayed_works))
kernel/workqueue.c:			if (pwq->nr_active || !list_empty(&pwq->delayed_works)) {
kernel/workqueue.c-		if (pwq->nr_active < pwq->max_active)
kernel/workqueue.c-	if (!test_and_set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(work))) {
kernel/workqueue.c-		if (WARN_ON((pwq != wq->dfl_pwq) && (pwq->refcnt > 1)) ||
kernel/workqueue.c-		if (*work_data_bits(work) & WORK_STRUCT_DELAYED)
kernel/workqueue.c:	INIT_LIST_HEAD(&pwq->delayed_works);
kernel/workqueue.c-	INIT_LIST_HEAD(&pwq->mayday_node);
kernel/workqueue.c-	INIT_LIST_HEAD(&pwq->pwqs_node);
kernel/workqueue.c- * interrupted while holding PENDING and @work off queue, irq must be
kernel/workqueue.c-	int			max_active;	/* L: max active works */
kernel/workqueue.c-	int			nr_active;	/* L: nr of active works */
kernel/workqueue.c- * irqsafe, ensures that we return -EAGAIN for finite short period of time.
kernel/workqueue.c: * @is_dwork: @work is a delayed_work
kernel/workqueue.c- * it returns %true and the work doesn't re-arm itself.  Explicitly flush or
kernel/workqueue.c: * Kill off a pending delayed_work.
kernel/workqueue.c-		list_del_init(&work->entry);
kernel/workqueue.c:		list_for_each_entry(work, &pwq->delayed_works, entry) {
kernel/workqueue.c-	local_irq_disable();
kernel/workqueue.c-		local_irq_restore(flags);
kernel/workqueue.c: * mod_delayed_work_on - modify delay of or queue a delayed work on specific CPU
kernel/workqueue.c- * modify @dwork's timer so that it expires after @delay.  If @delay is
kernel/workqueue.c-			mutex_unlock(&wq->mutex);
kernel/workqueue.c- * On >= 0 return, the caller owns @work's PENDING bit.  To avoid getting
kernel/workqueue.c-		/* one down, submit a delayed one */
kernel/workqueue.c-	 * on that there's no such delay when @delay is 0.
kernel/workqueue.c- * pool->worklist.
kernel/workqueue.c-			pr_cont_work(comma, work);
kernel/workqueue.c-		pr_info("    delayed:");
kernel/workqueue.c:	pwq_activate_delayed_work(work);
kernel/workqueue.c:			pwq_activate_delayed_work(work);
kernel/workqueue.c-			pwq_activate_first_delayed(pwq);
kernel/workqueue.c-	pwq->flush_color = -1;
kernel/workqueue.c-		pwq->max_active = wq->saved_max_active;
kernel/workqueue.c-	pwq->nr_active--;
kernel/workqueue.c-		       pwq->nr_active < pwq->max_active)
kernel/workqueue.c-	pwq->refcnt = 1;
kernel/workqueue.c-		pwq = unbound_pwq_by_node(wq, cpu_to_node(cpu));
kernel/workqueue.c:		__queue_delayed_work(cpu, wq, dwork, delay);
kernel/workqueue.c:		__queue_delayed_work(cpu, wq, dwork, delay);
kernel/workqueue.c: * queue_delayed_work_on - queue work on specific CPU after delay
kernel/workqueue.c-	__queue_work(dwork->cpu, dwork->wq, &dwork->work);
kernel/workqueue.c-	rcu_read_unlock_sched();
kernel/workqueue.c:	ret = !list_empty(&pwq->delayed_works);
kernel/workqueue.c-		ret = true;
kernel/workqueue.c-	return __cancel_work(&dwork->work, true);
kernel/workqueue.c-	return __cancel_work_timer(&dwork->work, true);
kernel/workqueue.c-	return flush_work(&dwork->work);
kernel/workqueue.c-	return ret;
kernel/workqueue.c-	return ret;
kernel/workqueue.c- * Return: %true if @dwork was pending and canceled; %false if it wasn't
kernel/workqueue.c: * See cancel_delayed_work()
kernel/workqueue.c- * See try_to_grab_pending() for details.
kernel/workqueue.c-	/* should have been called from irqsafe timer with irq already off */
kernel/workqueue.c-				show_pwq(pwq);
kernel/workqueue.c-			show_workqueue_state();
kernel/workqueue.c-		spin_lock_irq(&pwq->pool->lock);
kernel/workqueue.c-			spin_lock_irqsave(&pwq->pool->lock, flags);
kernel/workqueue.c-		spin_unlock_irq(&pwq->pool->lock);
kernel/workqueue.c-			spin_unlock_irqrestore(&pwq->pool->lock, flags);
kernel/workqueue.c- * Start freezing workqueues.  After this function returns, all freezable
kernel/workqueue.c-static bool __cancel_work(struct work_struct *work, bool is_dwork)
kernel/workqueue.c:static void pwq_activate_delayed_work(struct work_struct *work)
kernel/workqueue.c-static void pwq_activate_first_delayed(struct pool_workqueue *pwq)
kernel/workqueue.c:static void __queue_delayed_work(int cpu, struct workqueue_struct *wq,
kernel/workqueue.c:	struct delayed_work *dwork = from_timer(dwork, t, timer);
kernel/workqueue.c:		struct delayed_work *dwork = to_delayed_work(work);
kernel/workqueue.c:			   struct delayed_work *dwork, unsigned long delay)
kernel/workqueue.c:			 struct delayed_work *dwork, unsigned long delay)
kernel/workqueue.c:				struct delayed_work *dwork, unsigned long delay)
kernel/workqueue.c:	struct list_head	delayed_works;	/* L: delayed works */
kernel/workqueue.c-	struct list_head	mayday_node;	/* MD: node on wq->maydays */
kernel/workqueue.c-	struct list_head	pwqs_node;	/* WR: node on wq->pwqs */
kernel/workqueue.c-	struct pool_workqueue *pwq = get_work_pwq(work);
kernel/workqueue.c-	struct timer_list *timer = &dwork->timer;
kernel/workqueue.c-						    struct work_struct, entry);
kernel/workqueue.c-	struct work_struct *work = &dwork->work;
kernel/workqueue.c:	struct work_struct *work = list_first_entry(&pwq->delayed_works,
kernel/workqueue.c- * The caller must ensure that the workqueue on which @work was last
kernel/workqueue.c- * The work callback function may still be running on return, unless
kernel/workqueue.c- * This function is safe to call from any context including IRQ handler.
kernel/workqueue.c- * %true if @dwork was pending, %false otherwise.
kernel/workqueue.c- * try_to_grab_pending - steal work item from worklist and disable irq
kernel/workqueue.c-	/* try to steal the timer if it exists */
kernel/workqueue.c-	unsigned long flags;
kernel/workqueue.c: * use cancel_delayed_work_sync() to wait on it.
kernel/workqueue.c:void delayed_work_timer_fn(struct timer_list *t)
kernel/workqueue.c:void destroy_delayed_work_on_stack(struct delayed_work *work)
kernel/workqueue.c:		    WARN_ON(!list_empty(&pwq->delayed_works))) {
kernel/workqueue.c-	WARN_ON_ONCE(!list_empty(&work->entry));
kernel/workqueue.c:	WARN_ON_ONCE(timer->function != delayed_work_timer_fn);
kernel/workqueue.c-	WARN_ON_ONCE(timer_pending(timer));
kernel/workqueue.c-	WARN_ON_ONCE(!wq);
kernel/workqueue.c-		    WARN_ON(pwq->nr_active) ||
kernel/workqueue.c:		while (!list_empty(&pwq->delayed_works) &&
kernel/workqueue.c-		work_flags |= WORK_STRUCT_DELAYED;
kernel/workqueue.c:		worklist = &pwq->delayed_works;
kernel/workqueue.c: * workqueues will queue new works to their delayed_works list instead of
kernel/workqueue.c- * @work: work item to steal
kernel/workqueue.c- * @wq: workqueue to use
kernel/workqueue.c- * @wq: workqueue to use
kernel/workqueue.c- * zero, @work is guaranteed to be scheduled immediately regardless of its
MachinexChangeLog-
MachinexChangeLog-
MachinexChangeLog-
MachinexChangeLog-2017-10-01  robcore <robpatershuk@gmail.com>
MachinexChangeLog-	* drivers/cpufreq/mx_hotplug.c, include/linux/workqueue.h,
MachinexChangeLog-	* drivers/net/wireless/bcmdhd/wl_cfg80211.c,
MachinexChangeLog-	for NULL values...catering to my own shitty race conditions
MachinexChangeLog-	include/linux/workqueue.h: create and use mod_scheduled_work which
MachinexChangeLog:	is just a wrapper for mod_delayed_work on the system wq
MachinexChangeLog:	kernel/workqueue.c: modified modify_delayed_work so that it checks
mm/backing-dev.c-
mm/backing-dev.c-
mm/backing-dev.c-
mm/backing-dev.c-
mm/backing-dev.c-}
mm/backing-dev.c-}
mm/backing-dev.c- *
mm/backing-dev.c- */
mm/backing-dev.c-	/*
mm/backing-dev.c-	 */
mm/backing-dev.c-	 * @bdi->bdi_list is empty telling bdi_Writeback_workfn() that @bdi
mm/backing-dev.c:	 * Drain work list and shutdown the delayed_work.  At this point,
mm/backing-dev.c: * earlier. Thus we use queue_delayed_work().
mm/backing-dev.c:	flush_delayed_work(&bdi->wb.dwork);
mm/backing-dev.c-	if (bdi->dev) {
mm/backing-dev.c-	if (test_bit(BDI_registered, &bdi->state))
mm/backing-dev.c-	 * is dying and its work_list needs to be drained no matter what.
mm/backing-dev.c:	mod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);
mm/backing-dev.c:		queue_delayed_work(bdi_wq, &bdi->wb.dwork, timeout);
mm/backing-dev.c-	spin_lock_bh(&bdi->wb_lock);
mm/backing-dev.c-	spin_unlock_bh(&bdi->wb_lock);
mm/backing-dev.c-void bdi_wakeup_thread_delayed(struct backing_dev_info *bdi)
mm/backing-dev.c:	WARN_ON(delayed_work_pending(&bdi->wb.dwork));
mm/backing-dev.c-	WARN_ON(!list_empty(&bdi->work_list));
mm/backing-dev.c- * We have to be careful not to postpone flush work if it is scheduled for
mm/slab.c-
mm/slab.c-
mm/slab.c-
mm/slab.c-
mm/slab.c-
mm/slab.c-{
mm/slab.c-}
mm/slab.c-	}
mm/slab.c-	 */
mm/slab.c:	cancel_delayed_work_sync(&per_cpu(slab_reap_work, cpu));
mm/slab.c-#define BAD_ALIEN_MAGIC 0x01020304ul
mm/slab.c-	if (!mutex_trylock(&slab_mutex))
mm/slab.c-	if (reap_work->work.func == NULL) {
mm/slab.c-		INIT_DEFERRABLE_WORK(reap_work, cache_reap);
mm/slab.c-		init_reap_node(cpu);
mm/slab.c-	int node = numa_mem_id();
mm/slab.c-	/* Now the cache_reaper is guaranteed to be not running. */
mm/slab.c-out:
mm/slab.c-	per_cpu(slab_reap_work, cpu).work.func = NULL;
mm/slab.c-					__round_jiffies_relative(HZ, cpu));
mm/slab.c:		schedule_delayed_work_on(cpu, reap_work,
mm/slab.c:	schedule_delayed_work(work, round_jiffies_relative(REAPTIMEOUT_AC));
mm/slab.c-	/* Set up the next iteration */
mm/slab.c:static DEFINE_PER_CPU(struct delayed_work, slab_reap_work);
mm/slab.c-static inline struct array_cache *cpu_cache_get(struct kmem_cache *cachep)
mm/slab.c-static void start_cpu_timer(int cpu)
mm/slab.c:	struct delayed_work *reap_work = &per_cpu(slab_reap_work, cpu);
mm/slab.c:	struct delayed_work *work = to_delayed_work(w);
mm/slab.c-	struct kmem_cache_node *n;
mm/slab.c-	 * timer.
mm/vmstat.c-
mm/vmstat.c-
mm/vmstat.c-
mm/vmstat.c-{
mm/vmstat.c-{
mm/vmstat.c-{
mm/vmstat.c-}
mm/vmstat.c-}
mm/vmstat.c:	cancel_delayed_work_sync(&per_cpu(vmstat_work, cpu));
mm/vmstat.c-#ifdef CONFIG_SMP
mm/vmstat.c-	INIT_DEFERRABLE_WORK(work, vmstat_update);
mm/vmstat.c-int sysctl_stat_interval __read_mostly = HZ;
mm/vmstat.c-	per_cpu(vmstat_work, cpu).work.func = NULL;
mm/vmstat.c:	queue_delayed_work(vmstat_wq, this_cpu_ptr(&vmstat_work),
mm/vmstat.c-	refresh_cpu_vm_stats();
mm/vmstat.c-	return 0;
mm/vmstat.c-		round_jiffies_relative(sysctl_stat_interval));
mm/vmstat.c:	schedule_delayed_work_on(cpu, work, __round_jiffies_relative(HZ, cpu));
mm/vmstat.c:static DEFINE_PER_CPU(struct delayed_work, vmstat_work);
mm/vmstat.c-static int vmstat_cpu_down_prep(unsigned int cpu)
mm/vmstat.c-static struct workqueue_struct *vmstat_wq;
mm/vmstat.c-static void start_cpu_timer(int cpu)
mm/vmstat.c:	struct delayed_work *work = &per_cpu(vmstat_work, cpu);
net/atm/lec.c-
net/atm/lec.c-
net/atm/lec.c-
net/atm/lec.c-
net/atm/lec.c-
net/atm/lec.c-}
net/atm/lec.c-}
net/atm/lec.c-	/*
net/atm/lec.c:	cancel_delayed_work_sync(&priv->lec_arp_work);
net/atm/lec.c-	INIT_DELAYED_WORK(&priv->lec_arp_work, lec_arp_check_expire);
net/atm/lec.c-	int i;
net/atm/lec.c:	schedule_delayed_work(&priv->lec_arp_work, LEC_ARP_REFRESH_INTERVAL);
net/atm/lec.c:	schedule_delayed_work(&priv->lec_arp_work, LEC_ARP_REFRESH_INTERVAL);
net/atm/lec.c-	spin_lock_init(&priv->lec_arp_lock);
net/atm/lec.c-	spin_unlock_irqrestore(&priv->lec_arp_lock, flags);
net/batman-adv/bat_iv_ogm.c-
net/batman-adv/bat_iv_ogm.c-
net/batman-adv/bat_iv_ogm.c:			   &forw_packet_aggr->delayed_work,
net/batman-adv/bat_iv_ogm.c:	INIT_DELAYED_WORK(&forw_packet_aggr->delayed_work,
net/batman-adv/bat_iv_ogm.c:	queue_delayed_work(bat_event_workqueue,
net/batman-adv/bat_iv_ogm.c-			  send_outstanding_bat_ogm_packet);
net/batman-adv/bat_iv_ogm.c-			   send_time - jiffies);
net/batman-adv/bat_iv_ogm.c-	/* start timer for this packet */
net/batman-adv/originator.c-
net/batman-adv/originator.c-
net/batman-adv/originator.c-
net/batman-adv/originator.c-
net/batman-adv/originator.c-{
net/batman-adv/originator.c-{
net/batman-adv/originator.c-}
net/batman-adv/originator.c-	bat_priv->orig_hash = NULL;
net/batman-adv/originator.c:	cancel_delayed_work_sync(&bat_priv->orig_work);
net/batman-adv/originator.c:		container_of(delayed_work, struct bat_priv, orig_work);
net/batman-adv/originator.c:		container_of(work, struct delayed_work, work);
net/batman-adv/originator.c-	INIT_DELAYED_WORK(&bat_priv->orig_work, purge_orig);
net/batman-adv/originator.c-	_purge_orig(bat_priv);
net/batman-adv/originator.c:	queue_delayed_work(bat_event_workqueue, &bat_priv->orig_work, 1 * HZ);
net/batman-adv/originator.c-		return;
net/batman-adv/originator.c-static void purge_orig(struct work_struct *work)
net/batman-adv/originator.c-	struct bat_priv *bat_priv =
net/batman-adv/originator.c:	struct delayed_work *delayed_work =
net/batman-adv/send.c-
net/batman-adv/send.c-
net/batman-adv/send.c-
net/batman-adv/send.c-
net/batman-adv/send.c-{
net/batman-adv/send.c-{
net/batman-adv/send.c-}
net/batman-adv/send.c-		 */
net/batman-adv/send.c-		 */
net/batman-adv/send.c:		container_of(delayed_work, struct forw_packet, delayed_work);
net/batman-adv/send.c:		container_of(delayed_work, struct forw_packet, delayed_work);
net/batman-adv/send.c:		container_of(work, struct delayed_work, work);
net/batman-adv/send.c:		container_of(work, struct delayed_work, work);
net/batman-adv/send.c-		 * delete the item from the list
net/batman-adv/send.c-		 * delete the item from the list
net/batman-adv/send.c:	INIT_DELAYED_WORK(&forw_packet->delayed_work,
net/batman-adv/send.c:		pending = cancel_delayed_work_sync(&forw_packet->delayed_work);
net/batman-adv/send.c:		pending = cancel_delayed_work_sync(&forw_packet->delayed_work);
net/batman-adv/send.c:	queue_delayed_work(bat_event_workqueue, &forw_packet->delayed_work,
net/batman-adv/send.c-			  send_outstanding_bcast_packet);
net/batman-adv/send.c-			   send_time);
net/batman-adv/send.c-		spin_lock_bh(&bat_priv->forw_bat_list_lock);
net/batman-adv/send.c-		spin_lock_bh(&bat_priv->forw_bcast_list_lock);
net/batman-adv/send.c-	/* start timer for this packet */
net/batman-adv/send.c-	struct bat_priv *bat_priv;
net/batman-adv/send.c:	struct delayed_work *delayed_work =
net/batman-adv/send.c:	struct delayed_work *delayed_work =
net/batman-adv/send.c-	struct forw_packet *forw_packet =
net/batman-adv/send.c-	struct forw_packet *forw_packet =
net/batman-adv/send.c-	struct hard_iface *hard_iface;
net/batman-adv/send.c-	struct net_device *soft_iface = forw_packet->if_incoming->soft_iface;
net/batman-adv/send.c-	struct sk_buff *skb1;
net/batman-adv/send.c-void send_outstanding_bat_ogm_packet(struct work_struct *work)
net/batman-adv/translation-table.c-
net/batman-adv/translation-table.c-
net/batman-adv/translation-table.c-{
net/batman-adv/translation-table.c-{
net/batman-adv/translation-table.c-{
net/batman-adv/translation-table.c-}
net/batman-adv/translation-table.c:	cancel_delayed_work_sync(&bat_priv->tt_work);
net/batman-adv/translation-table.c:		container_of(delayed_work, struct bat_priv, tt_work);
net/batman-adv/translation-table.c:		container_of(work, struct delayed_work, work);
net/batman-adv/translation-table.c-	INIT_DELAYED_WORK(&bat_priv->tt_work, tt_purge);
net/batman-adv/translation-table.c-			   msecs_to_jiffies(5000));
net/batman-adv/translation-table.c:	queue_delayed_work(bat_event_workqueue, &bat_priv->tt_work,
net/batman-adv/translation-table.c-static void tt_purge(struct work_struct *work)
net/batman-adv/translation-table.c-	struct bat_priv *bat_priv =
net/batman-adv/translation-table.c:	struct delayed_work *delayed_work =
net/batman-adv/translation-table.c-	tt_local_purge(bat_priv);
net/batman-adv/translation-table.c-	tt_local_table_free(bat_priv);
net/batman-adv/translation-table.c-void tt_free(struct bat_priv *bat_priv)
net/batman-adv/vis.c-
net/batman-adv/vis.c-
net/batman-adv/vis.c-
net/batman-adv/vis.c-{
net/batman-adv/vis.c-{
net/batman-adv/vis.c-}
net/batman-adv/vis.c:	cancel_delayed_work_sync(&bat_priv->vis_work);
net/batman-adv/vis.c:		container_of(delayed_work, struct bat_priv, vis_work);
net/batman-adv/vis.c:		container_of(work, struct delayed_work, work);
net/batman-adv/vis.c-	INIT_DELAYED_WORK(&bat_priv->vis_work, send_vis_packets);
net/batman-adv/vis.c-			   msecs_to_jiffies(VIS_INTERVAL));
net/batman-adv/vis.c:	queue_delayed_work(bat_event_workqueue, &bat_priv->vis_work,
net/batman-adv/vis.c-		return;
net/batman-adv/vis.c-	spin_lock_bh(&bat_priv->vis_hash_lock);
net/batman-adv/vis.c-static void send_vis_packets(struct work_struct *work)
net/batman-adv/vis.c-	struct bat_priv *bat_priv =
net/batman-adv/vis.c:	struct delayed_work *delayed_work =
net/batman-adv/vis.c-	struct vis_info *info;
net/bluetooth/hci_conn.c-
net/bluetooth/hci_conn.c-
net/bluetooth/hci_conn.c-{
net/bluetooth/hci_conn.c-{
net/bluetooth/hci_conn.c-}
net/bluetooth/hci_conn.c-	}
net/bluetooth/hci_conn.c-	BT_DBG("conn %p", conn);
net/bluetooth/hci_conn.c-	BT_DBG("conn %p, pending %d", conn,
net/bluetooth/hci_conn.c:	cancel_delayed_work(&conn->rssi_update_work);
net/bluetooth/hci_conn.c:	cancel_delayed_work(&conn->rssi_update_work);
net/bluetooth/hci_conn.c-		container_of(delayed, struct hci_conn, rssi_update_work);
net/bluetooth/hci_conn.c:		container_of(work, struct delayed_work, work);
net/bluetooth/hci_conn.c:			delayed_work_pending(&conn->rssi_update_work));
net/bluetooth/hci_conn.c-	del_timer(&conn->disc_timer);
net/bluetooth/hci_conn.c-	del_timer(&conn->encrypt_pause_timer);
net/bluetooth/hci_conn.c-	del_timer(&conn->smp_timer);
net/bluetooth/hci_conn.c:	if (!delayed_work_pending(&conn->rssi_update_work)) {
net/bluetooth/hci_conn.c-				msecs_to_jiffies(interval));
net/bluetooth/hci_conn.c:		queue_delayed_work(hdev->workqueue, &conn->rssi_update_work,
net/bluetooth/hci_conn.c-static void hci_conn_rssi_update(struct work_struct *work)
net/bluetooth/hci_conn.c:	struct delayed_work *delayed =
net/bluetooth/hci_conn.c-	struct hci_conn *conn =
net/bluetooth/hci_conn.c-	struct hci_dev *hdev = conn->hdev;
net/bluetooth/l2cap_core.c-
net/bluetooth/l2cap_core.c-
net/bluetooth/l2cap_core.c-
net/bluetooth/l2cap_core.c-
net/bluetooth/l2cap_core.c-
net/bluetooth/l2cap_core.c-
net/bluetooth/l2cap_core.c-
net/bluetooth/l2cap_core.c-{
net/bluetooth/l2cap_core.c-{
net/bluetooth/l2cap_core.c-{
net/bluetooth/l2cap_core.c-{
net/bluetooth/l2cap_core.c-{
net/bluetooth/l2cap_core.c-{
net/bluetooth/l2cap_core.c-{
net/bluetooth/l2cap_core.c-{
net/bluetooth/l2cap_core.c-}
net/bluetooth/l2cap_core.c-}
net/bluetooth/l2cap_core.c-}
net/bluetooth/l2cap_core.c-}
net/bluetooth/l2cap_core.c-	}
net/bluetooth/l2cap_core.c-	}
net/bluetooth/l2cap_core.c-	}
net/bluetooth/l2cap_core.c-	}
net/bluetooth/l2cap_core.c-	}
net/bluetooth/l2cap_core.c-	}
net/bluetooth/l2cap_core.c-		}
net/bluetooth/l2cap_core.c:	BT_DBG("pi %p, pending %d", pi, delayed_work_pending(&pi->ack_work));
net/bluetooth/l2cap_core.c-	BT_DBG("pi %p", pi);
net/bluetooth/l2cap_core.c-	BT_DBG("pi %p", pi);
net/bluetooth/l2cap_core.c-	BT_DBG("pi %p", pi);
net/bluetooth/l2cap_core.c-	BT_DBG("pi %p", pi);
net/bluetooth/l2cap_core.c:		cancel_delayed_work(&l2cap_pi(sk)->ack_work);
net/bluetooth/l2cap_core.c:		cancel_delayed_work(&l2cap_pi(sk)->ack_work);
net/bluetooth/l2cap_core.c:			cancel_delayed_work(&l2cap_pi(sk)->ack_work);
net/bluetooth/l2cap_core.c:		cancel_delayed_work(&l2cap_pi(sk)->monitor_work);
net/bluetooth/l2cap_core.c:		cancel_delayed_work(&l2cap_pi(sk)->monitor_work);
net/bluetooth/l2cap_core.c:			cancel_delayed_work(&l2cap_pi(sk)->monitor_work);
net/bluetooth/l2cap_core.c:		cancel_delayed_work(&l2cap_pi(sk)->retrans_work);
net/bluetooth/l2cap_core.c:		cancel_delayed_work(&l2cap_pi(sk)->retrans_work);
net/bluetooth/l2cap_core.c:			cancel_delayed_work(&l2cap_pi(sk)->retrans_work);
net/bluetooth/l2cap_core.c:	cancel_delayed_work(&pi->ack_work);
net/bluetooth/l2cap_core.c:	cancel_delayed_work(&pi->monitor_work);
net/bluetooth/l2cap_core.c:	cancel_delayed_work(&pi->retrans_work);
net/bluetooth/l2cap_core.c-		container_of(delayed, struct l2cap_pinfo, ack_work);
net/bluetooth/l2cap_core.c-		container_of(delayed, struct l2cap_pinfo, monitor_work);
net/bluetooth/l2cap_core.c-		container_of(delayed, struct l2cap_pinfo, retrans_work);
net/bluetooth/l2cap_core.c:		container_of(work, struct delayed_work, work);
net/bluetooth/l2cap_core.c:		container_of(work, struct delayed_work, work);
net/bluetooth/l2cap_core.c:		container_of(work, struct delayed_work, work);
net/bluetooth/l2cap_core.c:	if (!delayed_work_pending(&pi->ack_work)) {
net/bluetooth/l2cap_core.c:	if (!delayed_work_pending(&pi->monitor_work) && pi->retrans_timeout) {
net/bluetooth/l2cap_core.c-	if (pi->monitor_timeout) {
net/bluetooth/l2cap_core.c-	l2cap_ertm_stop_retrans_timer(pi);
net/bluetooth/l2cap_core.c-				msecs_to_jiffies(L2CAP_DEFAULT_ACK_TO));
net/bluetooth/l2cap_core.c-				msecs_to_jiffies(pi->monitor_timeout));
net/bluetooth/l2cap_core.c-			msecs_to_jiffies(pi->retrans_timeout));
net/bluetooth/l2cap_core.c:		queue_delayed_work(_l2cap_wq, &pi->ack_work,
net/bluetooth/l2cap_core.c:		queue_delayed_work(_l2cap_wq, &pi->monitor_work,
net/bluetooth/l2cap_core.c:		queue_delayed_work(_l2cap_wq, &pi->retrans_work,
net/bluetooth/l2cap_core.c-		skb_queue_purge(SREJ_QUEUE(sk));
net/bluetooth/l2cap_core.c-		skb_queue_purge(SREJ_QUEUE(sk));
net/bluetooth/l2cap_core.c-			skb_queue_purge(SREJ_QUEUE(sk));
net/bluetooth/l2cap_core.c-static inline void l2cap_ertm_start_ack_timer(struct l2cap_pinfo *pi)
net/bluetooth/l2cap_core.c-static void l2cap_ertm_ack_timeout(struct work_struct *work)
net/bluetooth/l2cap_core.c-static void l2cap_ertm_monitor_timeout(struct work_struct *work)
net/bluetooth/l2cap_core.c-static void l2cap_ertm_retrans_timeout(struct work_struct *work)
net/bluetooth/l2cap_core.c:	struct delayed_work *delayed =
net/bluetooth/l2cap_core.c:	struct delayed_work *delayed =
net/bluetooth/l2cap_core.c:	struct delayed_work *delayed =
net/bluetooth/l2cap_core.c-	struct l2cap_pinfo *pi =
net/bluetooth/l2cap_core.c-	struct l2cap_pinfo *pi =
net/bluetooth/l2cap_core.c-	struct l2cap_pinfo *pi =
net/ceph/messenger.c-
net/ceph/messenger.c-	}
net/ceph/messenger.c:	cancel_delayed_work(&con->work);
net/ceph/messenger.c-	con_close_socket(con);
net/ceph/messenger.c-		con->ops->put(con);
net/ceph/messenger.c-	con->peer_global_seq = 0;
net/ceph/messenger.c-		dout("%s %p - already queued\n", __func__, con);
net/ceph/messenger.c:	if (!queue_delayed_work(ceph_msgr_wq, &con->work, delay)) {
net/ceph/messenger.c-	mutex_unlock(&con->mutex);
net/ceph/messenger.c-	reset_connection(con);
net/ceph/mon_client.c-
net/ceph/mon_client.c-
net/ceph/mon_client.c-
net/ceph/mon_client.c-
net/ceph/mon_client.c-{
net/ceph/mon_client.c-{
net/ceph/mon_client.c-}
net/ceph/mon_client.c- */
net/ceph/mon_client.c:	cancel_delayed_work_sync(&monc->delayed_work);
net/ceph/mon_client.c:		container_of(work, struct ceph_mon_client, delayed_work.work);
net/ceph/mon_client.c-		delay = 20 * HZ;
net/ceph/mon_client.c:	dout("monc delayed_work\n");
net/ceph/mon_client.c-	dout("__schedule_delayed after %u\n", delay);
net/ceph/mon_client.c-	dout("stop\n");
net/ceph/mon_client.c- * got an ENOMEM).  And keep the monitor connection alive.
net/ceph/mon_client.c-	if (monc->hunting) {
net/ceph/mon_client.c:	INIT_DELAYED_WORK(&monc->delayed_work, delayed_work);
net/ceph/mon_client.c-	monc->generic_request_tree = RB_ROOT;
net/ceph/mon_client.c-	monc->num_generic_requests = 0;
net/ceph/mon_client.c-	monc->sub_sent = 0;
net/ceph/mon_client.c-	mutex_lock(&monc->mutex);
net/ceph/mon_client.c-	mutex_lock(&monc->mutex);
net/ceph/mon_client.c:	schedule_delayed_work(&monc->delayed_work, delay);
net/ceph/mon_client.c:static void delayed_work(struct work_struct *work)
net/ceph/mon_client.c-	struct ceph_mon_client *monc =
net/ceph/osd_client.c-
net/ceph/osd_client.c-
net/ceph/osd_client.c-
net/ceph/osd_client.c-
net/ceph/osd_client.c-{
net/ceph/osd_client.c-{
net/ceph/osd_client.c-}
net/ceph/osd_client.c-}
net/ceph/osd_client.c-}
net/ceph/osd_client.c:	cancel_delayed_work(&osdc->timeout_work);
net/ceph/osd_client.c:	cancel_delayed_work_sync(&osdc->osds_timeout_work);
net/ceph/osd_client.c:	cancel_delayed_work_sync(&osdc->timeout_work);
net/ceph/osd_client.c-		ceph_osdmap_destroy(osdc->osdmap);
net/ceph/osd_client.c-	destroy_workqueue(osdc->notify_wq);
net/ceph/osd_client.c-	flush_workqueue(osdc->notify_wq);
net/ceph/osd_client.c-	if (osdc->osdmap) {
net/ceph/osd_client.c-			osdc->client->options->osd_keepalive_timeout * HZ);
net/ceph/osd_client.c-	osdc->event_count = 0;
net/ceph/osd_client.c-			      round_jiffies_relative(delay));
net/ceph/osd_client.c-	   round_jiffies_relative(osdc->client->options->osd_idle_ttl * HZ));
net/ceph/osd_client.c:	schedule_delayed_work(&osdc->osds_timeout_work,
net/ceph/osd_client.c:	schedule_delayed_work(&osdc->osds_timeout_work,
net/ceph/osd_client.c:	schedule_delayed_work(&osdc->timeout_work,
net/ceph/osd_client.c-static void __cancel_osd_timeout(struct ceph_osd_client *osdc)
net/ceph/osd_client.c-static void __schedule_osd_timeout(struct ceph_osd_client *osdc)
net/ceph/osd_client.c-	up_read(&osdc->map_sem);
net/core/dst.c-
net/core/dst.c-	}
net/core/dst.c-	}
net/core/dst.c-					dst_garbage.timer_expires);
net/core/dst.c-		dst_garbage.timer_expires = DST_GC_MIN;
net/core/dst.c-		dst_garbage.timer_inc = DST_GC_INC;
net/core/dst.c-			expires = round_jiffies_relative(expires);
net/core/dst.c-		if (expires > 4*HZ)
net/core/dst.c:		queue_delayed_work(system_wq, &dst_gc_work,
net/core/dst.c:		queue_delayed_work(system_wq, &dst_gc_work, expires);
net/core/link_watch.c-
net/core/link_watch.c-}
net/core/link_watch.c-	 */
net/core/link_watch.c-	else
net/core/link_watch.c-	if (test_bit(LW_URGENT, &linkwatch_flags))
net/core/link_watch.c:		mod_delayed_work(system_wq, &linkwatch_work, 0);
net/core/link_watch.c:		schedule_delayed_work(&linkwatch_work, delay);
net/core/neighbour.c-
net/core/neighbour.c-	 */
net/core/neighbour.c-	 * base_reachable_time.
net/core/neighbour.c:	cancel_delayed_work_sync(&tbl->gc_work);
net/core/neighbour.c-	del_timer_sync(&tbl->proxy_timer);
net/core/neighbour.c-	INIT_DEFERRABLE_WORK(&tbl->gc_work, neigh_periodic_work);
net/core/neighbour.c-	/* It is not clean... Fix it to unload IPv6 module safely */
net/core/neighbour.c-	pneigh_queue_purge(&tbl->proxy_queue);
net/core/neighbour.c:	queue_delayed_work(system_wq, &tbl->gc_work,
net/core/neighbour.c:	queue_delayed_work(system_wq, &tbl->gc_work,
net/core/neighbour.c-	rwlock_init(&tbl->lock);
net/core/neighbour.c-			      tbl->parms.base_reachable_time >> 1);
net/core/neighbour.c-			tbl->parms.reachable_time);
net/core/neighbour.c-	timer_setup(&tbl->proxy_timer, neigh_proxy_process, 0);
net/core/neighbour.c-	write_unlock_bh(&tbl->lock);
net/core/netpoll.c-
net/core/netpoll.c-
net/core/netpoll.c-}
net/core/netpoll.c-	}
net/core/netpoll.c-		}
net/core/netpoll.c:		cancel_delayed_work_sync(&npinfo->tx_work);
net/core/netpoll.c-		/* clean after last, unfinished work */
net/core/netpoll.c-	if (status != NETDEV_TX_OK) {
net/core/netpoll.c-			local_irq_restore(flags);
net/core/netpoll.c-			return;
net/core/netpoll.c:		schedule_delayed_work(&npinfo->tx_work,0);
net/core/netpoll.c:			schedule_delayed_work(&npinfo->tx_work, HZ/10);
net/core/netpoll.c-		skb_queue_purge(&npinfo->arp_tx);
net/core/netpoll.c-		skb_queue_purge(&npinfo->txq);
net/core/netpoll.c-		skb_queue_tail(&npinfo->txq, skb);
net/ipv4/inetpeer.c-
net/ipv4/inetpeer.c-
net/ipv4/inetpeer.c-
net/ipv4/inetpeer.c-
net/ipv4/inetpeer.c-
net/ipv4/inetpeer.c-}
net/ipv4/inetpeer.c-}
net/ipv4/inetpeer.c:	schedule_delayed_work(&gc_work, gc_delay);
net/ipv4/inetpeer.c:	schedule_delayed_work(&gc_work, gc_delay);
net/ipv4/inetpeer.c-	spin_unlock_bh(&gc_lock);
net/ipv4/inetpeer.c-	spin_unlock_bh(&gc_lock);
net/ipv4/inetpeer.c-static const int gc_delay = 60 * HZ;
net/ipv4/inetpeer.c-static DEFINE_SPINLOCK(gc_lock);
net/ipv4/inetpeer.c-static LIST_HEAD(gc_list);
net/ipv4/inetpeer.c:static struct delayed_work gc_work;
net/ipv4/route.c-
net/ipv4/route.c-
net/ipv4/route.c-
net/ipv4/route.c-
net/ipv4/route.c-{
net/ipv4/route.c-}
net/ipv4/route.c-	expires_ljiffies = jiffies;
net/ipv4/route.c-	INIT_DEFERRABLE_WORK(&expires_work, rt_worker_func);
net/ipv4/route.c-		net_random() % ip_rt_gc_interval + ip_rt_gc_interval);
net/ipv4/route.c-	rt_check_expire();
net/ipv4/route.c:	schedule_delayed_work(&expires_work,
net/ipv4/route.c:	schedule_delayed_work(&expires_work, ip_rt_gc_interval);
net/ipv4/route.c-static int rt_chain_length_max __read_mostly	= 20;
net/ipv4/route.c:static struct delayed_work expires_work;
net/ipv4/route.c-static unsigned long expires_ljiffies;
net/mac80211/scan.c-
net/mac80211/scan.c-
net/mac80211/scan.c-
net/mac80211/scan.c-
net/mac80211/scan.c-}
net/mac80211/scan.c-	 */
net/mac80211/scan.c-	/* and clean up */
net/mac80211/scan.c:	cancel_delayed_work(&local->scan_work);
net/mac80211/scan.c-EXPORT_SYMBOL(ieee80211_scan_completed);
net/mac80211/scan.c-	goto out;
net/mac80211/scan.c-	ieee80211_hw_config(local, 0);
net/mac80211/scan.c:	ieee80211_queue_delayed_work(&local->hw,
net/mac80211/scan.c:	ieee80211_queue_delayed_work(&local->hw, &local->scan_work, 0);
net/mac80211/scan.c:	ieee80211_queue_delayed_work(&local->hw, &local->scan_work, next_delay);
net/mac80211/scan.c-	__ieee80211_scan_completed(&local->hw, true, false);
net/mac80211/scan.c-	if (aborted)
net/mac80211/scan.c-				     &local->scan_work, 0);
net/mac80211/scan.c-		set_bit(SCAN_ABORTED, &local->scanning);
net/mac80211/scan.c-	 * simply exit once it acquires the mutex.
net/mac80211/scan.c-	} while (next_delay == 0);
net/mac80211/util.c-
net/mac80211/util.c-
net/mac80211/util.c-
net/mac80211/util.c-{
net/mac80211/util.c-}
net/mac80211/util.c:EXPORT_SYMBOL(ieee80211_queue_delayed_work);
net/mac80211/util.c-EXPORT_SYMBOL(ieee80211_queue_work);
net/mac80211/util.c:	queue_delayed_work(local->workqueue, dwork, delay);
net/mac80211/util.c-		return;
net/mac80211/util.c:				  struct delayed_work *dwork,
net/mac80211/util.c-u32 ieee802_11_parse_elems_crc(u8 *start, size_t len,
net/mac80211/util.c-				  unsigned long delay)
net/mac80211/util.c:void ieee80211_queue_delayed_work(struct ieee80211_hw *hw,
net/mac80211/work.c:		ieee80211_queue_delayed_work(&local->hw,
net/mac80211/work.c-	if (list_empty(&local->work_list) && local->scan_req &&
net/mac80211/work.c-	    !local->scanning)
net/mac80211/work.c-					     &local->scan_work,
net/mac80211/work.c-					     round_jiffies_relative(0));
net/netfilter/ipvs/ip_vs_ctl.c-
net/netfilter/ipvs/ip_vs_ctl.c-
net/netfilter/ipvs/ip_vs_ctl.c-}
net/netfilter/ipvs/ip_vs_ctl.c:	cancel_delayed_work_sync(&ipvs->defense_work);
net/netfilter/ipvs/ip_vs_ctl.c-	cancel_work_sync(&ipvs->defense_work.work);
net/netfilter/ipvs/ip_vs_ctl.c-#endif
net/netfilter/ipvs/ip_vs_ctl.c-	if (atomic_read(&ipvs->dropentry))
net/netfilter/ipvs/ip_vs_ctl.c-	INIT_DELAYED_WORK(&ipvs->defense_work, defense_work_handler);
net/netfilter/ipvs/ip_vs_ctl.c-		ip_vs_random_dropentry(ipvs->net);
net/netfilter/ipvs/ip_vs_ctl.c-	return 0;
net/netfilter/ipvs/ip_vs_ctl.c-	/* Schedule defense work */
net/netfilter/ipvs/ip_vs_ctl.c:	schedule_delayed_work(&ipvs->defense_work, DEFENSE_TIMER_PERIOD);
net/netfilter/ipvs/ip_vs_ctl.c:	schedule_delayed_work(&ipvs->defense_work, DEFENSE_TIMER_PERIOD);
net/netfilter/ipvs/ip_vs_ctl.c-	struct netns_ipvs *ipvs = net_ipvs(net);
net/netfilter/ipvs/ip_vs_ctl.c-	unregister_net_sysctl_table(ipvs->sysctl_hdr);
net/netfilter/ipvs/ip_vs_sync.c:		cancel_delayed_work_sync(&ipvs->master_wakeup_work);
net/netfilter/ipvs/ip_vs_sync.c-		if (!ipvs->sync_queue_len)
net/netfilter/ipvs/ip_vs_sync.c-		ipvs->master_thread = NULL;
net/netfilter/ipvs/ip_vs_sync.c-		ipvs->sync_queue_len++;
net/netfilter/ipvs/ip_vs_sync.c-	    ipvs->sync_queue_len < sysctl_sync_qlen_max(ipvs)) {
net/netfilter/ipvs/ip_vs_sync.c-		ipvs->sync_state &= ~IP_VS_STATE_MASTER;
net/netfilter/ipvs/ip_vs_sync.c-					      max(IPVS_SYNC_SEND_DELAY, 1));
net/netfilter/ipvs/ip_vs_sync.c-		retc = kthread_stop(ipvs->master_thread);
net/netfilter/ipvs/ip_vs_sync.c:			schedule_delayed_work(&ipvs->master_wakeup_work,
net/netfilter/ipvs/ip_vs_sync.c-		spin_unlock_bh(&ipvs->sync_lock);
net/openvswitch/datapath.c-
net/openvswitch/datapath.c-
net/openvswitch/datapath.c-
net/openvswitch/datapath.c-
net/openvswitch/datapath.c-{
net/openvswitch/datapath.c-}
net/openvswitch/datapath.c:	cancel_delayed_work_sync(&rehash_flow_wq);
net/openvswitch/datapath.c-	dp_unregister_genl(ARRAY_SIZE(dp_genl_families));
net/openvswitch/datapath.c-	genl_unlock();
net/openvswitch/datapath.c-		goto error_unreg_notifier;
net/openvswitch/datapath.c-	rcu_barrier();
net/openvswitch/datapath.c-	return 0;
net/openvswitch/datapath.c:	schedule_delayed_work(&rehash_flow_wq, REHASH_FLOW_INTERVAL);
net/openvswitch/datapath.c:	schedule_delayed_work(&rehash_flow_wq, REHASH_FLOW_INTERVAL);
net/openvswitch/datapath.c-static void dp_cleanup(void)
net/rds/connection.c-
net/rds/connection.c-
net/rds/connection.c-}
net/rds/connection.c:	cancel_delayed_work_sync(&conn->c_conn_w);
net/rds/connection.c:	cancel_delayed_work_sync(&conn->c_recv_w);
net/rds/connection.c:	cancel_delayed_work_sync(&conn->c_send_w);
net/rds/connection.c-	 * conn - the reconnect is always triggered by the active peer. */
net/rds/connection.c-EXPORT_SYMBOL_GPL(rds_conn_connect_if_down);
net/rds/connection.c-	if (!hlist_unhashed(&conn->c_hash_node)) {
net/rds/connection.c-	if (rds_conn_state(conn) == RDS_CONN_DOWN &&
net/rds/connection.c-	/* make sure lingering queued work won't try to ref the conn */
net/rds/connection.c:		queue_delayed_work(rds_wq, &conn->c_conn_w, 0);
net/rds/connection.c-	rcu_read_lock();
net/rds/connection.c-	/* tear down queued messages */
net/rds/connection.c-	    !test_and_set_bit(RDS_RECONNECT_PENDING, &conn->c_flags))
net/rds/connection.c-	 * to the conn hash, so we never trigger a reconnect on this
net/rds/ib_rdma.c-
net/rds/ib_rdma.c-
net/rds/ib_rdma.c-
net/rds/ib_rdma.c-
net/rds/ib_rdma.c-{
net/rds/ib_rdma.c-	}
net/rds/ib_rdma.c-		}
net/rds/ib_rdma.c-			 * as use_once and invalidate at the same time. */
net/rds/ib_rdma.c-	    atomic_read(&pool->dirty_count) >= pool->max_items / 10)
net/rds/ib_rdma.c-	atomic_t		item_count;		/* total # of MRs */
net/rds/ib_rdma.c:	cancel_delayed_work_sync(&pool->flush_worker);
net/rds/ib_rdma.c-	if (atomic_read(&pool->dirty_count) >= pool->max_items / 10)
net/rds/ib_rdma.c-	if (atomic_read(&pool->free_pinned) >= pool->max_free_pinned ||
net/rds/ib_rdma.c-	if (invalidate) {
net/rds/ib_rdma.c-	rds_ib_flush_mr_pool(pool, 1, NULL);
net/rds/ib_rdma.c:			schedule_delayed_work(&pool->flush_worker, 10);
net/rds/ib_rdma.c:		schedule_delayed_work(&pool->flush_worker, 10);
net/rds/ib_rdma.c:		schedule_delayed_work(&pool->flush_worker, 10);
net/rds/ib_rdma.c:	struct delayed_work	flush_worker;		/* flush worker */
net/rds/ib_rdma.c-	struct mutex		flush_lock;		/* serialize fmr invalidate */
net/rds/ib_rdma.c-struct rds_ib_mr_pool {
net/rds/ib_rdma.c-void rds_ib_destroy_mr_pool(struct rds_ib_mr_pool *pool)
net/rds/ib_rdma.c-	WARN_ON(atomic_read(&pool->item_count));
net/rds/ib_rdma.c-			/* We get here if the user created a MR marked
net/rds/ib_rdma.c-	while (1) {
net/rds/ib_send.c-
net/rds/ib_send.c-
net/rds/ib_send.c-	atomic_add(IB_SET_SEND_CREDITS(credits), &ic->i_credits);
net/rds/ib_send.c-		if (test_and_clear_bit(RDS_LL_SEND_FULL, &conn->c_flags) ||
net/rds/ib_send.c-	if (test_and_clear_bit(RDS_LL_SEND_FULL, &conn->c_flags))
net/rds/ib_send.c:			queue_delayed_work(rds_wq, &conn->c_send_w, 0);
net/rds/ib_send.c:		queue_delayed_work(rds_wq, &conn->c_send_w, 0);
net/rds/ib_send.c-		    test_bit(0, &conn->c_map_queued))
net/rds/ib_send.c-	WARN_ON(IB_GET_SEND_CREDITS(credits) >= 16384);
net/rds/ib_send.c-		/* We expect errors as the qp is drained during shutdown */
net/rds/iw_recv.c-
net/rds/iw_recv.c-}
net/rds/iw_recv.c-	 */
net/rds/iw_recv.c-	if (rds_iw_ring_low(&ic->i_recv_ring))
net/rds/iw_recv.c:		queue_delayed_work(rds_wq, &conn->c_recv_w, 0);
net/rds/iw_send.c-
net/rds/iw_send.c-
net/rds/iw_send.c-	atomic_add(IB_SET_SEND_CREDITS(credits), &ic->i_credits);
net/rds/iw_send.c-		if (test_and_clear_bit(RDS_LL_SEND_FULL, &conn->c_flags) ||
net/rds/iw_send.c-	if (test_and_clear_bit(RDS_LL_SEND_FULL, &conn->c_flags))
net/rds/iw_send.c:			queue_delayed_work(rds_wq, &conn->c_send_w, 0);
net/rds/iw_send.c:		queue_delayed_work(rds_wq, &conn->c_send_w, 0);
net/rds/iw_send.c-		    test_bit(0, &conn->c_map_queued))
net/rds/iw_send.c-	WARN_ON(IB_GET_SEND_CREDITS(credits) >= 16384);
net/rds/iw_send.c-		/* We expect errors as the qp is drained during shutdown */
net/rds/send.c-
net/rds/send.c-
net/rds/send.c-	if (!test_bit(RDS_LL_SEND_FULL, &conn->c_flags))
net/rds/send.c:		queue_delayed_work(rds_wq, &conn->c_send_w, 0);
net/rds/send.c-	rds_message_put(rm);
net/rds/tcp_recv.c-
net/rds/tcp_recv.c-	if (rds_tcp_read_sock(conn, GFP_ATOMIC) == -ENOMEM)
net/rds/tcp_recv.c-out:
net/rds/tcp_recv.c:		queue_delayed_work(rds_wq, &conn->c_recv_w, 0);
net/rds/tcp_recv.c-	read_unlock_bh(&sk->sk_callback_lock);
net/rds/tcp_send.c-
net/rds/tcp_send.c-
net/rds/tcp_send.c-        if ((atomic_read(&sk->sk_wmem_alloc) << 1) <= sk->sk_sndbuf)
net/rds/tcp_send.c-out:
net/rds/tcp_send.c:		queue_delayed_work(rds_wq, &conn->c_send_w, 0);
net/rds/threads.c-
net/rds/threads.c-}
net/rds/threads.c-	}
net/rds/threads.c-			break;
net/rds/threads.c-			break;
net/rds/threads.c-			break;
net/rds/threads.c-			break;
net/rds/threads.c-		case -EAGAIN:
net/rds/threads.c-		case -EAGAIN:
net/rds/threads.c-		case -ENOMEM:
net/rds/threads.c-		case -ENOMEM:
net/rds/threads.c-		 conn, &conn->c_laddr, &conn->c_faddr);
net/rds/threads.c-	conn->c_reconnect_jiffies = 0;
net/rds/threads.c-		conn->c_reconnect_jiffies = rds_sysctl_reconnect_min_jiffies;
net/rds/threads.c-		default:
net/rds/threads.c-		default:
net/rds/threads.c-EXPORT_SYMBOL_GPL(rds_connect_complete);
net/rds/threads.c-	if (conn->c_reconnect_jiffies == 0) {
net/rds/threads.c:	queue_delayed_work(rds_wq, &conn->c_conn_w,
net/rds/threads.c:		queue_delayed_work(rds_wq, &conn->c_conn_w, 0);
net/rds/threads.c:			queue_delayed_work(rds_wq, &conn->c_recv_w, 0);
net/rds/threads.c:	queue_delayed_work(rds_wq, &conn->c_recv_w, 0);
net/rds/threads.c:			queue_delayed_work(rds_wq, &conn->c_recv_w, 2);
net/rds/threads.c:			queue_delayed_work(rds_wq, &conn->c_send_w, 0);
net/rds/threads.c:	queue_delayed_work(rds_wq, &conn->c_send_w, 0);
net/rds/threads.c:			queue_delayed_work(rds_wq, &conn->c_send_w, 2);
net/rds/threads.c-			   rand % conn->c_reconnect_jiffies);
net/rds/threads.c-		 rand % conn->c_reconnect_jiffies, conn->c_reconnect_jiffies,
net/rds/threads.c-			rds_stats_inc(s_recv_delayed_retry);
net/rds/threads.c-			rds_stats_inc(s_recv_immediate_retry);
net/rds/threads.c-			rds_stats_inc(s_send_delayed_retry);
net/rds/threads.c-			rds_stats_inc(s_send_immediate_retry);
net/rds/threads.c-		return;
net/rds/threads.c-	set_bit(0, &conn->c_map_queued);
net/rfkill/core.c-
net/rfkill/core.c-
net/rfkill/core.c-
net/rfkill/core.c-
net/rfkill/core.c-
net/rfkill/core.c-
net/rfkill/core.c-
net/rfkill/core.c-
net/rfkill/core.c-
net/rfkill/core.c-
net/rfkill/core.c-
net/rfkill/core.c-}
net/rfkill/core.c-}
net/rfkill/core.c:	cancel_delayed_work_sync(&rfkill->poll_work);
net/rfkill/core.c:	cancel_delayed_work_sync(&rfkill->poll_work);
net/rfkill/core.c:		cancel_delayed_work_sync(&rfkill->poll_work);
net/rfkill/core.c-	cancel_work_sync(&rfkill->uevent_work);
net/rfkill/core.c-EXPORT_SYMBOL(rfkill_pause_polling);
net/rfkill/core.c-	if (rfkill->ops->poll)
net/rfkill/core.c-	if (rfkill->ops->poll)
net/rfkill/core.c-	if (rfkill->ops->poll && !rfkill->polling_paused)
net/rfkill/core.c:	queue_delayed_work(system_power_efficient_wq,
net/rfkill/core.c:	queue_delayed_work(system_power_efficient_wq,
net/rfkill/core.c:		queue_delayed_work(system_power_efficient_wq,
net/rfkill/core.c:		queue_delayed_work(system_power_efficient_wq,
net/rfkill/core.c-		return;
net/rfkill/core.c-	return 0;
net/rfkill/core.c-	rfkill->ops->poll(rfkill, rfkill->data);
net/rfkill/core.c-	rfkill->polling_paused = true;
net/rfkill/core.c-		&rfkill->poll_work,
net/rfkill/core.c-			&rfkill->poll_work,
net/rfkill/core.c-			   &rfkill->poll_work, 0);
net/rfkill/core.c-				   &rfkill->poll_work, 0);
net/rfkill/core.c-	rfkill->suspended = true;
net/rfkill/core.c-		round_jiffies_relative(POLL_INTERVAL));
net/rfkill/core.c-			round_jiffies_relative(POLL_INTERVAL));
net/rfkill/core.c:	struct delayed_work	poll_work;
net/rfkill/core.c-	struct list_head	node;
net/rfkill/core.c-	struct work_struct	sync_work;
net/rfkill/core.c-	struct work_struct	uevent_work;
net/rfkill/input.c-{
net/rfkill/input.c-{
net/rfkill/input.c-}
net/rfkill/input.c-		/* bypass the limiter for EPO */
net/rfkill/input.c:	cancel_delayed_work_sync(&rfkill_op_work);
net/rfkill/input.c-	} else
net/rfkill/input.c-	if (op == RFKILL_GLOBAL_OP_EPO && !rfkill_is_epo_lock_active()) {
net/rfkill/input.c:	if (schedule_delayed_work(&rfkill_op_work,
net/rfkill/input.c-	input_unregister_handler(&rfkill_handler);
net/rfkill/input.c:		mod_delayed_work(system_wq, &rfkill_op_work, 0);
net/rfkill/input.c-		rfkill_last_scheduled = jiffies;
net/rfkill/input.c-		rfkill_last_scheduled = jiffies;
net/rfkill/input.c-				  rfkill_ratelimit(rfkill_last_scheduled)))
net/rfkill/input.c-static void rfkill_schedule_ratelimited(void)
net/rxrpc/ar-connection.c-
net/rxrpc/ar-connection.c-
net/rxrpc/ar-connection.c-
net/rxrpc/ar-connection.c-	}
net/rxrpc/ar-connection.c-	}
net/rxrpc/ar-connection.c-		ASSERTCMP(earliest, >, now);
net/rxrpc/ar-connection.c:	cancel_delayed_work(&rxrpc_connection_reap);
net/rxrpc/ar-connection.c-		_debug("reschedule reaper %ld", (long) earliest - now);
net/rxrpc/ar-connection.c-		_debug("zombie");
net/rxrpc/ar-connection.c-					 (earliest - now) * HZ);
net/rxrpc/ar-connection.c-	if (atomic_dec_and_test(&conn->usage)) {
net/rxrpc/ar-connection.c-	_leave("");
net/rxrpc/ar-connection.c-	rxrpc_connection_timeout = 0;
net/rxrpc/ar-connection.c:		rxrpc_queue_delayed_work(&rxrpc_connection_reap,
net/rxrpc/ar-connection.c:		rxrpc_queue_delayed_work(&rxrpc_connection_reap, 0);
net/rxrpc/ar-connection.c:	rxrpc_queue_delayed_work(&rxrpc_connection_reap, 0);
net/rxrpc/ar-internal.h-
net/rxrpc/ar-internal.h-
net/rxrpc/ar-internal.h-#define rxrpc_queue_call(CALL)	rxrpc_queue_work(&(CALL)->processor)
net/rxrpc/ar-internal.h:#define rxrpc_queue_delayed_work(WS,D)	\
net/rxrpc/ar-internal.h-#define rxrpc_queue_work(WS)	queue_work(rxrpc_workqueue, (WS))
net/rxrpc/ar-internal.h:	queue_delayed_work(rxrpc_workqueue, (WS), (D))
net/rxrpc/ar-transport.c-
net/rxrpc/ar-transport.c-
net/rxrpc/ar-transport.c-	}
net/rxrpc/ar-transport.c-	}
net/rxrpc/ar-transport.c-		ASSERTCMP(earliest, >, now);
net/rxrpc/ar-transport.c:	cancel_delayed_work(&rxrpc_transport_reap);
net/rxrpc/ar-transport.c-		_debug("reschedule reaper %ld", (long) earliest - now);
net/rxrpc/ar-transport.c-					 (earliest - now) * HZ);
net/rxrpc/ar-transport.c-	_leave("");
net/rxrpc/ar-transport.c-	_leave("");
net/rxrpc/ar-transport.c-		 * overextending the timeout if the reaper is running at the
net/rxrpc/ar-transport.c:		rxrpc_queue_delayed_work(&rxrpc_transport_reap,
net/rxrpc/ar-transport.c:		rxrpc_queue_delayed_work(&rxrpc_transport_reap, 0);
net/rxrpc/ar-transport.c:	rxrpc_queue_delayed_work(&rxrpc_transport_reap, 0);
net/rxrpc/ar-transport.c-	rxrpc_transport_timeout = 0;
net/rxrpc/ar-transport.c-		 * same time */
net/sunrpc/cache.c-
net/sunrpc/cache.c-
net/sunrpc/cache.c-
net/sunrpc/cache.c-
net/sunrpc/cache.c-
net/sunrpc/cache.c-}
net/sunrpc/cache.c-}
net/sunrpc/cache.c-	}
net/sunrpc/cache.c:		cancel_delayed_work_sync(&cache_cleaner);
net/sunrpc/cache.c-EXPORT_SYMBOL_GPL(sunrpc_init_cache_detail);
net/sunrpc/cache.c-	if (delay)
net/sunrpc/cache.c-	if (list_empty(&cache_list)) {
net/sunrpc/cache.c-		/* module must be being unloaded so its safe to kill the worker */
net/sunrpc/cache.c-	return;
net/sunrpc/cache.c:	schedule_delayed_work(&cache_cleaner, 0);
net/sunrpc/cache.c:		schedule_delayed_work(&cache_cleaner, delay);
net/sunrpc/cache.c-	/* start the cleaning process */
net/sunrpc/cache.c:static struct delayed_work cache_cleaner;
net/sunrpc/cache.c-static void do_cache_clean(struct work_struct *work);
net/sunrpc/cache.c-void sunrpc_init_cache_detail(struct cache_detail *cd)
net/sunrpc/rpc_pipe.c:	cancel_delayed_work_sync(&pipe->queue_timeout);
net/sunrpc/rpc_pipe.c-	} else if (pipe->flags & RPC_PIPE_WAIT_FOR_OPEN) {
net/sunrpc/rpc_pipe.c-		if (list_empty(&pipe->pipe))
net/sunrpc/rpc_pipe.c-	if (need_release && pipe->ops->release_pipe)
net/sunrpc/rpc_pipe.c-		pipe->ops->release_pipe(inode);
net/sunrpc/rpc_pipe.c-					&pipe->queue_timeout,
net/sunrpc/rpc_pipe.c:			queue_delayed_work(rpciod_workqueue,
net/sunrpc/rpc_pipe.c-	RPC_I(inode)->pipe = NULL;
net/sunrpc/rpc_pipe.c-	rpc_inode_setowner(inode, NULL);
net/sunrpc/rpc_pipe.c-					RPC_UPCALL_TIMEOUT);
net/sunrpc/xprtrdma/transport.c-
net/sunrpc/xprtrdma/transport.c-
net/sunrpc/xprtrdma/transport.c-}
net/sunrpc/xprtrdma/transport.c-	}
net/sunrpc/xprtrdma/transport.c:	cancel_delayed_work_sync(&r_xprt->rdma_connect);
net/sunrpc/xprtrdma/transport.c-	dprintk("RPC:       %s: called\n", __func__);
net/sunrpc/xprtrdma/transport.c-	} else {
net/sunrpc/xprtrdma/transport.c:			flush_delayed_work(&r_xprt->rdma_connect);
net/sunrpc/xprtrdma/transport.c-		if (!RPC_IS_ASYNC(task))
net/sunrpc/xprtrdma/transport.c-	if (r_xprt->rx_ep.rep_connected != 0) {
net/sunrpc/xprtrdma/transport.c-		/* Reconnect */
net/sunrpc/xprtrdma/transport.c:		schedule_delayed_work(&r_xprt->rdma_connect,
net/sunrpc/xprtrdma/transport.c:		schedule_delayed_work(&r_xprt->rdma_connect, 0);
net/sunrpc/xprtrdma/transport.c-	xprt_clear_connected(xprt);
net/sunrpc/xprtrdma/transport.c-			xprt->reestablish_timeout);
net/sunrpc/xprtrdma/transport.c-		xprt->reestablish_timeout <<= 1;
net/sunrpc/xprtrdma/transport.c-			xprt->reestablish_timeout = (5 * HZ);
net/sunrpc/xprtsock.c-
net/sunrpc/xprtsock.c-
net/sunrpc/xprtsock.c-
net/sunrpc/xprtsock.c-}
net/sunrpc/xprtsock.c-	}
net/sunrpc/xprtsock.c-	 */
net/sunrpc/xprtsock.c:	cancel_delayed_work_sync(&transport->connect_worker);
net/sunrpc/xprtsock.c:	    !cancel_delayed_work(&transport->connect_worker))
net/sunrpc/xprtsock.c-	clear_bit(XPRT_CONNECTION_ABORT, &xprt->state);
net/sunrpc/xprtsock.c-	 * Connection of transports
net/sunrpc/xprtsock.c-		dprintk("RPC:       xs_connect scheduled xprt %p\n", xprt);
net/sunrpc/xprtsock.c-	dprintk("RPC:       xs_destroy xprt %p\n", xprt);
net/sunrpc/xprtsock.c-	} else {
net/sunrpc/xprtsock.c-	if (!test_bit(XPRT_CONNECTION_ABORT, &xprt->state) ||
net/sunrpc/xprtsock.c:		queue_delayed_work(rpciod_workqueue,
net/sunrpc/xprtsock.c:		queue_delayed_work(rpciod_workqueue,
net/sunrpc/xprtsock.c:	queue_delayed_work(rpciod_workqueue, &transport->connect_worker,
net/sunrpc/xprtsock.c-		return;
net/sunrpc/xprtsock.c-				"seconds\n",
net/sunrpc/xprtsock.c-	set_bit(XPRT_CONNECTION_ABORT, &xprt->state);
net/sunrpc/xprtsock.c:	struct delayed_work	connect_worker;
net/sunrpc/xprtsock.c-	struct sockaddr_storage	srcaddr;
net/sunrpc/xprtsock.c-			   timeout);
net/sunrpc/xprtsock.c-				   &transport->connect_worker,
net/sunrpc/xprtsock.c-				   &transport->connect_worker, 0);
net/sunrpc/xprtsock.c-	transport = container_of(xprt, struct sock_xprt, xprt);
net/sunrpc/xprtsock.c-	unsigned short		srcport;
net/sunrpc/xprtsock.c-				   xprt->reestablish_timeout);
net/sunrpc/xprtsock.c-				xprt, xprt->reestablish_timeout / HZ);
net/sunrpc/xprtsock.c-	xs_local_destroy(xprt);
net/wireless/reg.c-
net/wireless/reg.c-
net/wireless/reg.c-
net/wireless/reg.c-
net/wireless/reg.c-
net/wireless/reg.c-}
net/wireless/reg.c-	}
net/wireless/reg.c:	cancel_delayed_work_sync(&reg_timeout);
net/wireless/reg.c:		cancel_delayed_work_sync(&reg_timeout);
net/wireless/reg.c-	cancel_work_sync(&reg_work);
net/wireless/reg.c-	if (last_request->initiator == NL80211_REGDOM_SET_BY_USER)
net/wireless/reg.c-	if (need_more_processing)
net/wireless/reg.c-	if (r != -EALREADY &&
net/wireless/reg.c-	     last_request->initiator == NL80211_REGDOM_SET_BY_COUNTRY_IE)) {
net/wireless/reg.c-	    (last_request->initiator == NL80211_REGDOM_SET_BY_DRIVER ||
net/wireless/reg.c-	mutex_lock(&cfg80211_mutex);
net/wireless/reg.c-	    reg_initiator == NL80211_REGDOM_SET_BY_USER)
net/wireless/reg.c-		return -ENODEV;
net/wireless/reg.c:		schedule_delayed_work(&reg_timeout, 0);
net/wireless/reg.c:		schedule_delayed_work(&reg_timeout, msecs_to_jiffies(3142));
patches-all/allpatches.txt-/root/machinex/patches-all/patches0-8000/2035-5.9.5-testing-compiler-flags-recommended-in-snapdrag.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches0-8000/2036-revert-last-three-patches-keeping-makefile-for-now.patch
patches-all/allpatches.txt:/root/machinex/patches-all/patches0-8000/2037-workqueue-use-mod_delayed_work-instead-of-__cancel-a.patch
patches-all/allpatches.txt:/root/machinex/patches-all/patches0-8000/2038-workqueue-use-mod_delayed_work-instead-of-cancel-and.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches0-8000/2039-workqueue-deprecate-system_nrt-_freezable-_wq.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches0-8000/2040-vfp-libs-test-out-hard-float-again-now-that-I-have-a.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches0-8000/2048-removed-makefile-options-not-available-with-this-com.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches0-8000/2049-the-ol-deferred-work-switcheroo.patch
patches-all/allpatches.txt:/root/machinex/patches-all/patches0-8000/2050-Reimplement-delayed_work-initializers-using-new-time.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches0-8000/2051-the-ol-module-signatgure-verification-removal-trick-.patch
patches-all/allpatches.txt:/root/machinex/patches-all/patches0-8000/2052-fix-deferrable_delayed_work-for-dma.c.patch
patches-all/allpatches.txt:/root/machinex/patches-all/patches0-8000/2053-workqueue-use-irqsafe-timer-for-delayed_work.patch
patches-all/allpatches.txt:/root/machinex/patches-all/patches0-8000/2054-deprecate-__cancel_delayed_work.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches0-8000/2055-workqueue-remove-delayed-from-cwq_dec_nr_in_flight.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches0-8000/2056-msm-pm-8x60-Increase-warn-timeout-further-for-sleep-.patch
patches-all/allpatches.txt:/root/machinex/patches-all/patches0-8000/2057-workqueue-cancel_delayed_work-should-return-false.patch
patches-all/allpatches.txt:/root/machinex/patches-all/patches0-8000/2058-workqueue-un-GPL-function-delayed_work_timer_fn.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches0-8000/2059-workqueue-consider-work-function-when-searching-for-.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches0-8000/2060-rcu-Reduce-cache-miss-initialization-latencies-for-l.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches0-8000/3469-squash-remaining-seccomp-udpates.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches0-8000/3470-pm8xxx-fix-SOD-RR-and-improve-deep-sleep-fingers-cro.patch
patches-all/allpatches.txt:/root/machinex/patches-all/patches0-8000/3471-massive-conversion-to-mod_delayed_work.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches0-8000/3472-arm-arch_timer-add-arch_counter_set_user_access.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches0-8000/3473-arm-arch_timer-provide-user-space-access-to-virtual-.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches0-8000/3677-config_use_of-no-go-at-this-point.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches0-8000/3678-REVERT-almost-finished-updating-pm-qos-shit.patch
patches-all/allpatches.txt:/root/machinex/patches-all/patches0-8000/3679-replace-mod_delayed_work-with-queue-in-some-choice-a.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches0-8000/3680-govs-more-moddelayed-replacement.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches0-8000/3681-remove-previous-implementation-of-get_online_cpus-to.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches0-8000/3835-oom-use-N_MEMORY-instead-N_HIGH_MEMORY.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches0-8000/3836-cpufreq-introduce-Medusa-a-multicore-efficient-cpu-g.patch
patches-all/allpatches.txt:/root/machinex/patches-all/patches0-8000/3837-cpu_boost-use-mod_delayed_work-instead-of-queue.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches0-8000/3838-cpufreq-cleaned-up-governors-set-up-hellsactive-baco.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches0-8000/3839-config-enabled-a-few-govs-for-testing.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches0-8000/4926-chuckle.REVERT-futex-patch-AGAIN.-I-never-learn.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches0-8000/4927-kprobes-fix-wait_for_kprobe_optimizer.patch
patches-all/allpatches.txt:/root/machinex/patches-all/patches0-8000/4928-SQUASH-stop-using-delayed_work_pending-for-a-ton-of-.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches0-8000/4929-lglock-add-DEFINE_STATIC_LGLOCK.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches0-8000/4930-shit-revert-this.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches0-8000/5793-sched-Consider-runnable-load-average-in-move_tasks.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches0-8000/5794-sched-Change-cfs_rq-load-avg-to-unsigned-long.patch
patches-all/allpatches.txt:/root/machinex/patches-all/patches0-8000/5795-workqueue-Provide-destroy_delayed_work_on_stack.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches0-8000/5796-workqueue-use-schedule_timeout_interruptible-instead.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches0-8000/5797-vmstat-explicitly-schedule-per-cpu-work-on-the-CPU-w.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches0-8000/6158-more-bs.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches0-8000/6159-some-header-work.patch
patches-all/allpatches.txt:/root/machinex/patches-all/patches0-8000/6160-mod_delayed_work-in-some-smart-places.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches0-8000/6161-some-sync-work.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches0-8000/6162-haha-really.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches0-8000/6862-PM-Runtime-Check-device-PM-QoS-setting-before-no-cal.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches0-8000/6863-always-been-curious-lets-see-what-happens.patch
patches-all/allpatches.txt:/root/machinex/patches-all/patches0-8000/6864-workqueue-reimplement-cancel_delayed_work-using-tryt.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches0-8000/6865-Input-gpio_keys-report-a-wakeup_event-for-a-button-p.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches0-8000/6866-various-3.6-backported-usb-fixes.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches0-8000/7040-cgroup-add-croupg-addrm-files.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches0-8000/7041-modpost-get-rid-of-devinit-exit.patch
patches-all/allpatches.txt:/root/machinex/patches-all/patches0-8000/7042-workqueue-mod_delayed_work_on-shouldn-t-queue-timer.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches0-8000/7043-useless-iommu-stuff.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches0-8000/7044-ext4-move-extra-inode-read-to-a-new-function.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches0-8000/7899-workqueue-replace-WORK_CPU_NONE-LAST-with-WORK_CPU_E.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches0-8000/7900-workqueue-make-work_busy-test-WORK_STRUCT_PENDING-fi.patch
patches-all/allpatches.txt:/root/machinex/patches-all/patches0-8000/7901-workqueue-add-delayed_work-wq-to-simplify-reentrancy.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches0-8000/7902-workqueue-make-work-data-point-to-pool-after-try-to-.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches0-8000/7903-workqueue-move-nr_running-into-worker_pool.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches16001-24000/0404-workqueue-fix-pool-ID-allocation-leakage-and-remove-.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches16001-24000/0405-workqueue-ensure-task-is-valid-across-kthread_stop.patch
patches-all/allpatches.txt:/root/machinex/patches-all/patches16001-24000/0406-workqueue-Provide-destroy_delayed_work_on_stack.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches16001-24000/0407-workqueue-fix-bugs-in-wq_update_unbound_numa-failure.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches16001-24000/0408-workqueue-make-rescuer_thread-empty-wq-maydays-list.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches16001-24000/5132-ext4-remove-an-unneeded-check-in-mext_page_mkuptodat.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches16001-24000/5133-workqueue-ensure-task-is-valid-across-kthread_stop.patch
patches-all/allpatches.txt:/root/machinex/patches-all/patches16001-24000/5134-workqueue-Remove-deprecated-__cancel_delayed_work.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches16001-24000/5135-dox.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches16001-24000/5136-dox.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches16001-24000/5630-sched-Clean-up-the-task_hot-function.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches16001-24000/5631-resources-Set-type-in-__request_region.patch
patches-all/allpatches.txt:/root/machinex/patches-all/patches16001-24000/5632-workqueue-Provide-destroy_delayed_work_on_stack.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches16001-24000/5633-tick-Remove-code-duplication-in-tick_handle_periodic.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches16001-24000/5634-REVERT-wq.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches24001-32000/0640-made-green-stand-out-further-than-red-as-an-experime.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches24001-32000/0641-matrix-keyboard.patch
patches-all/allpatches.txt:/root/machinex/patches-all/patches24001-32000/0642-change-mod_delayed_work-back-to-queue_delayed_work-w.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches24001-32000/0643-oopsy-daisy.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches24001-32000/0644-question-how-come-cpuidle-wasnt-erroring-via-gcc-wit.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches24001-32000/5922-workqueue-replace-WORK_CPU_NONE-LAST-with-WORK_CPU_E.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches24001-32000/5923-workqueue-make-work_busy-test-WORK_STRUCT_PENDING.patch
patches-all/allpatches.txt:/root/machinex/patches-all/patches24001-32000/5924-workqueue-add-delayed_work-wq-to-simplify-reentrancy.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches24001-32000/5925-workqueue-make-work-data-point-to-pool.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches24001-32000/5926-workqueue-simplify-is-work-item-queued-here-test.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches32001-40000/1407-squash-remaining-seccomp-udpates.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches32001-40000/1408-pm8xxx-fix-SOD-RR-and-improve-deep-sleep-fingers-cro.patch
patches-all/allpatches.txt:/root/machinex/patches-all/patches32001-40000/1409-massive-conversion-to-mod_delayed_work.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches32001-40000/1410-arm-arch_timer-add-arch_counter_set_user_access.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches32001-40000/1411-arm-arch_timer-provide-user-space-access-to-virtual-.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches32001-40000/1615-config_use_of-no-go-at-this-point.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches32001-40000/1616-REVERT-almost-finished-updating-pm-qos-shit.patch
patches-all/allpatches.txt:/root/machinex/patches-all/patches32001-40000/1617-replace-mod_delayed_work-with-queue-in-some-choice-a.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches32001-40000/1618-govs-more-moddelayed-replacement.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches32001-40000/1619-remove-previous-implementation-of-get_online_cpus-to.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches32001-40000/1773-oom-use-N_MEMORY-instead-N_HIGH_MEMORY.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches32001-40000/1774-cpufreq-introduce-Medusa-a-multicore-efficient-cpu-g.patch
patches-all/allpatches.txt:/root/machinex/patches-all/patches32001-40000/1775-cpu_boost-use-mod_delayed_work-instead-of-queue.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches32001-40000/1776-cpufreq-cleaned-up-governors-set-up-hellsactive-baco.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches32001-40000/1777-config-enabled-a-few-govs-for-testing.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches32001-40000/2864-chuckle.REVERT-futex-patch-AGAIN.-I-never-learn.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches32001-40000/2865-kprobes-fix-wait_for_kprobe_optimizer.patch
patches-all/allpatches.txt:/root/machinex/patches-all/patches32001-40000/2866-SQUASH-stop-using-delayed_work_pending-for-a-ton-of-.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches32001-40000/2867-lglock-add-DEFINE_STATIC_LGLOCK.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches32001-40000/2868-shit-revert-this.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches32001-40000/3731-sched-Consider-runnable-load-average-in-move_tasks.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches32001-40000/3732-sched-Change-cfs_rq-load-avg-to-unsigned-long.patch
patches-all/allpatches.txt:/root/machinex/patches-all/patches32001-40000/3733-workqueue-Provide-destroy_delayed_work_on_stack.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches32001-40000/3734-workqueue-use-schedule_timeout_interruptible-instead.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches32001-40000/3735-vmstat-explicitly-schedule-per-cpu-work-on-the-CPU-w.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches32001-40000/4096-more-bs.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches32001-40000/4097-some-header-work.patch
patches-all/allpatches.txt:/root/machinex/patches-all/patches32001-40000/4098-mod_delayed_work-in-some-smart-places.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches32001-40000/4099-some-sync-work.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches32001-40000/4100-haha-really.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches32001-40000/4800-PM-Runtime-Check-device-PM-QoS-setting-before-no-cal.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches32001-40000/4801-always-been-curious-lets-see-what-happens.patch
patches-all/allpatches.txt:/root/machinex/patches-all/patches32001-40000/4802-workqueue-reimplement-cancel_delayed_work-using-tryt.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches32001-40000/4803-Input-gpio_keys-report-a-wakeup_event-for-a-button-p.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches32001-40000/4804-various-3.6-backported-usb-fixes.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches32001-40000/4978-cgroup-add-croupg-addrm-files.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches32001-40000/4979-modpost-get-rid-of-devinit-exit.patch
patches-all/allpatches.txt:/root/machinex/patches-all/patches32001-40000/4980-workqueue-mod_delayed_work_on-shouldn-t-queue-timer.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches32001-40000/4981-useless-iommu-stuff.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches32001-40000/4982-ext4-move-extra-inode-read-to-a-new-function.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches32001-40000/5837-workqueue-replace-WORK_CPU_NONE-LAST-with-WORK_CPU_E.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches32001-40000/5838-workqueue-make-work_busy-test-WORK_STRUCT_PENDING-fi.patch
patches-all/allpatches.txt:/root/machinex/patches-all/patches32001-40000/5839-workqueue-add-delayed_work-wq-to-simplify-reentrancy.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches32001-40000/5840-workqueue-make-work-data-point-to-pool-after-try-to-.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches32001-40000/5841-workqueue-move-nr_running-into-worker_pool.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches40001-42063/2035-5.9.5-testing-compiler-flags-recommended-in-snapdrag.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches40001-42063/2036-revert-last-three-patches-keeping-makefile-for-now.patch
patches-all/allpatches.txt:/root/machinex/patches-all/patches40001-42063/2037-workqueue-use-mod_delayed_work-instead-of-__cancel-a.patch
patches-all/allpatches.txt:/root/machinex/patches-all/patches40001-42063/2038-workqueue-use-mod_delayed_work-instead-of-cancel-and.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches40001-42063/2039-workqueue-deprecate-system_nrt-_freezable-_wq.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches40001-42063/2040-vfp-libs-test-out-hard-float-again-now-that-I-have-a.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches40001-42063/2048-removed-makefile-options-not-available-with-this-com.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches40001-42063/2049-the-ol-deferred-work-switcheroo.patch
patches-all/allpatches.txt:/root/machinex/patches-all/patches40001-42063/2050-Reimplement-delayed_work-initializers-using-new-time.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches40001-42063/2051-the-ol-module-signatgure-verification-removal-trick-.patch
patches-all/allpatches.txt:/root/machinex/patches-all/patches40001-42063/2052-fix-deferrable_delayed_work-for-dma.c.patch
patches-all/allpatches.txt:/root/machinex/patches-all/patches40001-42063/2053-workqueue-use-irqsafe-timer-for-delayed_work.patch
patches-all/allpatches.txt:/root/machinex/patches-all/patches40001-42063/2054-deprecate-__cancel_delayed_work.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches40001-42063/2055-workqueue-remove-delayed-from-cwq_dec_nr_in_flight.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches40001-42063/2056-msm-pm-8x60-Increase-warn-timeout-further-for-sleep-.patch
patches-all/allpatches.txt:/root/machinex/patches-all/patches40001-42063/2057-workqueue-cancel_delayed_work-should-return-false.patch
patches-all/allpatches.txt:/root/machinex/patches-all/patches40001-42063/2058-workqueue-un-GPL-function-delayed_work_timer_fn.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches40001-42063/2059-workqueue-consider-work-function-when-searching-for-.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches40001-42063/2060-rcu-Reduce-cache-miss-initialization-latencies-for-l.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches8001-16000/0725-workqueue-remove-PREPARE_-DELAYED_-WORK.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches8001-16000/0726-dox.patch
patches-all/allpatches.txt:/root/machinex/patches-all/patches8001-16000/0727-workqueue-Provide-destroy_delayed_work_on_stack.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches8001-16000/0728-remove-deprecated-WQ_NON_REENTRANT-they-are-all.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches8001-16000/0729-workqueue-fix-bugs-in-wq_update_unbound_numa-failure.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches8001-16000/4356-workqueue-Convert-to-state-machine-callbacks.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches8001-16000/4357-workqueue-move-wq_numa_init-to-workqueue_init.patch
patches-all/allpatches.txt:/root/machinex/patches-all/patches8001-16000/4358-workqueue-trigger-WARN-if-queue_delayed_work-is-call.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches8001-16000/4359-workqueue-use-setup_deferrable_timer.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches8001-16000/4360-workqueue-Provide-work_on_cpu_safe.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches8001-16000/4775-remove-doubled-INIT_HLIST_HEAD-preempt-notifier.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches8001-16000/4776-sched-deadline-Fix-the-intention-to-re-evalute-tick-.patch
patches-all/allpatches.txt:/root/machinex/patches-all/patches8001-16000/4777-PM-QoS-avoid-calling-cancel_delayed_work_sync-during.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches8001-16000/4778-cpu-hotplug-Replace-anon-union.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches8001-16000/4779-dox.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches8001-16000/7103-blk-throttle-remove-deferred-config-application-mech.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches8001-16000/7104-blk-throttle-collapse-throtl_dispatch-into-the-workq.patch
patches-all/allpatches.txt:/root/machinex/patches-all/patches8001-16000/7105-blk-throttle-relocate-throtl_schedule_delayed_work.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches8001-16000/7106-blk-throttle-remove-pointless-throtl_nr_queued.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches8001-16000/7107-blk-throttle-rename-throtl_rb_root-to-throtl_service.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches8001-16000/7423-block-fix-regression-with-block-enabled-tagging.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches8001-16000/7424-replace-a-PTRERR.patch
patches-all/allpatches.txt:/root/machinex/patches-all/patches8001-16000/7425-oops-add-kblockd_schedule_delayed_work_on.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches8001-16000/7426-hahahaha-after-all-that-revert-my-dumb-ion-and-sound.patch
patches-all/allpatches.txt-/root/machinex/patches-all/patches8001-16000/7427-ref.patch
sound/aoa/core/gpio-feature.c-
sound/aoa/core/gpio-feature.c-
sound/aoa/core/gpio-feature.c:	cancel_delayed_work_sync(&rt->headphone_notify.work);
sound/aoa/core/gpio-feature.c:	cancel_delayed_work_sync(&rt->line_in_notify.work);
sound/aoa/core/gpio-feature.c:	cancel_delayed_work_sync(&rt->line_out_notify.work);
sound/aoa/core/gpio-feature.c-		free_irq(lineout_detect_irq, &rt->line_out_notify);
sound/aoa/core/gpio-feature.c-	if (rt->line_out_notify.gpio_private)
sound/aoa/core/gpio-feature.c-	mutex_destroy(&rt->headphone_notify.mutex);
sound/aoa/core/gpio-feature.c-	mutex_destroy(&rt->line_in_notify.mutex);
sound/aoa/core/gpio-feature.c-	return IRQ_HANDLED;
sound/aoa/core/gpio-feature.c:	schedule_delayed_work(&notif->work, 0);
sound/aoa/core/gpio-feature.c-	struct gpio_notification *notif = data;
sound/aoa/core/gpio-pmf.c-
sound/aoa/core/gpio-pmf.c-
sound/aoa/core/gpio-pmf.c-
sound/aoa/core/gpio-pmf.c-}
sound/aoa/core/gpio-pmf.c-	 * all things */
sound/aoa/core/gpio-pmf.c:	cancel_delayed_work_sync(&rt->headphone_notify.work);
sound/aoa/core/gpio-pmf.c:	cancel_delayed_work_sync(&rt->line_in_notify.work);
sound/aoa/core/gpio-pmf.c:	cancel_delayed_work_sync(&rt->line_out_notify.work);
sound/aoa/core/gpio-pmf.c-	/* make sure no work is pending before freeing
sound/aoa/core/gpio-pmf.c-	mutex_destroy(&rt->headphone_notify.mutex);
sound/aoa/core/gpio-pmf.c:	schedule_delayed_work(&notif->work, 0);
sound/aoa/core/gpio-pmf.c-	struct gpio_notification *notif = data;
sound/i2c/other/ak4113.c-
sound/i2c/other/ak4113.c-{
sound/i2c/other/ak4113.c-{
sound/i2c/other/ak4113.c-}
sound/i2c/other/ak4113.c-}
sound/i2c/other/ak4113.c-}
sound/i2c/other/ak4113.c-}
sound/i2c/other/ak4113.c-	ak4113_init_regs(chip);
sound/i2c/other/ak4113.c-	atomic_inc(&chip->wq_processing);	/* don't schedule new work */
sound/i2c/other/ak4113.c-	/* bring up statistics / event queing */
sound/i2c/other/ak4113.c:	cancel_delayed_work_sync(&chip->work);
sound/i2c/other/ak4113.c:		cancel_delayed_work_sync(&chip->work);
sound/i2c/other/ak4113.c-EXPORT_SYMBOL_GPL(snd_ak4113_reinit);
sound/i2c/other/ak4113.c-	if (atomic_dec_and_test(&chip->wq_processing))
sound/i2c/other/ak4113.c-	if (atomic_dec_and_test(&chip->wq_processing))
sound/i2c/other/ak4113.c-	if (atomic_inc_return(&chip->wq_processing) == 1)
sound/i2c/other/ak4113.c-	kfree(chip);
sound/i2c/other/ak4113.c-	return 0;
sound/i2c/other/ak4113.c:	schedule_delayed_work(&ak4113->work, HZ / 10);
sound/i2c/other/ak4113.c:		schedule_delayed_work(&chip->work, HZ / 10);
sound/i2c/other/ak4113.c:		schedule_delayed_work(&chip->work, HZ / 10);
sound/i2c/other/ak4113.c-	snd_ak4113_proc_init(ak4113);
sound/i2c/other/ak4113.c-	/* trigger workq */
sound/i2c/other/ak4114.c-
sound/i2c/other/ak4114.c-
sound/i2c/other/ak4114.c-{
sound/i2c/other/ak4114.c-{
sound/i2c/other/ak4114.c-}
sound/i2c/other/ak4114.c-}
sound/i2c/other/ak4114.c-}
sound/i2c/other/ak4114.c-}
sound/i2c/other/ak4114.c-	ak4114_init_regs(chip);
sound/i2c/other/ak4114.c-	atomic_inc(&chip->wq_processing);	/* don't schedule new work */
sound/i2c/other/ak4114.c-	/* bring up statistics / event queing */
sound/i2c/other/ak4114.c:	cancel_delayed_work_sync(&chip->work);
sound/i2c/other/ak4114.c:		cancel_delayed_work_sync(&chip->work);
sound/i2c/other/ak4114.c-	if (atomic_dec_and_test(&chip->wq_processing))
sound/i2c/other/ak4114.c-	if (atomic_dec_and_test(&chip->wq_processing))
sound/i2c/other/ak4114.c-	if (atomic_inc_return(&chip->wq_processing) == 1)
sound/i2c/other/ak4114.c-	kfree(chip);
sound/i2c/other/ak4114.c-	return 0;
sound/i2c/other/ak4114.c:	schedule_delayed_work(&ak4114->work, HZ / 10);
sound/i2c/other/ak4114.c:		schedule_delayed_work(&chip->work, HZ / 10);
sound/i2c/other/ak4114.c:		schedule_delayed_work(&chip->work, HZ / 10);
sound/i2c/other/ak4114.c-		snd_ak4114_check_rate_and_errors(chip, chip->check_flags);
sound/i2c/other/ak4114.c-	snd_ak4114_proc_init(ak4114);
sound/i2c/other/ak4114.c-	/* trigger workq */
sound/pci/ac97/ac97_codec.c-	}
sound/pci/ac97/ac97_codec.c-		 */
sound/pci/ac97/ac97_codec.c-		ac97->build_ops->suspend(ac97);
sound/pci/ac97/ac97_codec.c:		cancel_delayed_work(&ac97->power_work);
sound/pci/ac97/ac97_codec.c:	cancel_delayed_work_sync(&ac97->power_work);
sound/pci/ac97/ac97_codec.c:		cancel_delayed_work_sync(&ac97->power_work);
sound/pci/ac97/ac97_codec.c-	else {
sound/pci/ac97/ac97_codec.c-#endif
sound/pci/ac97/ac97_codec.c-#endif
sound/pci/ac97/ac97_codec.c-	if (ac97) {
sound/pci/ac97/ac97_codec.c-#ifdef CONFIG_SND_AC97_POWER_SAVE
sound/pci/ac97/ac97_codec.c-#ifdef CONFIG_SND_AC97_POWER_SAVE
sound/pci/ac97/ac97_codec.c-				      msecs_to_jiffies(power_save * 1000));
sound/pci/ac97/ac97_codec.c:		schedule_delayed_work(&ac97->power_work,
sound/pci/ac97/ac97_codec.c-	snd_ac97_powerdown(ac97);
sound/pci/ac97/ac97_codec.c-		snd_ac97_proc_done(ac97);
sound/pci/ac97/ac97_codec.c-		 *  that open/close frequently)
sound/pci/ac97/ac97_codec.c-		update_power_regs(ac97);
sound/pci/hda/hda_beep.c-			}
sound/pci/hda/hda_beep.c:		cancel_delayed_work(&beep->unregister_work);
sound/pci/hda/hda_beep.c:				cancel_delayed_work(&beep->unregister_work);
sound/pci/hda/hda_beep.c-		cancel_work_sync(&beep->register_work);
sound/pci/hda/hda_beep.c-			} else {
sound/pci/hda/hda_beep.c-									   HZ);
sound/pci/hda/hda_beep.c-	if (beep) {
sound/pci/hda/hda_beep.c-		if (beep->dev)
sound/pci/hda/hda_beep.c-		if (beep->mode == HDA_BEEP_MODE_SWREG) {
sound/pci/hda/hda_beep.c-			if (enable) {
sound/pci/hda/hda_beep.c:				schedule_delayed_work(&beep->unregister_work,
sound/pci/hda/hda_beep.c-				schedule_work(&beep->register_work);
sound/pci/hda/hda_beep.c-			snd_hda_do_detach(beep);
sound/pci/hda/hda_codec.c-
sound/pci/hda/hda_codec.c-}
sound/pci/hda/hda_codec.c-	}
sound/pci/hda/hda_codec.c-		bus->ops.pm_notify(bus);
sound/pci/hda/hda_codec.c:	cancel_delayed_work(&codec->power_work);
sound/pci/hda/hda_codec.c:	cancel_delayed_work(&codec->power_work);
sound/pci/hda/hda_codec.c:	cancel_delayed_work(&codec->power_work);
sound/pci/hda/hda_codec.c:	cancel_delayed_work(&codec->power_work);
sound/pci/hda/hda_codec.c-	codec->power_on = 0;
sound/pci/hda/hda_codec.c-	codec->power_transition = 0;
sound/pci/hda/hda_codec.c-	codec->power_transition = 0;
sound/pci/hda/hda_codec.c-		codec->power_transition = 1; /* avoid reentrance */
sound/pci/hda/hda_codec.c-#endif
sound/pci/hda/hda_codec.c-#endif
sound/pci/hda/hda_codec.c-	flush_workqueue(codec->bus->workq);
sound/pci/hda/hda_codec.c-	flush_workqueue(codec->bus->workq);
sound/pci/hda/hda_codec.c-	hda_call_codec_resume(codec);
sound/pci/hda/hda_codec.c-#ifdef CONFIG_SND_HDA_POWER_SAVE
sound/pci/hda/hda_codec.c-#ifdef CONFIG_SND_HDA_POWER_SAVE
sound/pci/hda/hda_codec.c-#ifdef CONFIG_SND_HDA_POWER_SAVE
sound/pci/hda/hda_codec.c-	if (power_save(codec)) {
sound/pci/hda/hda_codec.c-				msecs_to_jiffies(power_save(codec) * 1000));
sound/pci/hda/hda_codec.c:		queue_delayed_work(codec->bus->workq, &codec->power_work,
sound/pci/hda/hda_codec.c-	restore_init_pincfgs(codec);
sound/pci/hda/hda_codec.c-	snd_hda_update_power_acct(codec);
sound/pci/hda/patch_hdmi.c-
sound/pci/hda/patch_hdmi.c-
sound/pci/hda/patch_hdmi.c-{
sound/pci/hda/patch_hdmi.c-};
sound/pci/hda/patch_hdmi.c-	}
sound/pci/hda/patch_hdmi.c:		cancel_delayed_work(&per_pin->work);
sound/pci/hda/patch_hdmi.c:	container_of(to_delayed_work(work), struct hdmi_spec_per_pin, work);
sound/pci/hda/patch_hdmi.c-		else if (repoll) {
sound/pci/hda/patch_hdmi.c-	if (per_pin->repoll_count++ > 6)
sound/pci/hda/patch_hdmi.c-	int repoll_count;
sound/pci/hda/patch_hdmi.c-					   msecs_to_jiffies(300));
sound/pci/hda/patch_hdmi.c-					   &per_pin->work,
sound/pci/hda/patch_hdmi.c:			queue_delayed_work(codec->bus->workq,
sound/pci/hda/patch_hdmi.c-		snd_hda_eld_proc_free(codec, eld);
sound/pci/hda/patch_hdmi.c-			snd_hdmi_show_eld(eld);
sound/pci/hda/patch_hdmi.c:	struct delayed_work work;
sound/pci/hda/patch_hdmi.c-	struct hda_codec *codec;
sound/pci/hda/patch_hdmi.c-		struct hdmi_eld *eld = &per_pin->sink_eld;
sound/pci/hda/patch_hdmi.c-	struct hdmi_eld sink_eld;
sound/pci/hda/patch_hdmi.c-	struct hdmi_spec_per_pin *per_pin =
sound/pci/hda/patch_via.c-}
sound/pci/hda/patch_via.c-	}
sound/pci/hda/patch_via.c-	}
sound/pci/hda/patch_via.c:		cancel_delayed_work_sync(&spec->vt1708_hp_work);
sound/pci/hda/patch_via.c-		if (!spec->hp_work_active) {
sound/pci/hda/patch_via.c-	if (spec->hp_work_active) {
sound/pci/hda/patch_via.c-	if (spec->vt1708_jack_detect)
sound/pci/hda/patch_via.c-	int hp_work_active;
sound/pci/hda/patch_via.c-	int vt1708_jack_detect;
sound/pci/hda/patch_via.c-				      msecs_to_jiffies(100));
sound/pci/hda/patch_via.c-					      msecs_to_jiffies(100));
sound/pci/hda/patch_via.c:		schedule_delayed_work(&spec->vt1708_hp_work,
sound/pci/hda/patch_via.c:			schedule_delayed_work(&spec->vt1708_hp_work,
sound/pci/hda/patch_via.c-			snd_hda_codec_write(spec->codec, 0x1, 0, 0xf81, 0);
sound/pci/hda/patch_via.c-		snd_hda_codec_write(spec->codec, 0x1, 0, 0xf81, 1);
sound/pci/hda/patch_via.c-		spec->hp_work_active = 0;
sound/pci/hda/patch_via.c-			spec->hp_work_active = 1;
sound/pci/hda/patch_via.c:	struct delayed_work vt1708_hp_work;
sound/pci/hda/patch_via.c-	struct hda_codec *codec;
sound/pci/hda/patch_via.c-	/* work to check hp jack state */
sound/soc/codecs/audience/es325.c-
sound/soc/codecs/audience/es325.c-
sound/soc/codecs/audience/es325.c-{
sound/soc/codecs/audience/es325.c-		break;
sound/soc/codecs/audience/es325.c-			break;
sound/soc/codecs/audience/es325.c:		cancel_delayed_work(&es325->sleep_work);
sound/soc/codecs/audience/es325.c:			cancel_delayed_work(&es325->sleep_work);
sound/soc/codecs/audience/es325.c-	case ES325_POWER_STATE_SLEEP_PENDING:
sound/soc/codecs/audience/es325.c-			/* Defer Sleep */
sound/soc/codecs/audience/es325.c-	} else {
sound/soc/codecs/audience/es325.c-		es325->pm_state = ES325_POWER_STATE_NORMAL;
sound/soc/codecs/audience/es325.c-	if (es325->pm_state == ES325_POWER_STATE_SLEEP_PENDING) {
sound/soc/codecs/audience/es325.c-		if (new_state == ES325_POWER_STATE_NORMAL)
sound/soc/codecs/audience/es325.c-				msecs_to_jiffies(ES325_SLEEP_DELAY));
sound/soc/codecs/audience/es325.c-			new_state = ES325_POWER_STATE_SLEEP_PENDING;
sound/soc/codecs/audience/es325.c:			schedule_delayed_work(&es325->sleep_work,
sound/soc/codecs/audience/es325.c-			sleep_work);
sound/soc/codecs/audience/es325.c-static void es325_delayed_sleep(struct work_struct *work_req)
sound/soc/codecs/audience/es325.c:	struct delayed_work *d_work = to_delayed_work(work_req);
sound/soc/codecs/audience/es325.c-	struct es325_priv *es325 = container_of(d_work, struct es325_priv,
sound/soc/codecs/audience/es705.c-
sound/soc/codecs/audience/es705.c-
sound/soc/codecs/audience/es705.c-	
sound/soc/codecs/audience/es705.c:		cancel_delayed_work_sync(&es705->reroute_work);
sound/soc/codecs/audience/es705.c:		cancel_delayed_work_sync(&es705->sleep_work);
sound/soc/codecs/audience/es705.c-#endif
sound/soc/codecs/audience/es705.c-#endif
sound/soc/codecs/audience/es705.c-#endif
sound/soc/codecs/audience/es705.c-#endif
sound/soc/codecs/audience/es705.c-#endif
sound/soc/codecs/audience/es705.c-#endif
sound/soc/codecs/audience/es705.c-		es705->pm_state = ES705_POWER_AWAKE;
sound/soc/codecs/audience/es705.c-		es705->pm_state = ES705_POWER_SLEEP_PENDING;
sound/soc/codecs/audience/es705.c-		(es705->pm_state == ES705_POWER_SLEEP_PENDING)) {
sound/soc/codecs/audience/es705.c-		goto es705_wakeup_exit;
sound/soc/codecs/audience/es705.c-#if defined(PREVENT_CALL_MUTE_WHEN_SWITCH_NB_AND_WB)
sound/soc/codecs/audience/es705.c-#if defined(PREVENT_CALL_MUTE_WHEN_SWITCH_NB_AND_WB)
sound/soc/codecs/audience/es705.c-#if defined(PREVENT_CALL_MUTE_WHEN_SWITCH_NB_AND_WB)
sound/soc/codecs/audience/es705.c-#if defined(PREVENT_CALL_MUTE_WHEN_SWITCH_NB_AND_WB)
sound/soc/codecs/audience/es705.c-#if defined(PREVENT_CALL_MUTE_WHEN_SWITCH_NB_AND_WB)
sound/soc/codecs/audience/es705.c:	if (delayed_work_pending(&es705->reroute_work))
sound/soc/codecs/audience/es705.c:	if (delayed_work_pending(&es705->sleep_work) ||
sound/soc/codecs/audience/es705.c-	if (es705->pm_state == ES705_POWER_AWAKE) {
sound/soc/codecs/audience/es705.c-								msecs_to_jiffies(es705->reroute_delay));
sound/soc/codecs/audience/es705.c-								msecs_to_jiffies(es705->reroute_delay));
sound/soc/codecs/audience/es705.c-								msecs_to_jiffies(es705->reroute_delay));
sound/soc/codecs/audience/es705.c-								msecs_to_jiffies(es705->reroute_delay));
sound/soc/codecs/audience/es705.c-			msecs_to_jiffies(es705->sleep_delay));
sound/soc/codecs/audience/es705.c-	msm_slim_es705_func(es705_priv.gen0_client);
sound/soc/codecs/audience/es705.c-					"%s() adjust narrowband offset\n", __func__);
sound/soc/codecs/audience/es705.c-					"%s() adjust wideband offset\n", __func__);
sound/soc/codecs/audience/es705.c-					"%s() adjust wideband offset\n", __func__);
sound/soc/codecs/audience/es705.c-					"%s() adjust wideband offset\n", __func__);
sound/soc/codecs/audience/es705.c:				schedule_delayed_work(&es705->reroute_work,
sound/soc/codecs/audience/es705.c:				schedule_delayed_work(&es705->reroute_work,
sound/soc/codecs/audience/es705.c:				schedule_delayed_work(&es705->reroute_work,
sound/soc/codecs/audience/es705.c:				schedule_delayed_work(&es705->reroute_work,
sound/soc/codecs/audience/es705.c:		schedule_delayed_work(&es705->sleep_work,
sound/soc/codecs/es325.c-			}
sound/soc/codecs/es325.c-#define ES325_SLEEP_TIME HZ
sound/soc/codecs/es325.c-#ifdef ES325_SLEEP
sound/soc/codecs/es325.c:			if (delayed_work_pending(&es325_work)) {
sound/soc/codecs/es325.c-		if (es325->wq_active) {
sound/soc/codecs/es325.c-	if (!rc) {
sound/soc/codecs/es325.c-	int rc = 0;
sound/soc/codecs/es325.c-				pr_debug("=[ES325]=%s cancel work queue rc=%d\n", __func__, rc);
sound/soc/codecs/es325.c-			pr_debug("=[ES325]=%s delete sleep timer wakeup count=%d\n", __func__, es325->wakeup_cnt);
sound/soc/codecs/es325.c-		pr_err("=[ES325]=%s delayed work queue failed\n", __func__);
sound/soc/codecs/es325.c:				rc = cancel_delayed_work_sync(&es325_work);
sound/soc/codecs/es325.c:	rc = queue_delayed_work(es325_workqueue, &es325_work, ES325_SLEEP_TIME);
sound/soc/codecs/es325.c-static int es325_schedule_sleep_workqueue(void)
sound/soc/codecs/es325.c:struct delayed_work es325_work;
sound/soc/codecs/es325.c-	struct es325_priv *es325 = &es325_priv;
sound/soc/codecs/es325.c-struct workqueue_struct *es325_workqueue;
sound/soc/codecs/sta32x.c-
sound/soc/codecs/sta32x.c-
sound/soc/codecs/sta32x.c-}
sound/soc/codecs/sta32x.c-}
sound/soc/codecs/sta32x.c-};
sound/soc/codecs/sta32x.c-	}
sound/soc/codecs/sta32x.c-	}
sound/soc/codecs/sta32x.c:		cancel_delayed_work_sync(&sta32x->watchdog_work);
sound/soc/codecs/sta32x.c-	if (sta32x->pdata->needs_esd_watchdog) {
sound/soc/codecs/sta32x.c-	if (sta32x->pdata->needs_esd_watchdog) {
sound/soc/codecs/sta32x.c-	if (!sta32x->shutdown)
sound/soc/codecs/sta32x.c-	int shutdown;
sound/soc/codecs/sta32x.c-				      round_jiffies_relative(HZ));
sound/soc/codecs/sta32x.c-				      round_jiffies_relative(HZ));
sound/soc/codecs/sta32x.c:		schedule_delayed_work(&sta32x->watchdog_work,
sound/soc/codecs/sta32x.c:		schedule_delayed_work(&sta32x->watchdog_work,
sound/soc/codecs/sta32x.c-		sta32x->shutdown = 0;
sound/soc/codecs/sta32x.c-		sta32x->shutdown = 1;
sound/soc/codecs/sta32x.c:	struct delayed_work watchdog_work;
sound/soc/codecs/sta32x.c-	u32 coef_shadow[STA32X_COEF_COUNT];
sound/soc/codecs/twl6040.c-
sound/soc/codecs/twl6040.c-
sound/soc/codecs/twl6040.c-
sound/soc/codecs/twl6040.c-
sound/soc/codecs/twl6040.c-
sound/soc/codecs/twl6040.c-
sound/soc/codecs/twl6040.c-
sound/soc/codecs/twl6040.c-
sound/soc/codecs/twl6040.c-
sound/soc/codecs/twl6040.c-};
sound/soc/codecs/twl6040.c-};
sound/soc/codecs/twl6040.c-		 */
sound/soc/codecs/twl6040.c-		 */
sound/soc/codecs/twl6040.c-		break;
sound/soc/codecs/twl6040.c:		cancel_delayed_work_sync(work);
sound/soc/codecs/twl6040.c:		cancel_delayed_work_sync(work);
sound/soc/codecs/twl6040.c-		 * executing work.
sound/soc/codecs/twl6040.c-		 * executing work.
sound/soc/codecs/twl6040.c-		INIT_COMPLETION(out->ramp_done);
sound/soc/codecs/twl6040.c-	int report;
sound/soc/codecs/twl6040.c-			   msecs_to_jiffies(200));
sound/soc/codecs/twl6040.c-		out->left_step = priv->hf_left_step;
sound/soc/codecs/twl6040.c-		out->left_step = priv->hs_left_step;
sound/soc/codecs/twl6040.c-		out->right_step = out->right_vol;
sound/soc/codecs/twl6040.c:	queue_delayed_work(priv->workqueue, &priv->hs_jack.work,
sound/soc/codecs/twl6040.c:		queue_delayed_work(priv->workqueue, work, msecs_to_jiffies(1));
sound/soc/codecs/twl6040.c:		queue_delayed_work(priv->workqueue, work, msecs_to_jiffies(1));
sound/soc/codecs/twl6040.c-	struct completion ramp_done;
sound/soc/codecs/twl6040.c:	struct delayed_work *work;
sound/soc/codecs/twl6040.c:	struct delayed_work work;
sound/soc/codecs/twl6040.c:	struct delayed_work work;
sound/soc/codecs/twl6040.c-	struct snd_soc_jack *jack;
sound/soc/codecs/twl6040.c-	struct twl6040_data *priv = snd_soc_codec_get_drvdata(codec);
sound/soc/codecs/twl6040.c-	struct twl6040_data *priv = snd_soc_codec_get_drvdata(codec);
sound/soc/codecs/twl6040.c-struct twl6040_jack_data {
sound/soc/codecs/twl6040.c-	struct twl6040_output *out;
sound/soc/codecs/twl6040.c-	switch (w->shift) {
sound/soc/codecs/twl6040.c-	u16 ramp;
sound/soc/codecs/twl6040.c-	unsigned int step_delay;
sound/soc/codecs/twl6040.c-		wait_for_completion_timeout(&out->ramp_done,
sound/soc/codecs/wcd9304.c-
sound/soc/codecs/wcd9304.c-
sound/soc/codecs/wcd9304.c-
sound/soc/codecs/wcd9304.c-
sound/soc/codecs/wcd9304.c-
sound/soc/codecs/wcd9304.c-
sound/soc/codecs/wcd9304.c-
sound/soc/codecs/wcd9304.c-
sound/soc/codecs/wcd9304.c-
sound/soc/codecs/wcd9304.c-
sound/soc/codecs/wcd9304.c-
sound/soc/codecs/wcd9304.c-{
sound/soc/codecs/wcd9304.c-{
sound/soc/codecs/wcd9304.c-{
sound/soc/codecs/wcd9304.c-};
sound/soc/codecs/wcd9304.c-	}
sound/soc/codecs/wcd9304.c-		}
sound/soc/codecs/wcd9304.c-	bool hs_detect_work_stop;
sound/soc/codecs/wcd9304.c-		break;
sound/soc/codecs/wcd9304.c:		cancel_delayed_work_sync(&tx_hpf_work[decimator - 1].dwork);
sound/soc/codecs/wcd9304.c-	case SND_SOC_DAPM_PRE_PMD:
sound/soc/codecs/wcd9304.c-				CF_MIN_3DB_150HZ) {
sound/soc/codecs/wcd9304.c-	codec = hpf_work->sitar->codec;
sound/soc/codecs/wcd9304.c-	const struct firmware *mbhc_fw;
sound/soc/codecs/wcd9304.c-	core = dev_get_drvdata(sitar->codec->dev->parent);
sound/soc/codecs/wcd9304.c:	delayed_work = to_delayed_work(work);
sound/soc/codecs/wcd9304.c:	dwork = to_delayed_work(work);
sound/soc/codecs/wcd9304.c-	} else {
sound/soc/codecs/wcd9304.c:	hpf_delayed_work = to_delayed_work(work);
sound/soc/codecs/wcd9304.c:	hpf_work = container_of(hpf_delayed_work, struct hpf_work, dwork);
sound/soc/codecs/wcd9304.c:	if (cancel_delayed_work_sync(&sitar->mbhc_btn_dwork)) {
sound/soc/codecs/wcd9304.c:		if (schedule_delayed_work(&priv->mbhc_btn_dwork,
sound/soc/codecs/wcd9304.c-		/* if scheduled mbhc_btn_dwork is canceled from here,
sound/soc/codecs/wcd9304.c-		if (tx_hpf_work[decimator - 1].tx_hpf_cut_of_freq !=
sound/soc/codecs/wcd9304.c-	int ret = -1, retry = 0;
sound/soc/codecs/wcd9304.c-				mbhc_firmware_dwork);
sound/soc/codecs/wcd9304.c-				msecs_to_jiffies(300));
sound/soc/codecs/wcd9304.c-					  msecs_to_jiffies(400)) == 0) {
sound/soc/codecs/wcd9304.c-	pr_debug("%s:\n", __func__);
sound/soc/codecs/wcd9304.c-		priv->buttons_pressed |= mask;
sound/soc/codecs/wcd9304.c-		rc = sitar_mbhc_init_and_calibrate(codec);
sound/soc/codecs/wcd9304.c:		schedule_delayed_work(&sitar->mbhc_firmware_dwork,
sound/soc/codecs/wcd9304.c:			schedule_delayed_work(&tx_hpf_work[decimator - 1].dwork,
sound/soc/codecs/wcd9304.c-	short bias_value;
sound/soc/codecs/wcd9304.c:	sitar = container_of(delayed_work, struct sitar_priv, mbhc_btn_dwork);
sound/soc/codecs/wcd9304.c-	sitar = container_of(dwork, struct sitar_priv,
sound/soc/codecs/wcd9304.c-	sitar = hpf_work->sitar;
sound/soc/codecs/wcd9304.c-static void btn_lpress_fn(struct work_struct *work)
sound/soc/codecs/wcd9304.c-static void mbhc_fw_read(struct work_struct *work)
sound/soc/codecs/wcd9304.c-static void tx_hpf_corner_freq_callback(struct work_struct *work)
sound/soc/codecs/wcd9304.c:	struct delayed_work *delayed_work;
sound/soc/codecs/wcd9304.c:	struct delayed_work *dwork;
sound/soc/codecs/wcd9304.c:	struct delayed_work dwork;
sound/soc/codecs/wcd9304.c:	struct delayed_work *hpf_delayed_work;
sound/soc/codecs/wcd9304.c:	struct delayed_work mbhc_btn_dwork;
sound/soc/codecs/wcd9304.c:	struct delayed_work mbhc_firmware_dwork;
sound/soc/codecs/wcd9304.c-	struct hpf_work *hpf_work;
sound/soc/codecs/wcd9304.c-	struct sitar_priv *sitar;
sound/soc/codecs/wcd9304.c-	struct sitar_priv *sitar;
sound/soc/codecs/wcd9304.c-	struct sitar_priv *sitar;
sound/soc/codecs/wcd9304.c-	struct snd_soc_codec *codec;
sound/soc/codecs/wcd9304.c-	struct wcd9xxx *core = dev_get_drvdata(sitar->codec->dev->parent);
sound/soc/codecs/wcd9304.c-	struct work_struct hs_correct_plug_work;
sound/soc/codecs/wcd9304.c-	u32 decimator;
sound/soc/codecs/wcd9304.c-	u8 hpf_cut_of_freq;
sound/soc/codecs/wcd9304.c-	u8 tx_hpf_cut_of_freq;
sound/soc/codecs/wcd9304.c-	unsigned long mbhc_last_resume; /* in jiffies */
sound/soc/codecs/wcd9304.c-					usecs_to_jiffies(MBHC_FW_READ_TIMEOUT));
sound/soc/codecs/wcd9304.c-			WARN(1, "Button pressed twice without release"
sound/soc/codecs/wcd9304.c-		wcd9xxx_lock_sleep(core);
sound/soc/codecs/wcd9304.c-		 * we have to unlock from here instead btn_work */
sound/soc/codecs/wcd9304.c-	/* Work to perform MBHC Firmware Read */
sound/soc/codecs/wcd9306.c-{
sound/soc/codecs/wcd9306.c-};
sound/soc/codecs/wcd9306.c-
sound/soc/codecs/wcd9306.c-
sound/soc/codecs/wcd9306.c-
sound/soc/codecs/wcd9306.c-
sound/soc/codecs/wcd9306.c-
sound/soc/codecs/wcd9306.c-		}
sound/soc/codecs/wcd9306.c-		break;
sound/soc/codecs/wcd9306.c:		cancel_delayed_work_sync(&tx_hpf_work[decimator - 1].dwork);
sound/soc/codecs/wcd9306.c-				CF_MIN_3DB_150HZ) {
sound/soc/codecs/wcd9306.c-	codec = hpf_work->tapan->codec;
sound/soc/codecs/wcd9306.c:	hpf_delayed_work = to_delayed_work(work);
sound/soc/codecs/wcd9306.c:	hpf_work = container_of(hpf_delayed_work, struct hpf_work, dwork);
sound/soc/codecs/wcd9306.c-					msecs_to_jiffies(300));
sound/soc/codecs/wcd9306.c:			schedule_delayed_work(&tx_hpf_work[decimator - 1].dwork,
sound/soc/codecs/wcd9306.c-		snd_soc_update_bits(codec, tx_vol_ctl_reg, 0x01, 0x01);
sound/soc/codecs/wcd9306.c-static void tx_hpf_corner_freq_callback(struct work_struct *work)
sound/soc/codecs/wcd9306.c:	struct delayed_work dwork;
sound/soc/codecs/wcd9306.c:	struct delayed_work *hpf_delayed_work;
sound/soc/codecs/wcd9306.c-	struct hpf_work *hpf_work;
sound/soc/codecs/wcd9306.c-	struct tapan_priv *tapan;
sound/soc/codecs/wcd9306.c-	tapan = hpf_work->tapan;
sound/soc/codecs/wcd9306.c-	u32 decimator;
sound/soc/codecs/wcd9306.c-	u8 hpf_cut_of_freq;
sound/soc/codecs/wcd9306.c-	u8 tx_hpf_cut_of_freq;
sound/soc/codecs/wcd9310.c-
sound/soc/codecs/wcd9310.c-
sound/soc/codecs/wcd9310.c-
sound/soc/codecs/wcd9310.c-
sound/soc/codecs/wcd9310.c-
sound/soc/codecs/wcd9310.c-
sound/soc/codecs/wcd9310.c-
sound/soc/codecs/wcd9310.c-
sound/soc/codecs/wcd9310.c-
sound/soc/codecs/wcd9310.c-
sound/soc/codecs/wcd9310.c-
sound/soc/codecs/wcd9310.c-
sound/soc/codecs/wcd9310.c-
sound/soc/codecs/wcd9310.c-
sound/soc/codecs/wcd9310.c-
sound/soc/codecs/wcd9310.c-
sound/soc/codecs/wcd9310.c-
sound/soc/codecs/wcd9310.c-
sound/soc/codecs/wcd9310.c-
sound/soc/codecs/wcd9310.c-{
sound/soc/codecs/wcd9310.c-{
sound/soc/codecs/wcd9310.c-{
sound/soc/codecs/wcd9310.c-{
sound/soc/codecs/wcd9310.c-{
sound/soc/codecs/wcd9310.c-};
sound/soc/codecs/wcd9310.c-};
sound/soc/codecs/wcd9310.c-		}
sound/soc/codecs/wcd9310.c-	bool no_mic_headset_override;
sound/soc/codecs/wcd9310.c-		break;
sound/soc/codecs/wcd9310.c:		cancel_delayed_work_sync(&tx_hpf_work[decimator - 1].dwork);
sound/soc/codecs/wcd9310.c:		cancel_delayed_work_sync(&tx_mute_work[decimator - 1].dwork);
sound/soc/codecs/wcd9310.c-				CF_MIN_3DB_150HZ) {
sound/soc/codecs/wcd9310.c-	codec = hpf_work->tabla->codec;
sound/soc/codecs/wcd9310.c-	codec = tabla->codec;
sound/soc/codecs/wcd9310.c-	codec = tabla->codec;
sound/soc/codecs/wcd9310.c-	codec = tx_mute_work->tabla->codec;
sound/soc/codecs/wcd9310.c-	const struct firmware *mbhc_fw;
sound/soc/codecs/wcd9310.c-	core = dev_get_drvdata(tabla->codec->dev->parent);
sound/soc/codecs/wcd9310.c:	delayed_work = to_delayed_work(work);
sound/soc/codecs/wcd9310.c-	/* Delayed work to report long button press */
sound/soc/codecs/wcd9310.c-		/* Disable TX digital mute */
sound/soc/codecs/wcd9310.c:	dwork = to_delayed_work(work);
sound/soc/codecs/wcd9310.c:	dwork = to_delayed_work(work);
sound/soc/codecs/wcd9310.c-	else
sound/soc/codecs/wcd9310.c-	} else  {
sound/soc/codecs/wcd9310.c-					     false);
sound/soc/codecs/wcd9310.c-			__func__);
sound/soc/codecs/wcd9310.c:	hpf_delayed_work = to_delayed_work(work);
sound/soc/codecs/wcd9310.c:	hpf_work = container_of(hpf_delayed_work, struct hpf_work, dwork);
sound/soc/codecs/wcd9310.c:	if (cancel_delayed_work_sync(&tabla->mbhc_btn_dwork)) {
sound/soc/codecs/wcd9310.c-		if (ret != 0) {
sound/soc/codecs/wcd9310.c:		if (schedule_delayed_work(&priv->mbhc_btn_dwork,
sound/soc/codecs/wcd9310.c:		if (schedule_delayed_work(&priv->mbhc_insert_dwork,
sound/soc/codecs/wcd9310.c-		/* if scheduled mbhc_btn_dwork is canceled from here,
sound/soc/codecs/wcd9310.c-	int ret = -1, retry = 0;
sound/soc/codecs/wcd9310.c-			msecs_to_jiffies(100));
sound/soc/codecs/wcd9310.c-					msecs_to_jiffies(300));
sound/soc/codecs/wcd9310.c-					  msecs_to_jiffies(400)) == 0) {
sound/soc/codecs/wcd9310.c:	mute_delayed_work = to_delayed_work(work);
sound/soc/codecs/wcd9310.c-			mxcodec_dbg("%s: Complete plug insertion, Detecting plug "
sound/soc/codecs/wcd9310.c-	mxcodec_dbg("%s:\n", __func__);
sound/soc/codecs/wcd9310.c-			pr_err("%s: mbhc_insert_dwork is already scheduled\n",
sound/soc/codecs/wcd9310.c-		priv->buttons_pressed |= mask;
sound/soc/codecs/wcd9310.c-		rc = tabla_mbhc_init_and_calibrate(tabla);
sound/soc/codecs/wcd9310.c:		ret = cancel_delayed_work(&priv->mbhc_insert_dwork);
sound/soc/codecs/wcd9310.c:		schedule_delayed_work(
sound/soc/codecs/wcd9310.c:		schedule_delayed_work(&tabla->mbhc_firmware_dwork,
sound/soc/codecs/wcd9310.c:			schedule_delayed_work(&tx_hpf_work[decimator - 1].dwork,
sound/soc/codecs/wcd9310.c-	short bias_value;
sound/soc/codecs/wcd9310.c-		snd_soc_update_bits(codec, tx_vol_ctl_reg, 0x01, 0x01);
sound/soc/codecs/wcd9310.c-static void btn_lpress_fn(struct work_struct *work)
sound/soc/codecs/wcd9310.c-static void mbhc_fw_read(struct work_struct *work)
sound/soc/codecs/wcd9310.c-static void tx_digital_unmute_callback(struct work_struct *work)
sound/soc/codecs/wcd9310.c-static void tx_hpf_corner_freq_callback(struct work_struct *work)
sound/soc/codecs/wcd9310.c:	struct delayed_work *delayed_work;
sound/soc/codecs/wcd9310.c:		struct delayed_work dwork;
sound/soc/codecs/wcd9310.c:	struct delayed_work *dwork;
sound/soc/codecs/wcd9310.c:	struct delayed_work *dwork;
sound/soc/codecs/wcd9310.c:	struct delayed_work dwork;
sound/soc/codecs/wcd9310.c:	struct delayed_work *hpf_delayed_work;
sound/soc/codecs/wcd9310.c:	struct delayed_work mbhc_btn_dwork;
sound/soc/codecs/wcd9310.c:	struct delayed_work mbhc_firmware_dwork;
sound/soc/codecs/wcd9310.c:	struct delayed_work mbhc_insert_dwork;
sound/soc/codecs/wcd9310.c:	struct delayed_work *mute_delayed_work;
sound/soc/codecs/wcd9310.c-	struct hpf_work *hpf_work;
sound/soc/codecs/wcd9310.c-	struct mbhc_micbias_regs mbhc_bias_regs;
sound/soc/codecs/wcd9310.c-	struct mute_work *tx_mute_work;
sound/soc/codecs/wcd9310.c-	struct snd_soc_codec *codec;
sound/soc/codecs/wcd9310.c-	struct snd_soc_codec *codec;
sound/soc/codecs/wcd9310.c-		struct tabla_priv *tabla;
sound/soc/codecs/wcd9310.c-	struct tabla_priv *tabla;
sound/soc/codecs/wcd9310.c-	struct tabla_priv *tabla;
sound/soc/codecs/wcd9310.c-	struct tabla_priv *tabla;
sound/soc/codecs/wcd9310.c-	struct tabla_priv *tabla;
sound/soc/codecs/wcd9310.c-	struct tabla_priv *tabla;
sound/soc/codecs/wcd9310.c-	struct wcd9xxx *core = dev_get_drvdata(tabla->codec->dev->parent);
sound/soc/codecs/wcd9310.c-	struct wcd9xxx *tabla_core;
sound/soc/codecs/wcd9310.c:	tabla = container_of(delayed_work, struct tabla_priv, mbhc_btn_dwork);
sound/soc/codecs/wcd9310.c-	tabla = container_of(dwork, struct tabla_priv, mbhc_firmware_dwork);
sound/soc/codecs/wcd9310.c-	tabla = container_of(dwork, struct tabla_priv, mbhc_insert_dwork);
sound/soc/codecs/wcd9310.c-	tabla = hpf_work->tabla;
sound/soc/codecs/wcd9310.c-	tabla = tx_mute_work->tabla;
sound/soc/codecs/wcd9310.c:	tx_mute_work = container_of(mute_delayed_work, struct mute_work, dwork);
sound/soc/codecs/wcd9310.c-			&tx_mute_work[decimator - 1].dwork,
sound/soc/codecs/wcd9310.c-	u16 tx_vol_ctl_reg;
sound/soc/codecs/wcd9310.c-		u32 decimator;
sound/soc/codecs/wcd9310.c-	u32 decimator;
sound/soc/codecs/wcd9310.c-	u8 aux_r_gain;
sound/soc/codecs/wcd9310.c-	u8 hpf_cut_of_freq;
sound/soc/codecs/wcd9310.c-	u8 tx_hpf_cut_of_freq;
sound/soc/codecs/wcd9310.c-	unsigned long mbhc_last_resume; /* in jiffies */
sound/soc/codecs/wcd9310.c-					  usecs_to_jiffies(1000000)) == 0) {
sound/soc/codecs/wcd9310.c-				      usecs_to_jiffies(MBHC_FW_READ_TIMEOUT));
sound/soc/codecs/wcd9310.c-void mbhc_insert_work(struct work_struct *work)
sound/soc/codecs/wcd9310.c-			WARN(1, "Button pressed twice without release"
sound/soc/codecs/wcd9310.c-		wcd9xxx_lock_sleep(core);
sound/soc/codecs/wcd9310.c-		wcd9xxx_lock_sleep(core);
sound/soc/codecs/wcd9310.c-		* we have to unlock from here instead btn_work */
sound/soc/codecs/wcd9310.c-	/* Work to perform MBHC Firmware Read */
sound/soc/codecs/wcd9320.c-
sound/soc/codecs/wcd9320.c-
sound/soc/codecs/wcd9320.c-
sound/soc/codecs/wcd9320.c-
sound/soc/codecs/wcd9320.c-
sound/soc/codecs/wcd9320.c-
sound/soc/codecs/wcd9320.c-
sound/soc/codecs/wcd9320.c-
sound/soc/codecs/wcd9320.c-
sound/soc/codecs/wcd9320.c-
sound/soc/codecs/wcd9320.c-
sound/soc/codecs/wcd9320.c-
sound/soc/codecs/wcd9320.c-
sound/soc/codecs/wcd9320.c-
sound/soc/codecs/wcd9320.c-
sound/soc/codecs/wcd9320.c-
sound/soc/codecs/wcd9320.c-{
sound/soc/codecs/wcd9320.c-{
sound/soc/codecs/wcd9320.c-{
sound/soc/codecs/wcd9320.c-{
sound/soc/codecs/wcd9320.c-};
sound/soc/codecs/wcd9320.c-		}
sound/soc/codecs/wcd9320.c-	bool no_mic_headset_override;
sound/soc/codecs/wcd9320.c-		break;
sound/soc/codecs/wcd9320.c:		cancel_delayed_work_sync(&tx_hpf_work[decimator - 1].dwork);
sound/soc/codecs/wcd9320.c-				CF_MIN_3DB_150HZ) {
sound/soc/codecs/wcd9320.c-	codec = hpf_work->taiko->codec;
sound/soc/codecs/wcd9320.c-	codec = taiko->codec;
sound/soc/codecs/wcd9320.c-	codec = taiko->codec;
sound/soc/codecs/wcd9320.c-	const struct firmware *mbhc_fw;
sound/soc/codecs/wcd9320.c-	core = dev_get_drvdata(taiko->codec->dev->parent);
sound/soc/codecs/wcd9320.c:	delayed_work = to_delayed_work(work);
sound/soc/codecs/wcd9320.c-	/* Delayed work to report long button press */
sound/soc/codecs/wcd9320.c:	dwork = to_delayed_work(work);
sound/soc/codecs/wcd9320.c:	dwork = to_delayed_work(work);
sound/soc/codecs/wcd9320.c-	else
sound/soc/codecs/wcd9320.c-	} else  {
sound/soc/codecs/wcd9320.c-					     false);
sound/soc/codecs/wcd9320.c-			__func__);
sound/soc/codecs/wcd9320.c:	hpf_delayed_work = to_delayed_work(work);
sound/soc/codecs/wcd9320.c:	hpf_work = container_of(hpf_delayed_work, struct hpf_work, dwork);
sound/soc/codecs/wcd9320.c:	if (cancel_delayed_work_sync(&taiko->mbhc_btn_dwork)) {
sound/soc/codecs/wcd9320.c-		if (ret != 0) {
sound/soc/codecs/wcd9320.c:		if (schedule_delayed_work(&priv->mbhc_btn_dwork,
sound/soc/codecs/wcd9320.c:		if (schedule_delayed_work(&priv->mbhc_insert_dwork,
sound/soc/codecs/wcd9320.c-		/* if scheduled mbhc_btn_dwork is canceled from here,
sound/soc/codecs/wcd9320.c-	int ret = -1, retry = 0;
sound/soc/codecs/wcd9320.c-					msecs_to_jiffies(300));
sound/soc/codecs/wcd9320.c-					  msecs_to_jiffies(400)) == 0) {
sound/soc/codecs/wcd9320.c-			pr_debug(
sound/soc/codecs/wcd9320.c-	pr_debug("%s:\n", __func__);
sound/soc/codecs/wcd9320.c-			pr_err("%s: mbhc_insert_dwork is already scheduled\n",
sound/soc/codecs/wcd9320.c-		priv->buttons_pressed |= mask;
sound/soc/codecs/wcd9320.c-		rc = taiko_mbhc_init_and_calibrate(taiko);
sound/soc/codecs/wcd9320.c:		ret = cancel_delayed_work(&priv->mbhc_insert_dwork);
sound/soc/codecs/wcd9320.c:		schedule_delayed_work(&taiko->mbhc_firmware_dwork,
sound/soc/codecs/wcd9320.c:			schedule_delayed_work(&tx_hpf_work[decimator - 1].dwork,
sound/soc/codecs/wcd9320.c-	short bias_value;
sound/soc/codecs/wcd9320.c-		snd_soc_update_bits(codec, tx_vol_ctl_reg, 0x01, 0x01);
sound/soc/codecs/wcd9320.c-static void btn_lpress_fn(struct work_struct *work)
sound/soc/codecs/wcd9320.c-static void mbhc_fw_read(struct work_struct *work)
sound/soc/codecs/wcd9320.c-static void taiko_mbhc_insert_work(struct work_struct *work)
sound/soc/codecs/wcd9320.c-static void tx_hpf_corner_freq_callback(struct work_struct *work)
sound/soc/codecs/wcd9320.c:	struct delayed_work *delayed_work;
sound/soc/codecs/wcd9320.c:	struct delayed_work *dwork;
sound/soc/codecs/wcd9320.c:	struct delayed_work *dwork;
sound/soc/codecs/wcd9320.c:	struct delayed_work dwork;
sound/soc/codecs/wcd9320.c:	struct delayed_work *hpf_delayed_work;
sound/soc/codecs/wcd9320.c:	struct delayed_work mbhc_btn_dwork;
sound/soc/codecs/wcd9320.c:	struct delayed_work mbhc_firmware_dwork;
sound/soc/codecs/wcd9320.c:	struct delayed_work mbhc_insert_dwork;
sound/soc/codecs/wcd9320.c-	struct hpf_work *hpf_work;
sound/soc/codecs/wcd9320.c-	struct mbhc_micbias_regs mbhc_bias_regs;
sound/soc/codecs/wcd9320.c-	struct snd_soc_codec *codec;
sound/soc/codecs/wcd9320.c-	struct snd_soc_codec *codec;
sound/soc/codecs/wcd9320.c-	struct taiko_priv *taiko;
sound/soc/codecs/wcd9320.c-	struct taiko_priv *taiko;
sound/soc/codecs/wcd9320.c-	struct taiko_priv *taiko;
sound/soc/codecs/wcd9320.c-	struct taiko_priv *taiko;
sound/soc/codecs/wcd9320.c-	struct wcd9xxx *core = dev_get_drvdata(taiko->codec->dev->parent);
sound/soc/codecs/wcd9320.c-	struct wcd9xxx *taiko_core;
sound/soc/codecs/wcd9320.c:	taiko = container_of(delayed_work, struct taiko_priv, mbhc_btn_dwork);
sound/soc/codecs/wcd9320.c-	taiko = container_of(dwork, struct taiko_priv, mbhc_firmware_dwork);
sound/soc/codecs/wcd9320.c-	taiko = container_of(dwork, struct taiko_priv, mbhc_insert_dwork);
sound/soc/codecs/wcd9320.c-	taiko = hpf_work->taiko;
sound/soc/codecs/wcd9320.c-	u32 decimator;
sound/soc/codecs/wcd9320.c-	u8 aux_r_gain;
sound/soc/codecs/wcd9320.c-	u8 hpf_cut_of_freq;
sound/soc/codecs/wcd9320.c-	u8 tx_hpf_cut_of_freq;
sound/soc/codecs/wcd9320.c-	unsigned long mbhc_last_resume; /* in jiffies */
sound/soc/codecs/wcd9320.c-					  usecs_to_jiffies(1000000)) == 0) {
sound/soc/codecs/wcd9320.c-				      usecs_to_jiffies(MBHC_FW_READ_TIMEOUT));
sound/soc/codecs/wcd9320.c-			WARN(1, "Button pressed twice without release event\n");
sound/soc/codecs/wcd9320.c-		wcd9xxx_lock_sleep(core);
sound/soc/codecs/wcd9320.c-		wcd9xxx_lock_sleep(core);
sound/soc/codecs/wcd9320.c-		* we have to unlock from here instead btn_work */
sound/soc/codecs/wcd9320.c-	/* Work to perform MBHC Firmware Read */
sound/soc/codecs/wcd9335.c-
sound/soc/codecs/wcd9335.c-
sound/soc/codecs/wcd9335.c-
sound/soc/codecs/wcd9335.c-
sound/soc/codecs/wcd9335.c-
sound/soc/codecs/wcd9335.c-
sound/soc/codecs/wcd9335.c-
sound/soc/codecs/wcd9335.c-
sound/soc/codecs/wcd9335.c-{
sound/soc/codecs/wcd9335.c-{
sound/soc/codecs/wcd9335.c-};
sound/soc/codecs/wcd9335.c-};
sound/soc/codecs/wcd9335.c-		}
sound/soc/codecs/wcd9335.c-		}
sound/soc/codecs/wcd9335.c-		}
sound/soc/codecs/wcd9335.c-			}
sound/soc/codecs/wcd9335.c-		break;
sound/soc/codecs/wcd9335.c:		cancel_delayed_work_sync(
sound/soc/codecs/wcd9335.c:				cancel_delayed_work_sync(
sound/soc/codecs/wcd9335.c-							CF_MIN_3DB_150HZ)
sound/soc/codecs/wcd9335.c-	codec = tasha->codec;
sound/soc/codecs/wcd9335.c-	codec = tasha->codec;
sound/soc/codecs/wcd9335.c-	codec = tasha->codec;
sound/soc/codecs/wcd9335.c:	delayed_work = to_delayed_work(work);
sound/soc/codecs/wcd9335.c-	dev_dbg(dev, "%s: system suspend\n", __func__);
sound/soc/codecs/wcd9335.c:	dwork = to_delayed_work(work);
sound/soc/codecs/wcd9335.c-			else {
sound/soc/codecs/wcd9335.c:	hpf_delayed_work = to_delayed_work(work);
sound/soc/codecs/wcd9335.c:	hpf_work = container_of(hpf_delayed_work, struct hpf_work, dwork);
sound/soc/codecs/wcd9335.c:		if (cancel_delayed_work_sync(
sound/soc/codecs/wcd9335.c:	if (cancel_delayed_work_sync(&tasha->power_gate_work))
sound/soc/codecs/wcd9335.c-			if (hpf_cut_off_freq != CF_MIN_3DB_150HZ) {
sound/soc/codecs/wcd9335.c-	if (req_state == POWER_COLLAPSE) {
sound/soc/codecs/wcd9335.c-		if (tasha->power_active_ref == 0) {
sound/soc/codecs/wcd9335.c-		if (tasha->tx_hpf_work[decimator].hpf_cut_off_freq !=
sound/soc/codecs/wcd9335.c-	int amic_n;
sound/soc/codecs/wcd9335.c-					msecs_to_jiffies(300));
sound/soc/codecs/wcd9335.c-			msecs_to_jiffies(dig_core_collapse_timer * 1000));
sound/soc/codecs/wcd9335.c-				      msecs_to_jiffies(tx_unmute_delay));
sound/soc/codecs/wcd9335.c-				mutex_lock(&tasha->power_lock);
sound/soc/codecs/wcd9335.c-				mutex_unlock(&tasha->power_lock);
sound/soc/codecs/wcd9335.c:			schedule_delayed_work(
sound/soc/codecs/wcd9335.c:			schedule_delayed_work(&tasha->power_gate_work,
sound/soc/codecs/wcd9335.c:		schedule_delayed_work(&tasha->tx_mute_dwork[decimator].dwork,
sound/soc/codecs/wcd9335.c-		/* schedule work queue to Remove Mute */
sound/soc/codecs/wcd9335.c-		snd_soc_update_bits(codec, dec_cfg_reg, 0x08, 0x00);
sound/soc/codecs/wcd9335.c-		snd_soc_update_bits(codec, tx_vol_ctl_reg, 0x10, 0x10);
sound/soc/codecs/wcd9335.c-static void tasha_tx_hpf_corner_freq_callback(struct work_struct *work)
sound/soc/codecs/wcd9335.c:	struct delayed_work *delayed_work;
sound/soc/codecs/wcd9335.c:	struct delayed_work *dwork;
sound/soc/codecs/wcd9335.c:	struct delayed_work dwork;
sound/soc/codecs/wcd9335.c:	struct delayed_work dwork;
sound/soc/codecs/wcd9335.c:	struct delayed_work *hpf_delayed_work;
sound/soc/codecs/wcd9335.c:	struct delayed_work power_gate_work;
sound/soc/codecs/wcd9335.c-	struct hpf_work *hpf_work;
sound/soc/codecs/wcd9335.c-	struct mutex power_lock;
sound/soc/codecs/wcd9335.c-	struct mutex sido_lock;
sound/soc/codecs/wcd9335.c-	struct snd_soc_codec *codec;
sound/soc/codecs/wcd9335.c-	struct snd_soc_codec *codec;
sound/soc/codecs/wcd9335.c-	struct tasha_priv *tasha;
sound/soc/codecs/wcd9335.c-	struct tasha_priv *tasha;
sound/soc/codecs/wcd9335.c-	struct tasha_priv *tasha;
sound/soc/codecs/wcd9335.c-	struct tasha_priv *tasha;
sound/soc/codecs/wcd9335.c-	struct tx_mute_work *tx_mute_dwork;
sound/soc/codecs/wcd9335.c-	struct wcd9xxx_resmgr_v2 *resmgr;
sound/soc/codecs/wcd9335.c-		tasha_codec_power_gate_digital_core(tasha);
sound/soc/codecs/wcd9335.c-	tasha = container_of(dwork, struct tasha_priv, power_gate_work);
sound/soc/codecs/wcd9335.c-	tasha = hpf_work->tasha;
sound/soc/codecs/wcd9335.c-						&tasha->power_gate_work);
sound/soc/codecs/wcd9335.c-		    &tasha->tx_hpf_work[decimator].dwork)) {
sound/soc/codecs/wcd9335.c-					&tasha->tx_hpf_work[decimator].dwork,
sound/soc/codecs/wcd9335.c-				&tasha->tx_mute_dwork[decimator].dwork);
sound/soc/codecs/wcd9335.c-	tasha = tx_mute_dwork->tasha;
sound/soc/codecs/wcd9335.c:	tx_mute_dwork = container_of(delayed_work, struct tx_mute_work, dwork);
sound/soc/codecs/wcd9335.c-	u16 tx_vol_ctl_reg, hpf_gate_reg;
sound/soc/codecs/wcd9335.c-	u8 decimator;
sound/soc/codecs/wcd9335.c-	u8 decimator;
sound/soc/codecs/wcd9335.c-	u8 hpf_cut_off_freq;
sound/soc/codecs/wcd9xxx-mbhc.c-{
sound/soc/codecs/wcd9xxx-mbhc.c-{
sound/soc/codecs/wcd9xxx-mbhc.c-{
sound/soc/codecs/wcd9xxx-mbhc.c-{
sound/soc/codecs/wcd9xxx-mbhc.c-
sound/soc/codecs/wcd9xxx-mbhc.c-
sound/soc/codecs/wcd9xxx-mbhc.c-
sound/soc/codecs/wcd9xxx-mbhc.c-
sound/soc/codecs/wcd9xxx-mbhc.c-
sound/soc/codecs/wcd9xxx-mbhc.c-	codec = mbhc->codec;
sound/soc/codecs/wcd9xxx-mbhc.c-	codec = mbhc->codec;
sound/soc/codecs/wcd9xxx-mbhc.c:	dwork = to_delayed_work(work);
sound/soc/codecs/wcd9xxx-mbhc.c:	dwork = to_delayed_work(work);
sound/soc/codecs/wcd9xxx-mbhc.c:	dwork = to_delayed_work(work);
sound/soc/codecs/wcd9xxx-mbhc.c-	else
sound/soc/codecs/wcd9xxx-mbhc.c-	if (r)
sound/soc/codecs/wcd9xxx-mbhc.c:		if (schedule_delayed_work(&mbhc->mbhc_btn_dwork,
sound/soc/codecs/wcd9xxx-mbhc.c-		/* if scheduled mbhc.mbhc_btn_dwork is canceled from here,
sound/soc/codecs/wcd9xxx-mbhc.c-	int dce_mv, sta_mv;
sound/soc/codecs/wcd9xxx-mbhc.c-	int r;
sound/soc/codecs/wcd9xxx-mbhc.c-	int ret = -1, retry = 0;
sound/soc/codecs/wcd9xxx-mbhc.c-		mbhc->buttons_pressed |= mask;
sound/soc/codecs/wcd9xxx-mbhc.c-	mbhc = container_of(dwork, struct wcd9xxx_mbhc, mbhc_btn_dwork);
sound/soc/codecs/wcd9xxx-mbhc.c-	mbhc = container_of(dwork, struct wcd9xxx_mbhc, mbhc_firmware_dwork);
sound/soc/codecs/wcd9xxx-mbhc.c-	mbhc = container_of(dwork, struct wcd9xxx_mbhc, mbhc_insert_dwork);
sound/soc/codecs/wcd9xxx-mbhc.c-					  msecs_to_jiffies(400)) == 0) {
sound/soc/codecs/wcd9xxx-mbhc.c-	pr_debug("%s:\n", __func__);
sound/soc/codecs/wcd9xxx-mbhc.c:	r = cancel_delayed_work_sync(&mbhc->mbhc_btn_dwork);
sound/soc/codecs/wcd9xxx-mbhc.c-		rc = wcd9xxx_init_and_calibrate(mbhc);
sound/soc/codecs/wcd9xxx-mbhc.c:		schedule_delayed_work(&mbhc->mbhc_firmware_dwork,
sound/soc/codecs/wcd9xxx-mbhc.c-	short bias_value;
sound/soc/codecs/wcd9xxx-mbhc.c-static void wcd9xxx_btn_lpress_fn(struct work_struct *work)
sound/soc/codecs/wcd9xxx-mbhc.c-static void wcd9xxx_mbhc_fw_read(struct work_struct *work)
sound/soc/codecs/wcd9xxx-mbhc.c-static void wcd9xxx_mbhc_insert_work(struct work_struct *work)
sound/soc/codecs/wcd9xxx-mbhc.c:	struct delayed_work *dwork;
sound/soc/codecs/wcd9xxx-mbhc.c:	struct delayed_work *dwork;
sound/soc/codecs/wcd9xxx-mbhc.c:	struct delayed_work *dwork;
sound/soc/codecs/wcd9xxx-mbhc.c-	struct snd_soc_codec *codec;
sound/soc/codecs/wcd9xxx-mbhc.c-	struct snd_soc_codec *codec;
sound/soc/codecs/wcd9xxx-mbhc.c-	struct wcd9xxx *core;
sound/soc/codecs/wcd9xxx-mbhc.c-	struct wcd9xxx_mbhc *mbhc;
sound/soc/codecs/wcd9xxx-mbhc.c-	struct wcd9xxx_mbhc *mbhc;
sound/soc/codecs/wcd9xxx-mbhc.c-				      usecs_to_jiffies(FW_READ_TIMEOUT));
sound/soc/codecs/wcd9xxx-mbhc.c-			WARN(1, "Button pressed twice without release event\n");
sound/soc/codecs/wcd9xxx-mbhc.c-		wcd9xxx_lock_sleep(core);
sound/soc/codecs/wm8350.c-
sound/soc/codecs/wm8350.c-
sound/soc/codecs/wm8350.c-
sound/soc/codecs/wm8350.c-
sound/soc/codecs/wm8350.c-
sound/soc/codecs/wm8350.c-
sound/soc/codecs/wm8350.c-
sound/soc/codecs/wm8350.c-
sound/soc/codecs/wm8350.c-{
sound/soc/codecs/wm8350.c-		break;
sound/soc/codecs/wm8350.c-		break;
sound/soc/codecs/wm8350.c:	cancel_delayed_work_sync(&priv->hpl.work);
sound/soc/codecs/wm8350.c:	cancel_delayed_work_sync(&priv->hpr.work);
sound/soc/codecs/wm8350.c:	    container_of(work, struct snd_soc_dapm_context, delayed_work.work);
sound/soc/codecs/wm8350.c:	flush_delayed_work(&codec->dapm.delayed_work);
sound/soc/codecs/wm8350.c:		if (!delayed_work_pending(&codec->dapm.delayed_work))
sound/soc/codecs/wm8350.c:		if (!delayed_work_pending(&codec->dapm.delayed_work))
sound/soc/codecs/wm8350.c-	/* if there was any work waiting then we run it now and
sound/soc/codecs/wm8350.c:	INIT_DELAYED_WORK(&codec->dapm.delayed_work, wm8350_pga_work);
sound/soc/codecs/wm8350.c-	INIT_DELAYED_WORK(&priv->hpl.work, wm8350_hpl_work);
sound/soc/codecs/wm8350.c-	INIT_DELAYED_WORK(&priv->hpr.work, wm8350_hpr_work);
sound/soc/codecs/wm8350.c-	int report;
sound/soc/codecs/wm8350.c-	int short_report;
sound/soc/codecs/wm8350.c-					      msecs_to_jiffies(1));
sound/soc/codecs/wm8350.c-					      msecs_to_jiffies(1));
sound/soc/codecs/wm8350.c-		out->active = 0;
sound/soc/codecs/wm8350.c-		out->active = 1;
sound/soc/codecs/wm8350.c-		pm_wakeup_event(wm8350->dev, 250);
sound/soc/codecs/wm8350.c-	priv->mic.jack = NULL;
sound/soc/codecs/wm8350.c-	return IRQ_HANDLED;
sound/soc/codecs/wm8350.c:			schedule_delayed_work(&codec->dapm.delayed_work,
sound/soc/codecs/wm8350.c:			schedule_delayed_work(&codec->dapm.delayed_work,
sound/soc/codecs/wm8350.c:	schedule_delayed_work(&jack->work, 200);
sound/soc/codecs/wm8350.c:	struct delayed_work work;
sound/soc/codecs/wm8350.c-	struct snd_soc_codec *codec = dapm->codec;
sound/soc/codecs/wm8350.c-	struct snd_soc_dapm_context *dapm =
sound/soc/codecs/wm8350.c-	struct snd_soc_jack *jack;
sound/soc/codecs/wm8350.c-	struct wm8350_data *wm8350_data = snd_soc_codec_get_drvdata(codec);
sound/soc/codecs/wm8350.c-struct wm8350_jack_data {
sound/soc/codecs/wm8350.c-	 * wait for its completion */
sound/soc/codecs/wm8350.c-	wm8350_clear_bits(wm8350, WM8350_POWER_MGMT_5, WM8350_CODEC_ENA);
sound/soc/codecs/wm8350.c-	wm8350_set_bias_level(codec, SND_SOC_BIAS_OFF);
sound/soc/codecs/wm8753.c-
sound/soc/codecs/wm8753.c-
sound/soc/codecs/wm8753.c-
sound/soc/codecs/wm8753.c-
sound/soc/codecs/wm8753.c-{
sound/soc/codecs/wm8753.c-	}
sound/soc/codecs/wm8753.c-	/* charge output caps */
sound/soc/codecs/wm8753.c-	codec->control_data = wm8753->regmap;
sound/soc/codecs/wm8753.c-		codec->dapm.bias_level = SND_SOC_BIAS_ON;
sound/soc/codecs/wm8753.c-		container_of(work, struct snd_soc_dapm_context,
sound/soc/codecs/wm8753.c:			     delayed_work.work);
sound/soc/codecs/wm8753.c:	flush_delayed_work(&codec->dapm.delayed_work);
sound/soc/codecs/wm8753.c:	INIT_DELAYED_WORK(&codec->dapm.delayed_work, wm8753_work);
sound/soc/codecs/wm8753.c-	int ret;
sound/soc/codecs/wm8753.c-			msecs_to_jiffies(caps_charge));
sound/soc/codecs/wm8753.c-			      msecs_to_jiffies(caps_charge));
sound/soc/codecs/wm8753.c:	schedule_delayed_work(&codec->dapm.delayed_work,
sound/soc/codecs/wm8753.c:		schedule_delayed_work(&codec->dapm.delayed_work,
sound/soc/codecs/wm8753.c-static int wm8753_remove(struct snd_soc_codec *codec)
sound/soc/codecs/wm8753.c-	struct snd_soc_codec *codec = dapm->codec;
sound/soc/codecs/wm8753.c-	struct snd_soc_dapm_context *dapm =
sound/soc/codecs/wm8753.c-	wm8753_set_bias_level(codec, dapm->bias_level);
sound/soc/codecs/wm8753.c-	wm8753_set_bias_level(codec, SND_SOC_BIAS_OFF);
sound/soc/codecs/wm8753.c-		wm8753_set_bias_level(codec, SND_SOC_BIAS_PREPARE);
sound/soc/codecs/wm8753.c-	wm8753_set_bias_level(codec, SND_SOC_BIAS_PREPARE);
sound/soc/codecs/wm8962.c-
sound/soc/codecs/wm8962.c-
sound/soc/codecs/wm8962.c-
sound/soc/codecs/wm8962.c-
sound/soc/codecs/wm8962.c-
sound/soc/codecs/wm8962.c-	}
sound/soc/codecs/wm8962.c:	cancel_delayed_work_sync(&wm8962->mic_work);
sound/soc/codecs/wm8962.c-		free_irq(wm8962->irq, codec);
sound/soc/codecs/wm8962.c-				      msecs_to_jiffies(250));
sound/soc/codecs/wm8962.c-		pm_wakeup_event(dev, 300);
sound/soc/codecs/wm8962.c:		schedule_delayed_work(&wm8962->mic_work,
sound/soc/codecs/wm8962.c:	struct delayed_work mic_work;
sound/soc/codecs/wm8962.c-	struct snd_soc_jack *jack;
sound/soc/codecs/wm8962.c-	u16 dsp2_ena;
sound/soc/codecs/wm8962.c-	wm8962_free_gpio(codec);
sound/soc/codecs/wm8971.c-
sound/soc/codecs/wm8971.c-
sound/soc/codecs/wm8971.c-	}
sound/soc/codecs/wm8971.c-	}
sound/soc/codecs/wm8971.c-		codec->dapm.bias_level = SND_SOC_BIAS_ON;
sound/soc/codecs/wm8971.c-	codec->dapm.bias_level = SND_SOC_BIAS_STANDBY;
sound/soc/codecs/wm8971.c-		container_of(work, struct snd_soc_dapm_context,
sound/soc/codecs/wm8971.c:			     delayed_work.work);
sound/soc/codecs/wm8971.c-	if (wm8971_workq == NULL)
sound/soc/codecs/wm8971.c:	INIT_DELAYED_WORK(&codec->dapm.delayed_work, wm8971_work);
sound/soc/codecs/wm8971.c-		msecs_to_jiffies(1000));
sound/soc/codecs/wm8971.c-			msecs_to_jiffies(1000));
sound/soc/codecs/wm8971.c:		queue_delayed_work(wm8971_workq, &codec->dapm.delayed_work,
sound/soc/codecs/wm8971.c:	queue_delayed_work(wm8971_workq, &codec->dapm.delayed_work,
sound/soc/codecs/wm8971.c-		snd_soc_write(codec, WM8971_PWR1, reg | 0x01c0);
sound/soc/codecs/wm8971.c-	snd_soc_write(codec, WM8971_PWR1, reg | 0x01c0);
sound/soc/codecs/wm8971.c-	struct snd_soc_codec *codec = dapm->codec;
sound/soc/codecs/wm8971.c-	struct snd_soc_dapm_context *dapm =
sound/soc/codecs/wm8971.c-	wm8971_set_bias_level(codec, codec->dapm.bias_level);
sound/soc/codecs/wm8971.c-	wm8971_workq = create_workqueue("wm8971");
sound/soc/msm/msm8230.c-
sound/soc/msm/msm8230.c-
sound/soc/msm/msm8230.c-};
sound/soc/msm/msm8230.c-			/* Delaying the amp power_on to remove the static noise
sound/soc/msm/msm8230.c-			during SPK_PA enable */
sound/soc/msm/msm8230.c-			&ext_amp_dwork.dwork,
sound/soc/msm/msm8230.c-			msecs_to_jiffies(50));
sound/soc/msm/msm8230.c:			schedule_delayed_work(
sound/soc/msm/msm8230.c:	struct delayed_work dwork;
sound/soc/msm/msm8230.c-struct ext_amp_work {
sound/soc/msm/msm8930.c-
sound/soc/msm/msm8930.c-
sound/soc/msm/msm8930.c-};
sound/soc/msm/msm8930.c-			/* Delaying the amp power_on to remove the static noise
sound/soc/msm/msm8930.c-			during SPK_PA enable */
sound/soc/msm/msm8930.c-			&ext_amp_dwork.dwork,
sound/soc/msm/msm8930.c-			msecs_to_jiffies(50));
sound/soc/msm/msm8930.c:			schedule_delayed_work(
sound/soc/msm/msm8930.c:	struct delayed_work dwork;
sound/soc/msm/msm8930.c-struct ext_amp_work {
sound/soc/msm/msm8960-d2.c-
sound/soc/msm/msm8960-d2.c-
sound/soc/msm/msm8960-d2.c-};
sound/soc/msm/msm8960-d2.c-			&bottom_amp_dwork.dwork,
sound/soc/msm/msm8960-d2.c-			/* Delaying the amp power_on to remove the static noise
sound/soc/msm/msm8960-d2.c-			during SPK_PA enable */
sound/soc/msm/msm8960-d2.c-			&ext_amp_dwork.dwork,
sound/soc/msm/msm8960-d2.c-#ifdef CONFIG_MACH_M2_ATT
sound/soc/msm/msm8960-d2.c-#if defined(CONFIG_MACH_AEGIS2)
sound/soc/msm/msm8960-d2.c-			msecs_to_jiffies(50));
sound/soc/msm/msm8960-d2.c:			schedule_delayed_work(
sound/soc/msm/msm8960-d2.c:			schedule_delayed_work(
sound/soc/msm/msm8960-d2.c:	struct delayed_work dwork;
sound/soc/msm/msm8960-d2.c-struct ext_amp_work {
sound/soc/msm/msm8960-d2.c-			usleep_range(4000, 4000);
sound/soc/msm/msm8960-jaguar.c-
sound/soc/msm/msm8960-jaguar.c-
sound/soc/msm/msm8960-jaguar.c-
sound/soc/msm/msm8960-jaguar.c-};
sound/soc/msm/msm8960-jaguar.c-			&ext_amp_dwork.dwork,
sound/soc/msm/msm8960-jaguar.c-			msecs_to_jiffies(50));
sound/soc/msm/msm8960-jaguar.c:			schedule_delayed_work(
sound/soc/msm/msm8960-jaguar.c:	struct delayed_work dwork;
sound/soc/msm/msm8960-jaguar.c-struct ext_amp_work {
sound/soc/msm/msm8960-jaguar.c-			usleep_range(4000, 4000);*/
sound/soc/soc-jack.c-
sound/soc/soc-jack.c-
sound/soc/soc-jack.c:		cancel_delayed_work_sync(&gpios[i].work);
sound/soc/soc-jack.c-		free_irq(gpio_to_irq(gpios[i].gpio), &gpios[i]);
sound/soc/soc-jack.c-		gpio_free(gpios[i].gpio);
sound/soc/soc-jack.c-		gpios[i].jack = NULL;
sound/soc/soc-jack.c-		gpio_unexport(gpios[i].gpio);
sound/soc/soc-jack.c-			      msecs_to_jiffies(gpio->debounce_time));
sound/soc/soc-jack.c-		pm_wakeup_event(dev, gpio->debounce_time + 50);
sound/soc/soc-jack.c:	schedule_delayed_work(&gpio->work,
sound/soc/soc-pcm.c-
sound/soc/soc-pcm.c-
sound/soc/soc-pcm.c-
sound/soc/soc-pcm.c-{
sound/soc/soc-pcm.c- */
sound/soc/soc-pcm.c-	}
sound/soc/soc-pcm.c-		}
sound/soc/soc-pcm.c:		cancel_delayed_work(&rtd->delayed_work);
sound/soc/soc-pcm.c-	    codec_dai->pop_wait) {
sound/soc/soc-pcm.c-		codec_dai->pop_wait = 0;
sound/soc/soc-pcm.c-			codec_dai->pop_wait = 1;
sound/soc/soc-pcm.c:			container_of(work, struct snd_soc_pcm_runtime, delayed_work.work);
sound/soc/soc-pcm.c- * due to DAPM power cycling.
sound/soc/soc-pcm.c:	INIT_DELAYED_WORK(&rtd->delayed_work, close_delayed_work);
sound/soc/soc-pcm.c-				msecs_to_jiffies(rtd->pmdown_time));
sound/soc/soc-pcm.c-	pcm->private_data = rtd;
sound/soc/soc-pcm.c-	rtd->pcm = pcm;
sound/soc/soc-pcm.c:			schedule_delayed_work(&rtd->delayed_work,
sound/soc/soc-pcm.c-			/* start delayed pop wq here for playback streams */
sound/soc/soc-pcm.c:static void close_delayed_work(struct work_struct *work)
sound/soc/soc-pcm.c-	struct snd_soc_dai *codec_dai = rtd->codec_dai;
sound/soc/soc-pcm.c-	struct snd_soc_pcm_runtime *rtd =
sound/soc/soc-pcm.c-	substream[SNDRV_PCM_STREAM_PLAYBACK] =
