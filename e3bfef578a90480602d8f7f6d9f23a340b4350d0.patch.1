From e3bfef578a90480602d8f7f6d9f23a340b4350d0 Mon Sep 17 00:00:00 2001
From: alucard24 <dmbaoh2@gmail.com>
Date: Fri, 14 Aug 2015 15:58:41 +0200
Subject: [PATCH] input: touchscreen: add alu-t-boost

---
 arch/arm/mach-msm/cpufreq.c              |  29 +++++
 arch/arm/mach-msm/include/mach/cpufreq.h |   5 +
 drivers/input/touchscreen/Kconfig        |   6 +
 drivers/input/touchscreen/Makefile       |   3 +-
 drivers/input/touchscreen/alu-t-boost.c  | 212 +++++++++++++++++++++++++++++++
 5 files changed, 254 insertions(+), 1 deletion(-)
 create mode 100644 drivers/input/touchscreen/alu-t-boost.c

diff --git a/arch/arm/mach-msm/cpufreq.c b/arch/arm/mach-msm/cpufreq.c
index 4d41233..bce0fe6 100644
--- a/arch/arm/mach-msm/cpufreq.c
+++ b/arch/arm/mach-msm/cpufreq.c
@@ -60,6 +60,20 @@ struct cpu_freq {
 
 static DEFINE_PER_CPU(struct cpu_freq, cpu_freq_info);
 
+static unsigned int lower_limit_freq[CONFIG_NR_CPUS];
+
+void set_cpu_min_lock(unsigned int cpu, int freq)
+{
+	if (cpu >= 0 && cpu < CONFIG_NR_CPUS) {
+		if (freq <= CONFIG_MSM_CPU_FREQ_MIN ||
+			freq > CONFIG_MSM_CPU_FREQ_MAX)
+			lower_limit_freq[cpu] = 0;
+		else
+			lower_limit_freq[cpu] = freq;
+	}
+}
+EXPORT_SYMBOL(set_cpu_min_lock);
+
 static int set_cpu_freq(struct cpufreq_policy *policy, unsigned int new_freq)
 {
 	int ret = 0;
@@ -68,6 +82,21 @@ static int set_cpu_freq(struct cpufreq_policy *policy, unsigned int new_freq)
 	struct cpufreq_freqs freqs;
 	struct cpu_freq *limit = &per_cpu(cpu_freq_info, policy->cpu);
 	struct sched_param param = { .sched_priority = MAX_RT_PRIO-1 };
+	unsigned int ll_freq = lower_limit_freq[policy->cpu];
+
+	if (ll_freq) {
+		unsigned int t_freq = new_freq;
+
+		if (ll_freq && new_freq < ll_freq)
+			t_freq = ll_freq;
+
+		new_freq = t_freq;
+
+		if (new_freq < policy->min)
+			new_freq = policy->min;
+		if (new_freq > policy->max)
+			new_freq = policy->max;
+	}
 
 	if (limit->limits_init) {
 		if (new_freq > limit->allowed_max) {
diff --git a/arch/arm/mach-msm/include/mach/cpufreq.h b/arch/arm/mach-msm/include/mach/cpufreq.h
index 1a6f2d9..0b925a4 100644
--- a/arch/arm/mach-msm/include/mach/cpufreq.h
+++ b/arch/arm/mach-msm/include/mach/cpufreq.h
@@ -31,12 +31,17 @@
  */
 extern int msm_cpufreq_set_freq_limits(
 		uint32_t cpu, uint32_t min, uint32_t max);
+extern void set_cpu_min_lock(unsigned int cpu, int freq);
 #else
 static inline int msm_cpufreq_set_freq_limits(
 		uint32_t cpu, uint32_t min, uint32_t max)
 {
 	return -ENOSYS;
 }
+static void set_cpu_min_lock(unsigned int cpu, int freq)
+{
+	return -ENOSYS;
+}
 #endif
 
 #endif /* __ARCH_ARM_MACH_MSM_MACH_CPUFREQ_H */
diff --git a/drivers/input/touchscreen/Kconfig b/drivers/input/touchscreen/Kconfig
index b8a9850..ad6d46e 100644
--- a/drivers/input/touchscreen/Kconfig
+++ b/drivers/input/touchscreen/Kconfig
@@ -1032,4 +1032,10 @@ config TOUCHSCREEN_SWEEP2SLEEP
 	tristate "Sweep2Sleep for touchscreens"
 	default y
 
+config ALUCARD_TOUCHSCREEN_BOOST
+	tristate "Touchscreen boost"
+	default y
+	help
+	  Alucard touchscreen boost.
+
 endif
diff --git a/drivers/input/touchscreen/Makefile b/drivers/input/touchscreen/Makefile
index bd5c580..3064aa6 100644
--- a/drivers/input/touchscreen/Makefile
+++ b/drivers/input/touchscreen/Makefile
@@ -6,7 +6,6 @@
 
 wm97xx-ts-y := wm97xx-core.o
 
-obj-$(CONFIG_TOUCHSCREEN_SWEEP2SLEEP)	+= sweep2sleep.o
 obj-$(CONFIG_TOUCHSCREEN_88PM860X)	+= 88pm860x-ts.o
 obj-$(CONFIG_TOUCHSCREEN_AD7877)	+= ad7877.o
 obj-$(CONFIG_TOUCHSCREEN_AD7879)	+= ad7879.o
@@ -90,3 +89,5 @@ obj-$(CONFIG_TOUCHSCREEN_FT5X06)	+= ft5x06_ts.o
 obj-$(CONFIG_TOUCHSCREEN_SYNAPTICS_I2C_RMI4)		+= synaptics_i2c_rmi4.o
 obj-$(CONFIG_TOUCHSCREEN_SYNAPTICS_DSX_RMI4_DEV)	+= synaptics_rmi_dev.o
 obj-$(CONFIG_TOUCHSCREEN_SYNAPTICS_DSX_FW_UPDATE) 	+= synaptics_fw_update.o
+obj-$(CONFIG_TOUCHSCREEN_SWEEP2SLEEP)	+= sweep2sleep.o
+obj-$(CONFIG_ALUCARD_TOUCHSCREEN_BOOST)	+= alu-t-boost.o
diff --git a/drivers/input/touchscreen/alu-t-boost.c b/drivers/input/touchscreen/alu-t-boost.c
new file mode 100644
index 0000000..d6c8783
--- /dev/null
+++ b/drivers/input/touchscreen/alu-t-boost.c
@@ -0,0 +1,212 @@
+/*
+ * Copyright (c) 2013-2014, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/*
+	Based on cpuboost and created by Alucard24@XDA.
+*/
+
+#define pr_fmt(fmt) "alu-t-boost: " fmt
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/notifier.h>
+#include <mach/cpufreq.h>
+#include <linux/cpufreq.h>
+#include <linux/cpu.h>
+#include <linux/sched.h>
+#include <linux/jiffies.h>
+#include <linux/moduleparam.h>
+#include <linux/slab.h>
+#include <linux/input.h>
+#include <linux/time.h>
+
+/*
+ * debug = 1 will print all
+ */
+static unsigned int debug = 0;
+module_param_named(debug_mask, debug, uint, 0644);
+
+#define dprintk(msg...)		\
+do {				\
+	if (debug)		\
+		pr_info(msg);	\
+} while (0)
+
+static struct workqueue_struct *touch_boost_wq;
+static struct delayed_work input_boost_rem;
+static struct work_struct input_boost_work;
+
+static unsigned int input_boost_freq;
+module_param(input_boost_freq, uint, 0644);
+
+static unsigned int input_boost_ms = 40;
+module_param(input_boost_ms, uint, 0644);
+
+static unsigned int nr_boost_cpus = 4;
+module_param(nr_boost_cpus, uint, 0644);
+
+static u64 last_input_time;
+
+static unsigned int min_input_interval = 150;
+module_param(min_input_interval, uint, 0644);
+
+static void do_input_boost_rem(struct work_struct *work)
+{
+	unsigned int i;
+
+	for_each_possible_cpu(i) {
+		dprintk("Removing input boost for CPU%u\n", i);
+		set_cpu_min_lock(i, 0);
+	}
+}
+
+static void do_input_boost(struct work_struct *work)
+{
+	unsigned int i;
+	unsigned nr_cpus = nr_boost_cpus;
+
+	cancel_delayed_work_sync(&input_boost_rem);
+
+	if (nr_cpus <= 0)
+		nr_cpus = 1;
+	else if (nr_cpus > NR_CPUS)
+		nr_cpus = NR_CPUS;
+
+	for (i = 0; i < nr_cpus; i++) {
+		struct cpufreq_policy policy;
+		unsigned int cur = 0;
+
+		dprintk("Input boost for CPU%u\n", i);
+		set_cpu_min_lock(i, input_boost_freq);
+
+		if (cpu_online(i)) {
+			cur = cpufreq_quick_get(i);
+			if (cur < input_boost_freq && cur > 0) {
+				policy.cpu = i;
+				cpufreq_driver_target(&policy,
+					input_boost_freq, CPUFREQ_RELATION_L);
+			}
+		}
+	}
+
+	queue_delayed_work_on(0, touch_boost_wq,
+			&input_boost_rem,
+			msecs_to_jiffies(input_boost_ms));
+}
+
+static void touchboost_input_event(struct input_handle *handle,
+		unsigned int type, unsigned int code, int value)
+{
+	u64 now;
+
+	if (!input_boost_freq)
+		return;
+
+	now = ktime_to_us(ktime_get());
+	if ((now - last_input_time) < (min_input_interval * USEC_PER_MSEC))
+		return;
+
+	if (work_pending(&input_boost_work))
+		return;
+
+	dprintk("Input boost for input event.\n");
+
+	queue_work(touch_boost_wq, &input_boost_work);
+	last_input_time = ktime_to_us(ktime_get());
+}
+
+static int touchboost_input_connect(struct input_handler *handler,
+		struct input_dev *dev, const struct input_device_id *id)
+{
+	struct input_handle *handle;
+	int error;
+
+	handle = kzalloc(sizeof(struct input_handle), GFP_KERNEL);
+	if (!handle)
+		return -ENOMEM;
+
+	handle->dev = dev;
+	handle->handler = handler;
+	handle->name = handler->name;
+
+	error = input_register_handle(handle);
+	if (error)
+		goto err2;
+
+	error = input_open_device(handle);
+	if (error)
+		goto err1;
+
+	return 0;
+err1:
+	input_unregister_handle(handle);
+err2:
+	kfree(handle);
+	return error;
+}
+
+static void touchboost_input_disconnect(struct input_handle *handle)
+{
+	input_close_device(handle);
+	input_unregister_handle(handle);
+	kfree(handle);
+}
+
+static const struct input_device_id touchboost_ids[] = {
+	/* multi-touch touchscreen */
+	{
+		.flags = INPUT_DEVICE_ID_MATCH_EVBIT |
+			INPUT_DEVICE_ID_MATCH_ABSBIT,
+		.evbit = { BIT_MASK(EV_ABS) },
+		.absbit = { [BIT_WORD(ABS_MT_POSITION_X)] =
+			BIT_MASK(ABS_MT_POSITION_X) |
+			BIT_MASK(ABS_MT_POSITION_Y) },
+	},
+	/* touchpad */
+	{
+		.flags = INPUT_DEVICE_ID_MATCH_KEYBIT |
+			INPUT_DEVICE_ID_MATCH_ABSBIT,
+		.keybit = { [BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH) },
+		.absbit = { [BIT_WORD(ABS_X)] =
+			BIT_MASK(ABS_X) | BIT_MASK(ABS_Y) },
+	},
+	{ },
+};
+
+static struct input_handler touchboost_input_handler = {
+	.event          = touchboost_input_event,
+	.connect        = touchboost_input_connect,
+	.disconnect     = touchboost_input_disconnect,
+	.name           = "alu-t-boost",
+	.id_table       = touchboost_ids,
+};
+
+
+static int touch_boost_init(void)
+{
+	int ret;
+
+	touch_boost_wq = alloc_workqueue("touch_boost_wq", WQ_HIGHPRI, 0);
+	if (!touch_boost_wq)
+		return -EFAULT;
+
+	INIT_WORK(&input_boost_work, do_input_boost);
+	INIT_DELAYED_WORK(&input_boost_rem, do_input_boost_rem);
+
+	ret = input_register_handler(&touchboost_input_handler);
+	if (ret)
+		pr_err("Cannot register touchboost input handler.\n");
+
+	return ret;
+}
+late_initcall(touch_boost_init);
