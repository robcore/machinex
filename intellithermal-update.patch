From 0fc69ea314a2c71d1ba5fedae1e4aa6dabdbaeaf Mon Sep 17 00:00:00 2001
From: Hybridmax <hybridmax95@gmail.com>
Date: Sun, 8 Mar 2015 01:47:43 +0100
Subject: [PATCH] intelli/msm_thermal: Updated to newest Code

Signed-off-by: Paul Reioux <reioux@gmail.com>
---
 drivers/thermal/intelli/msm_thermal.c | 38 +++++++++++++++++++++++------------
 1 file changed, 25 insertions(+), 13 deletions(-)

diff --git a/drivers/thermal/intelli/msm_thermal.c b/drivers/thermal/intelli/msm_thermal.c
index 60b926f..6cd6f00 100644
--- a/drivers/thermal/intelli/msm_thermal.c
+++ b/drivers/thermal/intelli/msm_thermal.c
@@ -11,7 +11,7 @@
  *
  * Added code to work as a standalone intelligent thermal throttling driver
  * for many Qualcomm SOCs by Paul Reioux (Faux123)
- * Modifications copyright (c) 2013
+ * Modifications copyright (c) 2013~2014
  *
  */
 
@@ -27,7 +27,7 @@
 #include <linux/msm_thermal.h>
 #include <mach/cpufreq.h>
 
-#define DEFAULT_POLLING_MS	250
+#define DEFAULT_POLLING_MS	500
 /* last 3 minutes based on 250ms polling cycle */
 #define MAX_HISTORY_SZ		((3*60*1000) / DEFAULT_POLLING_MS)
 
@@ -40,9 +40,20 @@ struct msm_thermal_stat_data {
 static struct msm_thermal_stat_data msm_thermal_stats;
 
 static int enabled;
-static struct msm_thermal_data msm_thermal_info;
-static uint32_t limited_max_freq = MSM_CPUFREQ_NO_LIMIT;
+static struct msm_thermal_data msm_thermal_info = {
+	.sensor_id = 5,
+	.poll_ms = DEFAULT_POLLING_MS,
+	.limit_temp_degC = 80,
+	.temp_hysteresis_degC = 10,
+	.freq_step = 2,
+	.freq_control_mask = 0xf,
+	.core_limit_temp_degC = 85,
+	.core_temp_hysteresis_degC = 10,
+	.core_control_mask = 0xe,
+};
+static uint32_t limited_max_freq_thermal = MSM_CPUFREQ_NO_LIMIT;
 static struct delayed_work check_temp_work;
+static struct workqueue_struct *intellithermal_wq;
 static bool core_control_enabled;
 static uint32_t cpus_offlined;
 static DEFINE_MUTEX(core_control_mutex);
@@ -97,7 +108,7 @@ static int update_cpu_max_freq(int cpu, uint32_t max_freq)
 	if (ret)
 		return ret;
 
-	limited_max_freq = max_freq;
+	limited_max_freq_thermal = max_freq;
 	if (max_freq != MSM_CPUFREQ_NO_LIMIT)
 		pr_info("%s: Limiting cpu%d max frequency to %d\n",
 				KBUILD_MODNAME, cpu, max_freq);
@@ -177,7 +188,7 @@ static void __ref do_freq_control(long temp)
 {
 	int ret = 0;
 	int cpu = 0;
-	uint32_t max_freq = limited_max_freq;
+	uint32_t max_freq = limited_max_freq_thermal;
 
 	if (temp >= msm_thermal_info.limit_temp_degC) {
 		if (limit_idx == limit_idx_low)
@@ -200,7 +211,7 @@ static void __ref do_freq_control(long temp)
 			max_freq = table[limit_idx].frequency;
 	}
 
-	if (max_freq == limited_max_freq)
+	if (max_freq == limited_max_freq_thermal)
 		return;
 
 	
@@ -252,7 +263,7 @@ static void __ref check_temp(struct work_struct *work)
 	//pr_info("msm_thermal: worker is alive!\n");
 reschedule:
 	if (enabled)
-		schedule_delayed_work(&check_temp_work,
+		queue_delayed_work(intellithermal_wq, &check_temp_work,
 				msecs_to_jiffies(msm_thermal_info.poll_ms));
 }
 
@@ -290,9 +301,7 @@ static void __ref disable_msm_thermal(void)
 	int cpu = 0;
 
 	
-	cancel_delayed_work_sync(&check_temp_work);
-	//flush_scheduled_work();
-
+	flush_workqueue(intellithermal_wq);
 
 	for_each_possible_cpu(cpu) {
 		update_cpu_max_freq(cpu, MSM_CPUFREQ_NO_LIMIT);
@@ -310,7 +319,8 @@ static int __ref set_enabled(const char *val, const struct kernel_param *kp)
 	} else {
 		if (!enabled) {
 			enabled = 1;
-			schedule_delayed_work(&check_temp_work, 0);
+			queue_delayed_work(intellithermal_wq,
+					   &check_temp_work, 0);
 			pr_info("msm_thermal: rescheduling...\n");
 		} else
 			pr_info("msm_thermal: already running...\n");
@@ -569,8 +579,10 @@ int __init msm_thermal_init(struct msm_thermal_data *pdata)
 	enabled = 1;
 	if (num_possible_cpus() > 1)
 		core_control_enabled = 1;
+	intellithermal_wq = alloc_workqueue("intellithermal",
+				WQ_UNBOUND | WQ_MEM_RECLAIM, 1);
 	INIT_DELAYED_WORK(&check_temp_work, check_temp);
-	schedule_delayed_work(&check_temp_work, 0);
+	queue_delayed_work(intellithermal_wq, &check_temp_work, 0);
 
 	if (num_possible_cpus() > 1)
 		register_cpu_notifier(&msm_thermal_cpu_notifier);
