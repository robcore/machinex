From c91ebd10fa275d1d4ff713b752fb2bb841ba7a11 Mon Sep 17 00:00:00 2001
From: Tkkg1994 <luca.grifo@outlook.com>
Date: Fri, 22 May 2015 13:28:31 +0200
Subject: [PATCH] fastcharge: update to latest driver from Yank-lu, big thanks
 to Him we can now hopefully control the wireless charging progress and have
 some more values to choose

msm:qseecom: Add validation checks for memory cleanup for qseecom

Add validation checks to handle memory freeing &
prevent NULL pointer access.

Change-Id: I7383b10037ca0ce3f049de060dc70f3ad4b9ca55
Signed-off-by: Hariprasad Dhalinarasimha <hnamgund@codeaurora.org>
---
 arch/arm/mach-msm/board-fusion3-battery.c |   7 +-
 arch/arm/mach-msm/fastchg.c               | 132 +++++++++++++++++++++++++-----
 drivers/battery/max77693_charger.c        |  15 +++-
 drivers/misc/qseecom.c                    |   3 +
 include/linux/fastchg.h                   |  36 ++++++--
 5 files changed, 160 insertions(+), 33 deletions(-)

diff --git a/arch/arm/mach-msm/board-fusion3-battery.c b/arch/arm/mach-msm/board-fusion3-battery.c
index c6c4040..b85fbf1 100755
--- a/arch/arm/mach-msm/board-fusion3-battery.c
+++ b/arch/arm/mach-msm/board-fusion3-battery.c
@@ -366,6 +366,8 @@ static int sec_bat_get_cable_from_extended_cable_type(
 				charge_current_max = USB_CHARGE_1000;
 				charge_current     = USB_CHARGE_1000;
 				break;
+			default:		/* Don't do anything for any other kind of connections and don't touch when type is unknown */
+				break;
 
 		}
 	/* We are in advanced Fast Charge mode, so we apply custom charging
@@ -387,9 +389,10 @@ static int sec_bat_get_cable_from_extended_cable_type(
 			   for all of them */
 			case POWER_SUPPLY_TYPE_MAINS:
 				charge_current_max = ac_charge_level;
-				/* but never go above 1.9A */
+				/* but never go above 2.1A */
 				charge_current     =
-					min(ac_charge_level, MAX_CHARGE_LEVEL);
+				/* Keep the 300mA/h delta, but never go above 2.1A/h */
+					min(ac_charge_level+300, MAX_CHARGE_LEVEL);
 				break;
 			/* Don't do anything for any other kind of connections
 			   and don't touch when type is unknown */
diff --git a/arch/arm/mach-msm/fastchg.c b/arch/arm/mach-msm/fastchg.c
index 77b468a..08fecf6 100755
--- a/arch/arm/mach-msm/fastchg.c
+++ b/arch/arm/mach-msm/fastchg.c
@@ -5,7 +5,7 @@
  * Adapted for 9505 from Note 3:
  * Paul Reioux <reioux@gmail.com>
  *
- * Modded by ktoonsez from Jean-Pierre and Faux's original implementation:
+ * Modded by ktoonsez and Tkkg1994 from Jean-Pierre and Faux's original implementation:
  *
  * This software is licensed under the terms of the GNU General Public
  * License version 2, as published by the Free Software Foundation, and
@@ -46,6 +46,10 @@
  *
  *   rate at which to charge when on USB (0.460A/h to 1.0A/h)
  *
+ * /sys/kernel/fast_charge/wireless_charge_level (r/w)
+ *
+ *   rate at which to charge when on WIRELESS (0.650A/h to 1.2A/h)
+ *
  * /sys/kernel/fast_charge/failsafe (rw)
  *
  *   0 - disabled - allow anything up to 2.1A/h to be used as AC / USB custom current
@@ -59,6 +63,10 @@
  *
  *   display available levels for USB (for failsafe enabled mode)
  *
+ * /sys/kernel/fast_charge/wireless_levels (ro)
+ *
+ *   display available levels for WIRELESS (for failsafe enabled mode)
+ *
  * /sys/kernel/fast_charge/version (ro)
  *
  *   display fast charge version information
@@ -201,10 +209,18 @@ static ssize_t ac_charge_level_store(struct kobject *kobj,
 	else {
 
 		switch (new_ac_charge_level) {
-			case AC_CHARGE_500:
 			case AC_CHARGE_1000:
-			case AC_CHARGE_1450:
+			case AC_CHARGE_1100:
+			case AC_CHARGE_1200:
+			case AC_CHARGE_1300:
+			case AC_CHARGE_1400:
+			case AC_CHARGE_1500:
+			case AC_CHARGE_1600:
+			case AC_CHARGE_1700:
+			case AC_CHARGE_1800:
 			case AC_CHARGE_1900:
+			case AC_CHARGE_2000:
+			case AC_CHARGE_2100:
 				ac_charge_level = new_ac_charge_level;
 				return count;
 			default:
@@ -253,7 +269,11 @@ static ssize_t usb_charge_level_store(struct kobject *kobj,
 
 		switch (new_usb_charge_level) {
 			case USB_CHARGE_460:
+			case USB_CHARGE_500:
+			case USB_CHARGE_600:
 			case USB_CHARGE_700:
+			case USB_CHARGE_800:
+			case USB_CHARGE_900:
 			case USB_CHARGE_1000:
 				usb_charge_level = new_usb_charge_level;
 				return count;
@@ -272,6 +292,58 @@ static struct kobj_attribute usb_charge_level_attribute =
 		usb_charge_level_show,
 		usb_charge_level_store);
 
+/* sysfs interface for "wireless_charge_level" */
+
+int wireless_charge_level;
+
+static ssize_t wireless_charge_level_show(struct kobject *kobj,
+		struct kobj_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", wireless_charge_level);
+}
+
+static ssize_t wireless_charge_level_store(struct kobject *kobj,
+		struct kobj_attribute *attr, const char *buf, size_t count)
+{
+
+	int new_wireless_charge_level;
+
+	sscanf(buf, "%du", &new_wireless_charge_level);
+
+	if (failsafe == FAIL_SAFE_DISABLED &&
+		new_wireless_charge_level <= MAX_CHARGE_LEVEL) {
+
+		wireless_charge_level = new_wireless_charge_level;
+		return count;
+
+	}
+
+	else {
+
+		switch (new_wireless_charge_level) {
+			case WIRELESS_CHARGE_650:
+			case WIRELESS_CHARGE_800:
+			case WIRELESS_CHARGE_900:
+			case WIRELESS_CHARGE_1000:
+			case WIRELESS_CHARGE_1100:
+			case WIRELESS_CHARGE_1200:
+				wireless_charge_level = new_wireless_charge_level;
+				return count;
+			default:			
+				return -EINVAL;
+		}
+
+	}
+
+	return -EINVAL;
+
+}
+
+static struct kobj_attribute wireless_charge_level_attribute =
+	__ATTR(wireless_charge_level, 0666,
+		wireless_charge_level_show,
+		wireless_charge_level_store);
+
 /* sysfs interface for "failsafe" */
 
 int failsafe;
@@ -294,7 +366,7 @@ static ssize_t failsafe_store(struct kobject *kobj,
 	switch (new_failsafe) {
 		case FAIL_SAFE_ENABLED:
 			usb_charge_level = USB_CHARGE_460;
-			ac_charge_level = AC_CHARGE_1000;
+			ac_charge_level = AC_CHARGE_1800;
 			failsafe = new_failsafe;
 			return count;
 		case FAIL_SAFE_DISABLED:
@@ -328,6 +400,16 @@ static ssize_t usb_levels_show(struct kobject *kobj,
 static struct kobj_attribute usb_levels_attribute =
 	__ATTR(usb_levels, 0444, usb_levels_show, NULL);
 
+/* sysfs interface for "wireless_levels" */
+static ssize_t wireless_levels_show(struct kobject *kobj,
+		struct kobj_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%s\n", WIRELESS_LEVELS);
+}
+
+static struct kobj_attribute wireless_levels_attribute =
+	__ATTR(wireless_levels, 0444, wireless_levels_show, NULL);
+
 /* sysfs interface for "info" */
 static ssize_t info_show(struct kobject *kobj,
 		struct kobj_attribute *attr, char *buf)
@@ -335,28 +417,32 @@ static ssize_t info_show(struct kobject *kobj,
 	return sprintf(
 		buf,
 		"Forced Fast Charge for Samsung Galaxy S4 Qualcomm %s\n\n"
-		"Fast charge mode : %s\n"
+		"Fast charge mode      : %s\n"
 		"MTP while charging mode : %s\n"
 		"Screen on Current Limit mode : %s\n"
-		"Custom  AC level : %dmA/h\n"
-		"Custom USB level : %dmA/h\n"
-		"Failsafe mode    : %s\n"
-		"Valid AC  levels : %s\n"
-		"Valid USB levels : %s\n",
+		"Custom  AC level      : %dmA/h\n"
+		"Custom USB level      : %dmA/h\n"
+		"Custom Wireless level : %dmA/h\n"
+		"Failsafe mode         : %s\n"
+		"Valid AC  levels      : %s\n"
+		"Valid USB levels      : %s\n"
+		"Valid Wireless levels : %s\n",
 		 FAST_CHARGE_VERSION,
 		 force_fast_charge == FAST_CHARGE_DISABLED 	   ? "0 - Disabled (default)" :
 		(force_fast_charge == FAST_CHARGE_FORCE_AC         ? "1 - Use stock AC level on USB" :
 		(force_fast_charge == FAST_CHARGE_FORCE_CUSTOM_MA  ? "2 - Use custom mA on AC and USB" : "Problem : value out of range")),
 		 use_mtp_during_fast_charge          == USE_MTP_DURING_FAST_CHARGE_DISABLED           ? "0 - Disabled" :
 		(use_mtp_during_fast_charge          == USE_MTP_DURING_FAST_CHARGE_ENABLED            ? "1 - Enabled" : "Problem : value out of range"),
-		 screen_on_current_limit          == SCREEN_ON_CURRENT_LIMIT_DISABLED           ? "0 - Disabled" :
-		(screen_on_current_limit          == SCREEN_ON_CURRENT_LIMIT_ENABLED            ? "1 - Enabled" : "Problem : value out of range"),
+		 screen_on_current_limit             == SCREEN_ON_CURRENT_LIMIT_DISABLED              ? "0 - Disabled" :
+		(screen_on_current_limit             == SCREEN_ON_CURRENT_LIMIT_ENABLED               ? "1 - Enabled" : "Problem : value out of range"),
 		 ac_charge_level,
 		 usb_charge_level,
+		 wireless_charge_level,
 		 failsafe          == FAIL_SAFE_DISABLED           ? "0 - Failsafe disabled - please be careful !" :
 		(failsafe          == FAIL_SAFE_ENABLED            ? "1 - Failsafe active (default)" : "Problem : value out of range"),
 		 failsafe          == FAIL_SAFE_ENABLED            ? AC_LEVELS : ANY_LEVELS,
-		 failsafe          == FAIL_SAFE_ENABLED            ? USB_LEVELS : ANY_LEVELS
+		 failsafe          == FAIL_SAFE_ENABLED            ? USB_LEVELS : ANY_LEVELS,
+		 failsafe          == FAIL_SAFE_ENABLED            ? WIRELESS_LEVELS : ANY_LEVELS
 		);
 }
 
@@ -382,9 +468,11 @@ static struct attribute *force_fast_charge_attrs[] = {
 	&screen_on_current_limit_attribute.attr,
 	&ac_charge_level_attribute.attr,
 	&usb_charge_level_attribute.attr,
+	&wireless_charge_level_attribute.attr,
 	&failsafe_attribute.attr,
 	&ac_levels_attribute.attr,
 	&usb_levels_attribute.attr,
+	&wireless_levels_attribute.attr,
 	&info_attribute.attr,
 	&version_attribute.attr,
 	NULL,
@@ -404,26 +492,26 @@ int force_fast_charge_init(void)
 	use_mtp_during_fast_charge = USE_MTP_DURING_FAST_CHARGE_ENABLED;
 	/* Use Samsung Screen ON current limit while charging, enabled by default */
 	screen_on_current_limit = SCREEN_ON_CURRENT_LIMIT_ENABLED;
-	/* Default AC charge level to 1900mA/h    */
-	ac_charge_level   = AC_CHARGE_1900;
+	/* Default AC charge level to 1800mA/h    */
+	ac_charge_level       = AC_CHARGE_1800;
 	/* Default USB charge level to 460mA/h    */
-	usb_charge_level  = USB_CHARGE_460;
+	usb_charge_level      = USB_CHARGE_460;
+	/* Default USB charge level to 650mA/h    */
+	wireless_charge_level = WIRELESS_CHARGE_650;
 	/* Allow only values in list by default   */
-	failsafe          = FAIL_SAFE_ENABLED;
+	failsafe              = FAIL_SAFE_ENABLED;
 
         force_fast_charge_kobj =
 		kobject_create_and_add("fast_charge", kernel_kobj);
-
-        if (!force_fast_charge_kobj)
+        if (!force_fast_charge_kobj) {
                 return -ENOMEM;
-
+	}
         force_fast_charge_retval =
 		sysfs_create_group(force_fast_charge_kobj,
 			&force_fast_charge_attr_group);
 
         if (force_fast_charge_retval)
                 kobject_put(force_fast_charge_kobj);
-
         return (force_fast_charge_retval);
 }
 /* end sysfs interface */
@@ -438,4 +526,4 @@ module_exit(force_fast_charge_exit);
 MODULE_LICENSE("GPL v2");
 MODULE_AUTHOR("Jean-Pierre Rasquin <yank555.lu@gmail.com>");
 MODULE_AUTHOR("Paul Reioux <reioux@gmail.com>");
-MODULE_DESCRIPTION("Fast Charge Hack for Android");
+MODULE_DESCRIPTION("Fast Charge Hack for Android");
\ No newline at end of file
diff --git a/drivers/battery/max77693_charger.c b/drivers/battery/max77693_charger.c
index 739ddff..181d8df 100755
--- a/drivers/battery/max77693_charger.c
+++ b/drivers/battery/max77693_charger.c
@@ -22,13 +22,12 @@
 #define ENABLE 1
 #define DISABLE 0
 
-
 #define RECOVERY_DELAY		3000
 #define RECOVERY_CNT		5
 #define REDUCE_CURRENT_STEP	100
 #define MINIMUM_INPUT_CURRENT	300
 #define SIOP_INPUT_LIMIT_CURRENT 1200
-#define SIOP_CHARGING_LIMIT_CURRENT 1000
+#define SIOP_CHARGING_LIMIT_CURRENT 1200
 
 struct max77693_charger_data {
 	struct max77693_dev	*max77693;
@@ -915,6 +914,18 @@ static int sec_chg_set_property(struct power_supply *psy,
 	case POWER_SUPPLY_PROP_CHARGE_TYPE:
 		if(val->intval == POWER_SUPPLY_TYPE_WIRELESS) {
 			u8 reg_data;
+#ifdef CONFIG_FORCE_FAST_CHARGE
+				/* Yank555 : Use Fast charge currents accroding to user settings */
+				if (force_fast_charge == FAST_CHARGE_FORCE_AC) {
+					/* We are in basic Fast Charge mode, so we substitute AC to WIRELESS levels */
+					charger->charging_current_max = WIRELESS_CHARGE_1000;
+					charger->charging_current = WIRELESS_CHARGE_1000 + 100;
+				} else if (force_fast_charge == FAST_CHARGE_FORCE_CUSTOM_MA) {
+					/* We are in custom current Fast Charge mode for WIRELESS */
+					charger->charging_current_max = wireless_charge_level;
+					charger->charging_current = min(wireless_charge_level+100, MAX_CHARGE_LEVEL);
+				}
+#endif
 			max77693_read_reg(charger->max77693->i2c,
 				MAX77693_CHG_REG_CHG_CNFG_12, &reg_data);
 			reg_data &= ~(1 << 5);
diff --git a/drivers/misc/qseecom.c b/drivers/misc/qseecom.c
index b594262..7e80bb4 100755
--- a/drivers/misc/qseecom.c
+++ b/drivers/misc/qseecom.c
@@ -736,6 +736,9 @@ static int qseecom_load_app(struct qseecom_dev_handle *data, void __user *argp)
 			&resp, sizeof(resp));
 		if (ret) {
 			pr_err("scm_call to load app failed\n");
+			if (!IS_ERR_OR_NULL(ihandle))
+				ion_free(qseecom.ion_clnt, ihandle);
+			qsee_disable_clock_vote(CLK_SFPB);
 			return -EINVAL;
 		}
 
diff --git a/include/linux/fastchg.h b/include/linux/fastchg.h
index 26fc7ee..404e889 100755
--- a/include/linux/fastchg.h
+++ b/include/linux/fastchg.h
@@ -22,10 +22,11 @@
 #ifndef _LINUX_FASTCHG_H
 #define _LINUX_FASTCHG_H
 
-#define FAST_CHARGE_VERSION "v1.1 by Ktoonsez from Jean-Pierre and Paul Reioux original implementation"
-#define AC_LEVELS  "500 1000 1450 1900"
-#define USB_LEVELS "460 700 1000"
-#define ANY_LEVELS "0 to 1900"
+#define FAST_CHARGE_VERSION "v1.2 by Yank555.lu, ktoonsez & Tkkg1994"
+#define AC_LEVELS  "1000 1100 1200 1300 1400 1500 1600 1700 1800 1900 2000 2100"
+#define USB_LEVELS "460 500 600 700 800 900 1000"
+#define WIRELESS_LEVELS "650 800 900 1000 1100 1200"
+#define ANY_LEVELS "0 to 2100"
 
 extern int force_fast_charge;
 
@@ -45,19 +46,40 @@ extern int screen_on_current_limit;
 
 extern int ac_charge_level;
 
-#define AC_CHARGE_500 500
 #define AC_CHARGE_1000 1000
-#define AC_CHARGE_1450 1300
+#define AC_CHARGE_1100 1100
+#define AC_CHARGE_1200 1200
+#define AC_CHARGE_1300 1300
+#define AC_CHARGE_1400 1400
+#define AC_CHARGE_1500 1500
+#define AC_CHARGE_1600 1600
+#define AC_CHARGE_1700 1700
+#define AC_CHARGE_1800 1800	/* default */
 #define AC_CHARGE_1900 1900
+#define AC_CHARGE_2000 2000
+#define AC_CHARGE_2100 2100
 
 extern int usb_charge_level;
 
 #define USB_CHARGE_460 460	/* default */
+#define USB_CHARGE_500 500
+#define USB_CHARGE_600 600
 #define USB_CHARGE_700 700
+#define USB_CHARGE_800 800
+#define USB_CHARGE_900 900
 #define USB_CHARGE_1000 1000
 
+extern int wireless_charge_level;
+
+#define WIRELESS_CHARGE_650 650	/* default */
+#define WIRELESS_CHARGE_800 800
+#define WIRELESS_CHARGE_900 900
+#define WIRELESS_CHARGE_1000 1000
+#define WIRELESS_CHARGE_1100 1100
+#define WIRELESS_CHARGE_1200 1200
+
 /* Whatever happens, this is the limit */
-#define MAX_CHARGE_LEVEL 1900
+#define MAX_CHARGE_LEVEL 2100
 
 extern int failsafe;
 #define FAIL_SAFE_ENABLED 1	/* default */
