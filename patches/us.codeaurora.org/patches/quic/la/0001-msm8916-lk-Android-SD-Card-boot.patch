From a53cea831bc65e6a85436707e6e7461895f655a8 Mon Sep 17 00:00:00 2001
From: Baji Patthan <bpatth@codeaurora.org>
Date: Fri, 1 May 2015 20:16:24 -0700
Subject: [PATCH] msm8916: lk: Android SD Card boot

msm8916: lk: Needed changes for the Android SD Card Boot

Change-Id: I8af6a2527f4f8063d25a46bce30590289f376ede
Signed-off-by: Baji Patthan <bpatth@codeaurora.org>
---
 platform/msm8916/include/platform/iomap.h |  1 +
 platform/msm8916/rules.mk                 |  2 +-
 platform/msm_shared/mmc_sdhci.c           |  3 ++
 target/msm8916/init.c                     | 54 ++++++++++++++++++++++++-------
 4 files changed, 47 insertions(+), 13 deletions(-)

diff --git a/platform/msm8916/include/platform/iomap.h b/platform/msm8916/include/platform/iomap.h
index 73b462e..31e9582 100644
--- a/platform/msm8916/include/platform/iomap.h
+++ b/platform/msm8916/include/platform/iomap.h
@@ -122,6 +122,7 @@
 #define SDCC1_N                     (CLK_CTL_BASE + 0x42010) /* n */
 #define SDCC1_D                     (CLK_CTL_BASE + 0x42014) /* d */
 
+#define SDC2_HDRV_PULL_CTL          (TLMM_BASE_ADDR + 0x109000)
 #define SDCC2_BCR                   (CLK_CTL_BASE + 0x43000) /* block reset */
 #define SDCC2_APPS_CBCR             (CLK_CTL_BASE + 0x43018) /* branch control */
 #define SDCC2_AHB_CBCR              (CLK_CTL_BASE + 0x4301C)
diff --git a/platform/msm8916/rules.mk b/platform/msm8916/rules.mk
index b0a2070..d57b92c 100644
--- a/platform/msm8916/rules.mk
+++ b/platform/msm8916/rules.mk
@@ -7,7 +7,7 @@ CPU     := generic
 
 DEFINES += ARM_CPU_CORE_A7
 
-MMC_SLOT         := 1
+MMC_SLOT         := 2
 
 DEFINES += PERIPH_BLK_BLSP=1
 DEFINES += WITH_CPU_EARLY_INIT=0 WITH_CPU_WARM_BOOT=0 \
diff --git a/platform/msm_shared/mmc_sdhci.c b/platform/msm_shared/mmc_sdhci.c
index a64df70..58657cb 100644
--- a/platform/msm_shared/mmc_sdhci.c
+++ b/platform/msm_shared/mmc_sdhci.c
@@ -232,6 +232,7 @@ static uint32_t mmc_decode_and_save_csd(struct mmc_card *card)
 	memcpy((struct mmc_csd *)&card->csd,(struct mmc_csd *)&mmc_csd,
 			sizeof(struct mmc_csd));
 
+#if 0
 	/* Calculate the wp grp size */
 	if (card->ext_csd[MMC_ERASE_GRP_DEF])
 		card->wp_grp_size = MMC_HC_ERASE_MULT * card->ext_csd[MMC_HC_ERASE_GRP_SIZE] / MMC_BLK_SZ;
@@ -239,6 +240,7 @@ static uint32_t mmc_decode_and_save_csd(struct mmc_card *card)
 		card->wp_grp_size = (card->csd.wp_grp_size + 1) * (card->csd.erase_grp_size + 1) \
 					  * (card->csd.erase_grp_mult + 1);
 
+#endif
 	dprintf(SPEW, "Decoded CSD fields:\n");
 	dprintf(SPEW, "cmmc_structure: %u\n", mmc_csd.cmmc_structure);
 	dprintf(SPEW, "card_cmd_class: %x\n", mmc_csd.card_cmd_class);
@@ -1451,6 +1453,7 @@ uint32_t mmc_sd_set_hs(struct sdhci_host *host, struct mmc_card *card)
        cmd.data.num_blocks = 0x1;
        cmd.data.blk_sz = 0x40;
 
+
        /* send command */
        if (sdhci_send_command(host, &cmd))
              return 1;
diff --git a/target/msm8916/init.c b/target/msm8916/init.c
index f3f3854..98e501e 100644
--- a/target/msm8916/init.c
+++ b/target/msm8916/init.c
@@ -76,7 +76,7 @@
 #define CE_WRITE_PIPE_LOCK_GRP  0
 #define CE_ARRAY_SIZE           20
 
-static void set_sdc_power_ctrl(void);
+static void set_sdc_power_ctrl(uint8_t slot);
 
 struct mmc_device *dev;
 
@@ -100,18 +100,20 @@ void target_sdc_init()
 {
 	struct mmc_config_data config;
 
-	/* Set drive strength & pull ctrl values */
-	set_sdc_power_ctrl();
 
-	config.bus_width = DATA_BUS_WIDTH_8BIT;
+	config.bus_width = DATA_BUS_WIDTH_4BIT;
 	config.max_clk_rate = MMC_CLK_177MHZ;
 
 	/* Try slot 1*/
-	config.slot         = 1;
+	config.slot         = MMC_SLOT;
 	config.sdhc_base    = mmc_sdhci_base[config.slot - 1];
 	config.pwrctl_base  = mmc_pwrctl_base[config.slot - 1];
 	config.pwr_irq      = mmc_sdc_pwrctl_irq[config.slot - 1];
 	config.hs400_support = 0;
+	dprintf(CRITICAL, "initialising mmc_slot =%u\n",MMC_SLOT);
+
+	/* Set drive strength & pull ctrl values */
+	set_sdc_power_ctrl(config.slot);
 
 	if (!(dev = mmc_init(&config))) {
 	/* Try slot 2 */
@@ -121,6 +123,9 @@ void target_sdc_init()
 		config.pwrctl_base  = mmc_pwrctl_base[config.slot - 1];
 		config.pwr_irq      = mmc_sdc_pwrctl_irq[config.slot - 1];
 
+		/* Set drive strength & pull ctrl values */
+		set_sdc_power_ctrl(config.slot);
+
 		if (!(dev = mmc_init(&config))) {
 			dprintf(CRITICAL, "mmc init failed!");
 			ASSERT(0);
@@ -363,22 +368,47 @@ int emmc_recovery_init(void)
 	return _emmc_recovery_init();
 }
 
-static void set_sdc_power_ctrl()
+static void set_sdc_power_ctrl(uint8_t slot)
 {
+	uint32_t reg = 0;
+	uint8_t clk;
+	uint8_t cmd;
+	uint8_t dat;
+
+	if(slot == 1)
+	{
+		clk = TLMM_CUR_VAL_16MA;
+		cmd = TLMM_CUR_VAL_10MA;
+		dat = TLMM_CUR_VAL_10MA;
+		reg = SDC1_HDRV_PULL_CTL;
+	}
+	else if(slot == 2)
+	{
+		clk = TLMM_CUR_VAL_16MA;
+		cmd = TLMM_CUR_VAL_10MA;
+		dat = TLMM_CUR_VAL_10MA;
+		reg = SDC2_HDRV_PULL_CTL;
+	}
+	else
+	{
+		dprintf(CRITICAL,"Unsupported SDC slot passed\n");
+		return;
+	}
+
 	/* Drive strength configs for sdc pins */
 	struct tlmm_cfgs sdc1_hdrv_cfg[] =
 	{
-		{ SDC1_CLK_HDRV_CTL_OFF,  TLMM_CUR_VAL_16MA, TLMM_HDRV_MASK },
-		{ SDC1_CMD_HDRV_CTL_OFF,  TLMM_CUR_VAL_10MA, TLMM_HDRV_MASK },
-		{ SDC1_DATA_HDRV_CTL_OFF, TLMM_CUR_VAL_6MA, TLMM_HDRV_MASK },
+		{ SDC1_CLK_HDRV_CTL_OFF,  clk, TLMM_HDRV_MASK, reg },
+		{ SDC1_CMD_HDRV_CTL_OFF,  cmd, TLMM_HDRV_MASK, reg },
+		{ SDC1_DATA_HDRV_CTL_OFF, dat, TLMM_HDRV_MASK, reg },
 	};
 
 	/* Pull configs for sdc pins */
 	struct tlmm_cfgs sdc1_pull_cfg[] =
 	{
-		{ SDC1_CLK_PULL_CTL_OFF,  TLMM_NO_PULL, TLMM_PULL_MASK },
-		{ SDC1_CMD_PULL_CTL_OFF,  TLMM_PULL_UP, TLMM_PULL_MASK },
-		{ SDC1_DATA_PULL_CTL_OFF, TLMM_PULL_UP, TLMM_PULL_MASK },
+		{ SDC1_CLK_PULL_CTL_OFF,  TLMM_NO_PULL, TLMM_PULL_MASK, reg },
+		{ SDC1_CMD_PULL_CTL_OFF,  TLMM_PULL_UP, TLMM_PULL_MASK, reg },
+		{ SDC1_DATA_PULL_CTL_OFF, TLMM_PULL_UP, TLMM_PULL_MASK, reg },
 	};
 
 	/* Set the drive strength & pull control values */
-- 
1.8.2.1

